import "./chunk-4AGKJI2U.js";
import {
  add_locations,
  attribute_effect,
  check_target,
  component,
  hmr,
  if_block,
  legacy_api,
  prop,
  rest_props,
  set_attribute,
  spread_props
} from "./chunk-HZUMA3JB.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_svg,
  set_text
} from "./chunk-3KODWDKR.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  first_child,
  getContext,
  next,
  pop,
  push,
  reset,
  set,
  sibling,
  template_effect
} from "./chunk-RVR3TTMP.js";
import "./chunk-257HUYHO.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-K63UQA3V.js";
import "./chunk-5AQFBOJN.js";

// node_modules/flowbite-svelte-icons/node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
var createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var validators = Object.defineProperty({
  __proto__: null,
  isAny,
  isAnyNonArbitrary,
  isArbitraryImage,
  isArbitraryLength,
  isArbitraryNumber,
  isArbitraryPosition,
  isArbitraryShadow,
  isArbitrarySize,
  isArbitraryValue,
  isArbitraryVariable,
  isArbitraryVariableFamilyName,
  isArbitraryVariableImage,
  isArbitraryVariableLength,
  isArbitraryVariablePosition,
  isArbitraryVariableShadow,
  isArbitraryVariableSize,
  isFraction,
  isInteger,
  isNumber,
  isPercent,
  isTshirtSize
}, Symbol.toStringTag, {
  value: "Module"
});
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = createTailwindMerge(getDefaultConfig);

// node_modules/flowbite-svelte-icons/dist/helpers.js
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// node_modules/flowbite-svelte-icons/dist/AddColumnAfterOutline.svelte
AddColumnAfterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddColumnAfterOutline.svelte";
var root_1 = add_locations(from_svg(`<title> </title>`), AddColumnAfterOutline[FILENAME], [[43, 4]]);
var root_2 = add_locations(from_svg(`<desc> </desc>`), AddColumnAfterOutline[FILENAME], [[46, 4]]);
var root = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 5v14m8-7h-2m0 0h-2m2 0v2m0-2v-2M3 11h6m-6 4h6m11 4H4c-.55228 0-1-.4477-1-1V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v12c0 .5523-.4477 1-1 1Z"></path></svg>`), AddColumnAfterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AddColumnAfterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AddColumnAfterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AddColumnAfterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AddColumnAfterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AddColumnAfterOutline = hmr(AddColumnAfterOutline, () => AddColumnAfterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddColumnAfterOutline[HMR].source;
    set(AddColumnAfterOutline[HMR].source, module.default[HMR].original);
  });
}
var AddColumnAfterOutline_default = AddColumnAfterOutline;

// node_modules/flowbite-svelte-icons/dist/AddColumnBeforeOutline.svelte
AddColumnBeforeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddColumnBeforeOutline.svelte";
var root_12 = add_locations(from_svg(`<title> </title>`), AddColumnBeforeOutline[FILENAME], [[43, 4]]);
var root_22 = add_locations(from_svg(`<desc> </desc>`), AddColumnBeforeOutline[FILENAME], [[46, 4]]);
var root2 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14m-8-7h2m0 0h2m-2 0v2m0-2v-2m12 1h-6m6 4h-6M4 19h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Z"></path></svg>`), AddColumnBeforeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AddColumnBeforeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AddColumnBeforeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root2();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_12();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AddColumnBeforeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_22();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AddColumnBeforeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AddColumnBeforeOutline = hmr(AddColumnBeforeOutline, () => AddColumnBeforeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddColumnBeforeOutline[HMR].source;
    set(AddColumnBeforeOutline[HMR].source, module.default[HMR].original);
  });
}
var AddColumnBeforeOutline_default = AddColumnBeforeOutline;

// node_modules/flowbite-svelte-icons/dist/AddressBookOutline.svelte
AddressBookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddressBookOutline.svelte";
var root_13 = add_locations(from_svg(`<title> </title>`), AddressBookOutline[FILENAME], [[43, 4]]);
var root_23 = add_locations(from_svg(`<desc> </desc>`), AddressBookOutline[FILENAME], [[46, 4]]);
var root3 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 6H5m2 3H5m2 3H5m2 3H5m2 3H5m11-1a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2M7 3h11a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1Zm8 7a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AddressBookOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AddressBookOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AddressBookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root3();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_13();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AddressBookOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_23();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AddressBookOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AddressBookOutline = hmr(AddressBookOutline, () => AddressBookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddressBookOutline[HMR].source;
    set(AddressBookOutline[HMR].source, module.default[HMR].original);
  });
}
var AddressBookOutline_default = AddressBookOutline;

// node_modules/flowbite-svelte-icons/dist/AddressBookSolid.svelte
AddressBookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddressBookSolid.svelte";
var root_14 = add_locations(from_svg(`<title> </title>`), AddressBookSolid[FILENAME], [[41, 4]]);
var root_24 = add_locations(from_svg(`<desc> </desc>`), AddressBookSolid[FILENAME], [[44, 4]]);
var root4 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7 2a2 2 0 0 0-2 2v1a1 1 0 0 0 0 2v1a1 1 0 0 0 0 2v1a1 1 0 1 0 0 2v1a1 1 0 1 0 0 2v1a1 1 0 1 0 0 2v1a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H7Zm3 8a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-1 7a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3 1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), AddressBookSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AddressBookSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AddressBookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root4();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_14();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AddressBookSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_24();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AddressBookSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AddressBookSolid = hmr(AddressBookSolid, () => AddressBookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddressBookSolid[HMR].source;
    set(AddressBookSolid[HMR].source, module.default[HMR].original);
  });
}
var AddressBookSolid_default = AddressBookSolid;

// node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalOutline.svelte
AdjustmentsHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalOutline.svelte";
var root_15 = add_locations(from_svg(`<title> </title>`), AdjustmentsHorizontalOutline[FILENAME], [[43, 4]]);
var root_25 = add_locations(from_svg(`<desc> </desc>`), AdjustmentsHorizontalOutline[FILENAME], [[46, 4]]);
var root5 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M20 6H10m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4m16 6h-2m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4m16 6H10m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4"></path></svg>`), AdjustmentsHorizontalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AdjustmentsHorizontalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AdjustmentsHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root5();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_15();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AdjustmentsHorizontalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_25();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AdjustmentsHorizontalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AdjustmentsHorizontalOutline = hmr(AdjustmentsHorizontalOutline, () => AdjustmentsHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsHorizontalOutline[HMR].source;
    set(AdjustmentsHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsHorizontalOutline_default = AdjustmentsHorizontalOutline;

// node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalSolid.svelte
AdjustmentsHorizontalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalSolid.svelte";
var root_16 = add_locations(from_svg(`<title> </title>`), AdjustmentsHorizontalSolid[FILENAME], [[41, 4]]);
var root_26 = add_locations(from_svg(`<desc> </desc>`), AdjustmentsHorizontalSolid[FILENAME], [[44, 4]]);
var root6 = add_locations(from_svg(`<svg><!><!><path d="M10.83 5a3.001 3.001 0 0 0-5.66 0H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17ZM4 11h9.17a3.001 3.001 0 0 1 5.66 0H20a1 1 0 1 1 0 2h-1.17a3.001 3.001 0 0 1-5.66 0H4a1 1 0 1 1 0-2Zm1.17 6H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17a3.001 3.001 0 0 0-5.66 0Z"></path></svg>`), AdjustmentsHorizontalSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AdjustmentsHorizontalSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AdjustmentsHorizontalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root6();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_16();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AdjustmentsHorizontalSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_26();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AdjustmentsHorizontalSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AdjustmentsHorizontalSolid = hmr(AdjustmentsHorizontalSolid, () => AdjustmentsHorizontalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsHorizontalSolid[HMR].source;
    set(AdjustmentsHorizontalSolid[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsHorizontalSolid_default = AdjustmentsHorizontalSolid;

// node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalOutline.svelte
AdjustmentsVerticalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalOutline.svelte";
var root_17 = add_locations(from_svg(`<title> </title>`), AdjustmentsVerticalOutline[FILENAME], [[43, 4]]);
var root_27 = add_locations(from_svg(`<desc> </desc>`), AdjustmentsVerticalOutline[FILENAME], [[46, 4]]);
var root7 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M6 4v10m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v2m6-16v2m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v10m6-16v10m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v2"></path></svg>`), AdjustmentsVerticalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AdjustmentsVerticalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AdjustmentsVerticalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root7();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_17();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AdjustmentsVerticalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_27();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AdjustmentsVerticalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AdjustmentsVerticalOutline = hmr(AdjustmentsVerticalOutline, () => AdjustmentsVerticalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsVerticalOutline[HMR].source;
    set(AdjustmentsVerticalOutline[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsVerticalOutline_default = AdjustmentsVerticalOutline;

// node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalSolid.svelte
AdjustmentsVerticalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalSolid.svelte";
var root_18 = add_locations(from_svg(`<title> </title>`), AdjustmentsVerticalSolid[FILENAME], [[41, 4]]);
var root_28 = add_locations(from_svg(`<desc> </desc>`), AdjustmentsVerticalSolid[FILENAME], [[44, 4]]);
var root8 = add_locations(from_svg(`<svg><!><!><path d="M5 13.17a3.001 3.001 0 0 0 0 5.66V20a1 1 0 1 0 2 0v-1.17a3.001 3.001 0 0 0 0-5.66V4a1 1 0 0 0-2 0v9.17ZM11 20v-9.17a3.001 3.001 0 0 1 0-5.66V4a1 1 0 1 1 2 0v1.17a3.001 3.001 0 0 1 0 5.66V20a1 1 0 1 1-2 0Zm6-1.17V20a1 1 0 1 0 2 0v-1.17a3.001 3.001 0 0 0 0-5.66V4a1 1 0 1 0-2 0v9.17a3.001 3.001 0 0 0 0 5.66Z"></path></svg>`), AdjustmentsVerticalSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AdjustmentsVerticalSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AdjustmentsVerticalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root8();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_18();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AdjustmentsVerticalSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_28();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AdjustmentsVerticalSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AdjustmentsVerticalSolid = hmr(AdjustmentsVerticalSolid, () => AdjustmentsVerticalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsVerticalSolid[HMR].source;
    set(AdjustmentsVerticalSolid[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsVerticalSolid_default = AdjustmentsVerticalSolid;

// node_modules/flowbite-svelte-icons/dist/AlignCenterOutline.svelte
AlignCenterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignCenterOutline.svelte";
var root_19 = add_locations(from_svg(`<title> </title>`), AlignCenterOutline[FILENAME], [[43, 4]]);
var root_29 = add_locations(from_svg(`<desc> </desc>`), AlignCenterOutline[FILENAME], [[46, 4]]);
var root9 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 6h8M6 10h12M8 14h8M6 18h12"></path></svg>`), AlignCenterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AlignCenterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AlignCenterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root9();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_19();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AlignCenterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_29();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AlignCenterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AlignCenterOutline = hmr(AlignCenterOutline, () => AlignCenterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignCenterOutline[HMR].source;
    set(AlignCenterOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignCenterOutline_default = AlignCenterOutline;

// node_modules/flowbite-svelte-icons/dist/AlignJustifyOutline.svelte
AlignJustifyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignJustifyOutline.svelte";
var root_110 = add_locations(from_svg(`<title> </title>`), AlignJustifyOutline[FILENAME], [[43, 4]]);
var root_210 = add_locations(from_svg(`<desc> </desc>`), AlignJustifyOutline[FILENAME], [[46, 4]]);
var root10 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 6H6m12 4H6m12 4H6m12 4H6"></path></svg>`), AlignJustifyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AlignJustifyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AlignJustifyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root10();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_110();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AlignJustifyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_210();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AlignJustifyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AlignJustifyOutline = hmr(AlignJustifyOutline, () => AlignJustifyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignJustifyOutline[HMR].source;
    set(AlignJustifyOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignJustifyOutline_default = AlignJustifyOutline;

// node_modules/flowbite-svelte-icons/dist/AlignLeftOutline.svelte
AlignLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignLeftOutline.svelte";
var root_111 = add_locations(from_svg(`<title> </title>`), AlignLeftOutline[FILENAME], [[43, 4]]);
var root_211 = add_locations(from_svg(`<desc> </desc>`), AlignLeftOutline[FILENAME], [[46, 4]]);
var root11 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h8m-8 4h12M6 14h8m-8 4h12"></path></svg>`), AlignLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AlignLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AlignLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root11();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_111();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AlignLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_211();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AlignLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AlignLeftOutline = hmr(AlignLeftOutline, () => AlignLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignLeftOutline[HMR].source;
    set(AlignLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignLeftOutline_default = AlignLeftOutline;

// node_modules/flowbite-svelte-icons/dist/AlignRightOutline.svelte
AlignRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignRightOutline.svelte";
var root_112 = add_locations(from_svg(`<title> </title>`), AlignRightOutline[FILENAME], [[43, 4]]);
var root_212 = add_locations(from_svg(`<desc> </desc>`), AlignRightOutline[FILENAME], [[46, 4]]);
var root12 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 6h-8m8 4H6m12 4h-8m8 4H6"></path></svg>`), AlignRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AlignRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AlignRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root12();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_112();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AlignRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_212();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AlignRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AlignRightOutline = hmr(AlignRightOutline, () => AlignRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignRightOutline[HMR].source;
    set(AlignRightOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignRightOutline_default = AlignRightOutline;

// node_modules/flowbite-svelte-icons/dist/AngleDownOutline.svelte
AngleDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleDownOutline.svelte";
var root_113 = add_locations(from_svg(`<title> </title>`), AngleDownOutline[FILENAME], [[43, 4]]);
var root_213 = add_locations(from_svg(`<desc> </desc>`), AngleDownOutline[FILENAME], [[46, 4]]);
var root13 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m19 9-7 7-7-7"></path></svg>`), AngleDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AngleDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AngleDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root13();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_113();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AngleDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_213();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AngleDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AngleDownOutline = hmr(AngleDownOutline, () => AngleDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleDownOutline[HMR].source;
    set(AngleDownOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleDownOutline_default = AngleDownOutline;

// node_modules/flowbite-svelte-icons/dist/AngleLeftOutline.svelte
AngleLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleLeftOutline.svelte";
var root_114 = add_locations(from_svg(`<title> </title>`), AngleLeftOutline[FILENAME], [[43, 4]]);
var root_214 = add_locations(from_svg(`<desc> </desc>`), AngleLeftOutline[FILENAME], [[46, 4]]);
var root14 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15 19-7-7 7-7"></path></svg>`), AngleLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AngleLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AngleLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root14();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_114();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AngleLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_214();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AngleLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AngleLeftOutline = hmr(AngleLeftOutline, () => AngleLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleLeftOutline[HMR].source;
    set(AngleLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleLeftOutline_default = AngleLeftOutline;

// node_modules/flowbite-svelte-icons/dist/AngleRightOutline.svelte
AngleRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleRightOutline.svelte";
var root_115 = add_locations(from_svg(`<title> </title>`), AngleRightOutline[FILENAME], [[43, 4]]);
var root_215 = add_locations(from_svg(`<desc> </desc>`), AngleRightOutline[FILENAME], [[46, 4]]);
var root15 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m9 5 7 7-7 7"></path></svg>`), AngleRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AngleRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AngleRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root15();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_115();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AngleRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_215();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AngleRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AngleRightOutline = hmr(AngleRightOutline, () => AngleRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleRightOutline[HMR].source;
    set(AngleRightOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleRightOutline_default = AngleRightOutline;

// node_modules/flowbite-svelte-icons/dist/AngleUpOutline.svelte
AngleUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleUpOutline.svelte";
var root_116 = add_locations(from_svg(`<title> </title>`), AngleUpOutline[FILENAME], [[43, 4]]);
var root_216 = add_locations(from_svg(`<desc> </desc>`), AngleUpOutline[FILENAME], [[46, 4]]);
var root16 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m5 15 7-7 7 7"></path></svg>`), AngleUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AngleUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AngleUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root16();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_116();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AngleUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_216();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AngleUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AngleUpOutline = hmr(AngleUpOutline, () => AngleUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleUpOutline[HMR].source;
    set(AngleUpOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleUpOutline_default = AngleUpOutline;

// node_modules/flowbite-svelte-icons/dist/AnnotationOutline.svelte
AnnotationOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AnnotationOutline.svelte";
var root_117 = add_locations(from_svg(`<title> </title>`), AnnotationOutline[FILENAME], [[43, 4]]);
var root_217 = add_locations(from_svg(`<desc> </desc>`), AnnotationOutline[FILENAME], [[46, 4]]);
var root17 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.556 8.5h8m-8 3.5H12m7.111-7H4.89a.896.896 0 0 0-.629.256.868.868 0 0 0-.26.619v9.25c0 .232.094.455.26.619A.896.896 0 0 0 4.89 16H9l3 4 3-4h4.111a.896.896 0 0 0 .629-.256.868.868 0 0 0 .26-.619v-9.25a.868.868 0 0 0-.26-.619.896.896 0 0 0-.63-.256Z"></path></svg>`), AnnotationOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AnnotationOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AnnotationOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root17();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_117();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AnnotationOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_217();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AnnotationOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AnnotationOutline = hmr(AnnotationOutline, () => AnnotationOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnnotationOutline[HMR].source;
    set(AnnotationOutline[HMR].source, module.default[HMR].original);
  });
}
var AnnotationOutline_default = AnnotationOutline;

// node_modules/flowbite-svelte-icons/dist/AnnotationSolid.svelte
AnnotationSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AnnotationSolid.svelte";
var root_118 = add_locations(from_svg(`<title> </title>`), AnnotationSolid[FILENAME], [[41, 4]]);
var root_218 = add_locations(from_svg(`<desc> </desc>`), AnnotationSolid[FILENAME], [[44, 4]]);
var root18 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3.559 4.544c.355-.35.834-.544 1.33-.544H19.11c.496 0 .975.194 1.33.544.356.35.559.829.559 1.331v9.25c0 .502-.203.981-.559 1.331-.355.35-.834.544-1.33.544H15.5l-2.7 3.6a1 1 0 0 1-1.6 0L8.5 17H4.889c-.496 0-.975-.194-1.33-.544A1.868 1.868 0 0 1 3 15.125v-9.25c0-.502.203-.981.559-1.331ZM7.556 7.5a1 1 0 1 0 0 2h8a1 1 0 0 0 0-2h-8Zm0 3.5a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2H7.556Z" clip-rule="evenodd"></path></svg>`), AnnotationSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AnnotationSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AnnotationSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root18();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_118();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AnnotationSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_218();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AnnotationSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AnnotationSolid = hmr(AnnotationSolid, () => AnnotationSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnnotationSolid[HMR].source;
    set(AnnotationSolid[HMR].source, module.default[HMR].original);
  });
}
var AnnotationSolid_default = AnnotationSolid;

// node_modules/flowbite-svelte-icons/dist/ApiKeyOutline.svelte
ApiKeyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ApiKeyOutline.svelte";
var root_119 = add_locations(from_svg(`<title> </title>`), ApiKeyOutline[FILENAME], [[43, 4]]);
var root_219 = add_locations(from_svg(`<desc> </desc>`), ApiKeyOutline[FILENAME], [[46, 4]]);
var root19 = add_locations(from_svg(`<svg><!><!><path d="M6.94318 11h-.85227l.96023-2.90909h1.07954L9.09091 11h-.85227l-.63637-2.10795h-.02272L6.94318 11Zm-.15909-1.14773h1.60227v.59093H6.78409v-.59093ZM9.37109 11V8.09091h1.25571c.2159 0 .4048.04261.5667.12784.162.08523.2879.20502.3779.35937.0899.15436.1349.33476.1349.5412 0 .20833-.0464.38873-.1392.54119-.0918.15246-.2211.26989-.3878.35229-.1657.0824-.3593.1236-.5809.1236h-.75003v-.61367h.59093c.0928 0 .1719-.0161.2372-.0483.0663-.03314.1169-.08002.152-.14062.036-.06061.054-.13211.054-.21449 0-.08334-.018-.15436-.054-.21307-.0351-.05966-.0857-.10511-.152-.13636-.0653-.0322-.1444-.0483-.2372-.0483h-.2784V11h-.78981Zm3.41481-2.90909V11h-.7898V8.09091h.7898Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M8.31818 2c-.55228 0-1 .44772-1 1v.72878c-.06079.0236-.12113.04809-.18098.07346l-.55228-.53789c-.38828-.37817-1.00715-.37817-1.39543 0L3.30923 5.09564c-.19327.18824-.30229.44659-.30229.71638 0 .26979.10902.52813.30229.71637l.52844.51468c-.01982.04526-.03911.0908-.05785.13662H3c-.55228 0-1 .44771-1 1v2.58981c0 .5523.44772 1 1 1h.77982c.01873.0458.03802.0914.05783.1366l-.52847.5147c-.19327.1883-.30228.4466-.30228.7164 0 .2698.10901.5281.30228.7164l1.88026 1.8313c.38828.3781 1.00715.3781 1.39544 0l.55228-.5379c.05987.0253.12021.0498.18102.0734v.7288c0 .5523.44772 1 1 1h2.65912c.5523 0 1-.4477 1-1v-.7288c.1316-.0511.2612-.1064.3883-.1657l.5435.2614v.4339c0 .5523.4477 1 1 1H14v.0625c0 .5523.4477 1 1 1h.0909v.0625c0 .5523.4477 1 1 1h.6844l.4952.4823c1.1648 1.1345 3.0214 1.1345 4.1863 0l.2409-.2347c.1961-.191.3053-.454.3022-.7277-.0031-.2737-.1183-.5342-.3187-.7207l-6.2162-5.7847c.0173-.0398.0342-.0798.0506-.12h.7799c.5522 0 1-.4477 1-1V8.17969c0-.55229-.4478-1-1-1h-.7799c-.0187-.04583-.038-.09139-.0578-.13666l.5284-.51464c.1933-.18824.3023-.44659.3023-.71638 0-.26979-.109-.52813-.3023-.71637l-1.8803-1.8313c-.3883-.37816-1.0071-.37816-1.3954 0l-.5523.53788c-.0598-.02536-.1201-.04985-.1809-.07344V3c0-.55228-.4477-1-1-1H8.31818Z"></path></svg>`), ApiKeyOutline[FILENAME], [[31, 0, [[48, 2], [51, 2]]]]);
function ApiKeyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ApiKeyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root19();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_119();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ApiKeyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_219();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ApiKeyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ApiKeyOutline = hmr(ApiKeyOutline, () => ApiKeyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ApiKeyOutline[HMR].source;
    set(ApiKeyOutline[HMR].source, module.default[HMR].original);
  });
}
var ApiKeyOutline_default = ApiKeyOutline;

// node_modules/flowbite-svelte-icons/dist/AppleFullOutline.svelte
AppleFullOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AppleFullOutline.svelte";
var root_120 = add_locations(from_svg(`<title> </title>`), AppleFullOutline[FILENAME], [[43, 4]]);
var root_220 = add_locations(from_svg(`<desc> </desc>`), AppleFullOutline[FILENAME], [[46, 4]]);
var root20 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 10.0419c-1.3902 0-1.3935-1.1249-4.20643-1.037-1.73056.05408-3.15551 2.2303-2.71168 5.3081C5.35949 16.2381 6.98619 21 8.99172 21c2.00548 0 2.07358-.8508 3.00828-.8508.9347 0 .8551.8508 3.0083.8508s3.6322-4.7619 3.9098-6.687c.4438-3.0778-.9811-5.25402-2.7117-5.3081-2.8129-.0879-2.8162 1.037-4.2064 1.037Zm2.3598-4.2126c-.8779.74829-1.8612.71957-2.7221.71957 0-.62576.0792-1.94012.8609-2.76911.7817-.82898 2.1271-.7664 2.6434-.7664 0 .59448.0956 2.06766-.7822 2.81594Z"></path></svg>`), AppleFullOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AppleFullOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AppleFullOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root20();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_120();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AppleFullOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_220();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AppleFullOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AppleFullOutline = hmr(AppleFullOutline, () => AppleFullOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AppleFullOutline[HMR].source;
    set(AppleFullOutline[HMR].source, module.default[HMR].original);
  });
}
var AppleFullOutline_default = AppleFullOutline;

// node_modules/flowbite-svelte-icons/dist/AppleFullSolid.svelte
AppleFullSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AppleFullSolid.svelte";
var root_121 = add_locations(from_svg(`<title> </title>`), AppleFullSolid[FILENAME], [[41, 4]]);
var root_221 = add_locations(from_svg(`<desc> </desc>`), AppleFullSolid[FILENAME], [[44, 4]]);
var root21 = add_locations(from_svg(`<svg><!><!><path d="M15.0524 2.01283c-.2634-.00221-.7706-.00646-1.3064.08808-.6053.10681-1.377.35866-1.975.99279-.557.59067-.8308 1.31504-.9706 1.92248-.1413.61388-.1628 1.1828-.1628 1.5327v1h1c.0429 0 .0873.00018.1333.00036.8172.00329 2.1026.00847 3.2375-.9589.7023-.59862.9572-1.43277 1.059-2.06861.0871-.54385.0798-1.08153.0758-1.37798-.0007-.051-.0013-.09486-.0013-.13038v-1h-1c-.0255 0-.0554-.00025-.0895-.00054Zm-3.0525 7.02912c-.2934 0-.3974-.0566-.7263-.23555-.1027-.05589-.2273-.12372-.3865-.20548-.6797-.34907-1.55211-.64467-3.12486-.59552-1.30968.04093-2.37715.88151-3.01521 2.0359-.64078 1.1594-.90215 2.7005-.65499 4.4145.1543 1.07.66239 2.84 1.39644 4.358.36735.7596.81762 1.5119 1.34963 2.0895C7.35502 21.4646 8.08053 22 8.99163 22c1.17857 0 1.86287-.2589 2.38977-.5504.1663-.092.2761-.1558.3523-.2001.1161-.0674.1542-.0895.1949-.0968.0198-.0035.0403-.0035.0708-.0035.0105 0 .0195-.0003.0268-.0005.0132-.0003.0222-.0006.031.0009.0193.0032.0373.0146.095.0514.0638.0408.1761.1125.3925.2382.5319.3091 1.2263.5608 2.4635.5608.9293 0 1.6712-.5145 2.2105-1.0909.5456-.5832.9936-1.3421 1.3526-2.1048.7186-1.5268 1.1845-3.2947 1.3365-4.3485.2471-1.714-.0142-3.2551-.655-4.4145-.6381-1.15439-1.7055-1.99497-3.0152-2.0359-1.5728-.04915-2.4451.24645-3.1248.59552-.1592.08176-.2839.14959-.3866.20548-.3289.17895-.4329.23555-.7263.23555Z"></path></svg>`), AppleFullSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AppleFullSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AppleFullSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root21();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_121();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AppleFullSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_221();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AppleFullSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AppleFullSolid = hmr(AppleFullSolid, () => AppleFullSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AppleFullSolid[HMR].source;
    set(AppleFullSolid[HMR].source, module.default[HMR].original);
  });
}
var AppleFullSolid_default = AppleFullSolid;

// node_modules/flowbite-svelte-icons/dist/AppleSolid.svelte
AppleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AppleSolid.svelte";
var root_122 = add_locations(from_svg(`<title> </title>`), AppleSolid[FILENAME], [[41, 4]]);
var root_222 = add_locations(from_svg(`<desc> </desc>`), AppleSolid[FILENAME], [[44, 4]]);
var root22 = add_locations(from_svg(`<svg><!><!><path d="M17.537 12.625a4.421 4.421 0 0 0 2.684 4.047 10.96 10.96 0 0 1-1.384 2.845c-.834 1.218-1.7 2.432-3.062 2.457-1.34.025-1.77-.794-3.3-.794-1.531 0-2.01.769-3.275.82-1.316.049-2.317-1.318-3.158-2.532-1.72-2.484-3.032-7.017-1.27-10.077A4.9 4.9 0 0 1 8.91 6.884c1.292-.025 2.51.869 3.3.869.789 0 2.27-1.075 3.828-.917a4.67 4.67 0 0 1 3.66 1.984 4.524 4.524 0 0 0-2.16 3.805m-2.52-7.432A4.4 4.4 0 0 0 16.06 2a4.482 4.482 0 0 0-2.945 1.516 4.185 4.185 0 0 0-1.061 3.093 3.708 3.708 0 0 0 2.967-1.416Z"></path></svg>`), AppleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function AppleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AppleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root22();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_122();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AppleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_222();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AppleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AppleSolid = hmr(AppleSolid, () => AppleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AppleSolid[HMR].source;
    set(AppleSolid[HMR].source, module.default[HMR].original);
  });
}
var AppleSolid_default = AppleSolid;

// node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownOutline.svelte
ArchiveArrowDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownOutline.svelte";
var root_123 = add_locations(from_svg(`<title> </title>`), ArchiveArrowDownOutline[FILENAME], [[43, 4]]);
var root_223 = add_locations(from_svg(`<desc> </desc>`), ArchiveArrowDownOutline[FILENAME], [[46, 4]]);
var root23 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 11v5m0 0 2-2m-2 2-2-2M3 6v1a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1Zm2 2v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V8H5Z"></path></svg>`), ArchiveArrowDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArchiveArrowDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArchiveArrowDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root23();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_123();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArchiveArrowDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_223();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArchiveArrowDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArchiveArrowDownOutline = hmr(ArchiveArrowDownOutline, () => ArchiveArrowDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveArrowDownOutline[HMR].source;
    set(ArchiveArrowDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArchiveArrowDownOutline_default = ArchiveArrowDownOutline;

// node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownSolid.svelte
ArchiveArrowDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownSolid.svelte";
var root_124 = add_locations(from_svg(`<title> </title>`), ArchiveArrowDownSolid[FILENAME], [[41, 4]]);
var root_224 = add_locations(from_svg(`<desc> </desc>`), ArchiveArrowDownSolid[FILENAME], [[44, 4]]);
var root24 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 1 0 0 4h16a2 2 0 1 0 0-4H4Zm0 6h16v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8Zm10.707 5.707a1 1 0 0 0-1.414-1.414l-.293.293V12a1 1 0 1 0-2 0v2.586l-.293-.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l2-2Z" clip-rule="evenodd"></path></svg>`), ArchiveArrowDownSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ArchiveArrowDownSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArchiveArrowDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root24();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_124();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArchiveArrowDownSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_224();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArchiveArrowDownSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArchiveArrowDownSolid = hmr(ArchiveArrowDownSolid, () => ArchiveArrowDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveArrowDownSolid[HMR].source;
    set(ArchiveArrowDownSolid[HMR].source, module.default[HMR].original);
  });
}
var ArchiveArrowDownSolid_default = ArchiveArrowDownSolid;

// node_modules/flowbite-svelte-icons/dist/ArchiveOutline.svelte
ArchiveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveOutline.svelte";
var root_125 = add_locations(from_svg(`<title> </title>`), ArchiveOutline[FILENAME], [[43, 4]]);
var root_225 = add_locations(from_svg(`<desc> </desc>`), ArchiveOutline[FILENAME], [[46, 4]]);
var root25 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 12v1h4v-1m4 7H6a1 1 0 0 1-1-1V9h14v9a1 1 0 0 1-1 1ZM4 5h16a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), ArchiveOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArchiveOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArchiveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root25();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_125();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArchiveOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_225();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArchiveOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArchiveOutline = hmr(ArchiveOutline, () => ArchiveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveOutline[HMR].source;
    set(ArchiveOutline[HMR].source, module.default[HMR].original);
  });
}
var ArchiveOutline_default = ArchiveOutline;

// node_modules/flowbite-svelte-icons/dist/ArchiveSolid.svelte
ArchiveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveSolid.svelte";
var root_126 = add_locations(from_svg(`<title> </title>`), ArchiveSolid[FILENAME], [[41, 4]]);
var root_226 = add_locations(from_svg(`<desc> </desc>`), ArchiveSolid[FILENAME], [[44, 4]]);
var root26 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M20 10H4v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8ZM9 13v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path d="M2 6a2 2 0 0 1 2-2h16a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2Z"></path></svg>`), ArchiveSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function ArchiveSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArchiveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root26();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_126();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArchiveSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_226();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArchiveSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArchiveSolid = hmr(ArchiveSolid, () => ArchiveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveSolid[HMR].source;
    set(ArchiveSolid[HMR].source, module.default[HMR].original);
  });
}
var ArchiveSolid_default = ArchiveSolid;

// node_modules/flowbite-svelte-icons/dist/ArrowDownOutline.svelte
ArrowDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowDownOutline.svelte";
var root_127 = add_locations(from_svg(`<title> </title>`), ArrowDownOutline[FILENAME], [[43, 4]]);
var root_227 = add_locations(from_svg(`<desc> </desc>`), ArrowDownOutline[FILENAME], [[46, 4]]);
var root27 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 19V5m0 14-4-4m4 4 4-4"></path></svg>`), ArrowDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root27();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_127();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_227();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowDownOutline = hmr(ArrowDownOutline, () => ArrowDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowDownOutline[HMR].source;
    set(ArrowDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowDownOutline_default = ArrowDownOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowDownToBracketOutline.svelte
ArrowDownToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowDownToBracketOutline.svelte";
var root_128 = add_locations(from_svg(`<title> </title>`), ArrowDownToBracketOutline[FILENAME], [[43, 4]]);
var root_228 = add_locations(from_svg(`<desc> </desc>`), ArrowDownToBracketOutline[FILENAME], [[46, 4]]);
var root28 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 15v2a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-2m-8 1V4m0 12-4-4m4 4 4-4"></path></svg>`), ArrowDownToBracketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowDownToBracketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowDownToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root28();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_128();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowDownToBracketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_228();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowDownToBracketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowDownToBracketOutline = hmr(ArrowDownToBracketOutline, () => ArrowDownToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowDownToBracketOutline[HMR].source;
    set(ArrowDownToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowDownToBracketOutline_default = ArrowDownToBracketOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowLeftOutline.svelte
ArrowLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowLeftOutline.svelte";
var root_129 = add_locations(from_svg(`<title> </title>`), ArrowLeftOutline[FILENAME], [[43, 4]]);
var root_229 = add_locations(from_svg(`<desc> </desc>`), ArrowLeftOutline[FILENAME], [[46, 4]]);
var root29 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14M5 12l4-4m-4 4 4 4"></path></svg>`), ArrowLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root29();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_129();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_229();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowLeftOutline = hmr(ArrowLeftOutline, () => ArrowLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowLeftOutline[HMR].source;
    set(ArrowLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowLeftOutline_default = ArrowLeftOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowLeftToBracketOutline.svelte
ArrowLeftToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowLeftToBracketOutline.svelte";
var root_130 = add_locations(from_svg(`<title> </title>`), ArrowLeftToBracketOutline[FILENAME], [[43, 4]]);
var root_230 = add_locations(from_svg(`<desc> </desc>`), ArrowLeftToBracketOutline[FILENAME], [[46, 4]]);
var root30 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12H4m12 0-4 4m4-4-4-4m3-4h2a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-2"></path></svg>`), ArrowLeftToBracketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowLeftToBracketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowLeftToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root30();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_130();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowLeftToBracketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_230();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowLeftToBracketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowLeftToBracketOutline = hmr(ArrowLeftToBracketOutline, () => ArrowLeftToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowLeftToBracketOutline[HMR].source;
    set(ArrowLeftToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowLeftToBracketOutline_default = ArrowLeftToBracketOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowRightAltOutline.svelte
ArrowRightAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightAltOutline.svelte";
var root_131 = add_locations(from_svg(`<title> </title>`), ArrowRightAltOutline[FILENAME], [[43, 4]]);
var root_231 = add_locations(from_svg(`<desc> </desc>`), ArrowRightAltOutline[FILENAME], [[46, 4]]);
var root31 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.153 19 21 12l-4.847-7H3l4.848 7L3 19h13.153Z"></path></svg>`), ArrowRightAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowRightAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowRightAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root31();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_131();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowRightAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_231();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowRightAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowRightAltOutline = hmr(ArrowRightAltOutline, () => ArrowRightAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightAltOutline[HMR].source;
    set(ArrowRightAltOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightAltOutline_default = ArrowRightAltOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowRightAltSolid.svelte
ArrowRightAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightAltSolid.svelte";
var root_132 = add_locations(from_svg(`<title> </title>`), ArrowRightAltSolid[FILENAME], [[41, 4]]);
var root_232 = add_locations(from_svg(`<desc> </desc>`), ArrowRightAltSolid[FILENAME], [[44, 4]]);
var root32 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 4a1 1 0 0 0-.822 1.57L6.632 12l-4.454 6.43A1 1 0 0 0 3 20h13.153a1 1 0 0 0 .822-.43l4.847-7a1 1 0 0 0 0-1.14l-4.847-7a1 1 0 0 0-.822-.43H3Z" clip-rule="evenodd"></path></svg>`), ArrowRightAltSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowRightAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowRightAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root32();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_132();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowRightAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_232();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowRightAltSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowRightAltSolid = hmr(ArrowRightAltSolid, () => ArrowRightAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightAltSolid[HMR].source;
    set(ArrowRightAltSolid[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightAltSolid_default = ArrowRightAltSolid;

// node_modules/flowbite-svelte-icons/dist/ArrowRightOutline.svelte
ArrowRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightOutline.svelte";
var root_133 = add_locations(from_svg(`<title> </title>`), ArrowRightOutline[FILENAME], [[43, 4]]);
var root_233 = add_locations(from_svg(`<desc> </desc>`), ArrowRightOutline[FILENAME], [[46, 4]]);
var root33 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 12H5m14 0-4 4m4-4-4-4"></path></svg>`), ArrowRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root33();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_133();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_233();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowRightOutline = hmr(ArrowRightOutline, () => ArrowRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightOutline[HMR].source;
    set(ArrowRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightOutline_default = ArrowRightOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowRightToBracketOutline.svelte
ArrowRightToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightToBracketOutline.svelte";
var root_134 = add_locations(from_svg(`<title> </title>`), ArrowRightToBracketOutline[FILENAME], [[43, 4]]);
var root_234 = add_locations(from_svg(`<desc> </desc>`), ArrowRightToBracketOutline[FILENAME], [[46, 4]]);
var root34 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 12H8m12 0-4 4m4-4-4-4M9 4H7a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h2"></path></svg>`), ArrowRightToBracketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowRightToBracketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowRightToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root34();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_134();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowRightToBracketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_234();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowRightToBracketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowRightToBracketOutline = hmr(ArrowRightToBracketOutline, () => ArrowRightToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightToBracketOutline[HMR].source;
    set(ArrowRightToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightToBracketOutline_default = ArrowRightToBracketOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowSortLettersOutline.svelte
ArrowSortLettersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowSortLettersOutline.svelte";
var root_135 = add_locations(from_svg(`<title> </title>`), ArrowSortLettersOutline[FILENAME], [[43, 4]]);
var root_235 = add_locations(from_svg(`<desc> </desc>`), ArrowSortLettersOutline[FILENAME], [[46, 4]]);
var root35 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 4v16M7 4l3 3M7 4 4 7m9-3h6l-6 6h6m-6.5 10 3.5-7 3.5 7M14 18h4"></path></svg>`), ArrowSortLettersOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowSortLettersOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowSortLettersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root35();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_135();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowSortLettersOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_235();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowSortLettersOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowSortLettersOutline = hmr(ArrowSortLettersOutline, () => ArrowSortLettersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowSortLettersOutline[HMR].source;
    set(ArrowSortLettersOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowSortLettersOutline_default = ArrowSortLettersOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowsRepeatCountOutline.svelte
ArrowsRepeatCountOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowsRepeatCountOutline.svelte";
var root_136 = add_locations(from_svg(`<title> </title>`), ArrowsRepeatCountOutline[FILENAME], [[43, 4]]);
var root_236 = add_locations(from_svg(`<desc> </desc>`), ArrowsRepeatCountOutline[FILENAME], [[46, 4]]);
var root36 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 4 3 3H5v3m3 10-3-3h14v-3m-9-2.5 2-1.5v4"></path></svg>`), ArrowsRepeatCountOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowsRepeatCountOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowsRepeatCountOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root36();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_136();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowsRepeatCountOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_236();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowsRepeatCountOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowsRepeatCountOutline = hmr(ArrowsRepeatCountOutline, () => ArrowsRepeatCountOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowsRepeatCountOutline[HMR].source;
    set(ArrowsRepeatCountOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowsRepeatCountOutline_default = ArrowsRepeatCountOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowsRepeatOutline.svelte
ArrowsRepeatOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowsRepeatOutline.svelte";
var root_137 = add_locations(from_svg(`<title> </title>`), ArrowsRepeatOutline[FILENAME], [[43, 4]]);
var root_237 = add_locations(from_svg(`<desc> </desc>`), ArrowsRepeatOutline[FILENAME], [[46, 4]]);
var root37 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 10 3-3m0 0-3-3m3 3H5v3m3 4-3 3m0 0 3 3m-3-3h14v-3"></path></svg>`), ArrowsRepeatOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowsRepeatOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowsRepeatOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root37();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_137();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowsRepeatOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_237();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowsRepeatOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowsRepeatOutline = hmr(ArrowsRepeatOutline, () => ArrowsRepeatOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowsRepeatOutline[HMR].source;
    set(ArrowsRepeatOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowsRepeatOutline_default = ArrowsRepeatOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpDownOutline.svelte
ArrowUpDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpDownOutline.svelte";
var root_138 = add_locations(from_svg(`<title> </title>`), ArrowUpDownOutline[FILENAME], [[43, 4]]);
var root_238 = add_locations(from_svg(`<desc> </desc>`), ArrowUpDownOutline[FILENAME], [[46, 4]]);
var root38 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20V7m0 13-4-4m4 4 4-4m4-12v13m0-13 4 4m-4-4-4 4"></path></svg>`), ArrowUpDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowUpDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root38();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_138();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_238();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpDownOutline = hmr(ArrowUpDownOutline, () => ArrowUpDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpDownOutline[HMR].source;
    set(ArrowUpDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpDownOutline_default = ArrowUpDownOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpFromBracketOutline.svelte
ArrowUpFromBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpFromBracketOutline.svelte";
var root_139 = add_locations(from_svg(`<title> </title>`), ArrowUpFromBracketOutline[FILENAME], [[43, 4]]);
var root_239 = add_locations(from_svg(`<desc> </desc>`), ArrowUpFromBracketOutline[FILENAME], [[46, 4]]);
var root39 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 15v2a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-2M12 4v12m0-12 4 4m-4-4L8 8"></path></svg>`), ArrowUpFromBracketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowUpFromBracketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpFromBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root39();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_139();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpFromBracketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_239();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpFromBracketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpFromBracketOutline = hmr(ArrowUpFromBracketOutline, () => ArrowUpFromBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpFromBracketOutline[HMR].source;
    set(ArrowUpFromBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpFromBracketOutline_default = ArrowUpFromBracketOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpOutline.svelte
ArrowUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpOutline.svelte";
var root_140 = add_locations(from_svg(`<title> </title>`), ArrowUpOutline[FILENAME], [[43, 4]]);
var root_240 = add_locations(from_svg(`<desc> </desc>`), ArrowUpOutline[FILENAME], [[46, 4]]);
var root40 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6v13m0-13 4 4m-4-4-4 4"></path></svg>`), ArrowUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root40();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_140();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_240();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpOutline = hmr(ArrowUpOutline, () => ArrowUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpOutline[HMR].source;
    set(ArrowUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpOutline_default = ArrowUpOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightDownLeftOutline.svelte
ArrowUpRightDownLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightDownLeftOutline.svelte";
var root_141 = add_locations(from_svg(`<title> </title>`), ArrowUpRightDownLeftOutline[FILENAME], [[43, 4]]);
var root_241 = add_locations(from_svg(`<desc> </desc>`), ArrowUpRightDownLeftOutline[FILENAME], [[46, 4]]);
var root41 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 4h4m0 0v4m0-4-5 5M8 20H4m0 0v-4m0 4 5-5"></path></svg>`), ArrowUpRightDownLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowUpRightDownLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpRightDownLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root41();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_141();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpRightDownLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_241();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpRightDownLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpRightDownLeftOutline = hmr(ArrowUpRightDownLeftOutline, () => ArrowUpRightDownLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightDownLeftOutline[HMR].source;
    set(ArrowUpRightDownLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightDownLeftOutline_default = ArrowUpRightDownLeftOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareOutline.svelte
ArrowUpRightFromSquareOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareOutline.svelte";
var root_142 = add_locations(from_svg(`<title> </title>`), ArrowUpRightFromSquareOutline[FILENAME], [[43, 4]]);
var root_242 = add_locations(from_svg(`<desc> </desc>`), ArrowUpRightFromSquareOutline[FILENAME], [[46, 4]]);
var root42 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 14v4.833A1.166 1.166 0 0 1 16.833 20H5.167A1.167 1.167 0 0 1 4 18.833V7.167A1.166 1.166 0 0 1 5.167 6h4.618m4.447-2H20v5.768m-7.889 2.121 7.778-7.778"></path></svg>`), ArrowUpRightFromSquareOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ArrowUpRightFromSquareOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpRightFromSquareOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root42();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_142();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpRightFromSquareOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_242();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpRightFromSquareOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpRightFromSquareOutline = hmr(ArrowUpRightFromSquareOutline, () => ArrowUpRightFromSquareOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightFromSquareOutline[HMR].source;
    set(ArrowUpRightFromSquareOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightFromSquareOutline_default = ArrowUpRightFromSquareOutline;

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareSolid.svelte
ArrowUpRightFromSquareSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareSolid.svelte";
var root_143 = add_locations(from_svg(`<title> </title>`), ArrowUpRightFromSquareSolid[FILENAME], [[41, 4]]);
var root_243 = add_locations(from_svg(`<desc> </desc>`), ArrowUpRightFromSquareSolid[FILENAME], [[44, 4]]);
var root43 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.403 5H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6.403a3.01 3.01 0 0 1-1.743-1.612l-3.025 3.025A3 3 0 1 1 9.99 9.768l3.025-3.025A3.01 3.01 0 0 1 11.403 5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M13.232 4a1 1 0 0 1 1-1H20a1 1 0 0 1 1 1v5.768a1 1 0 1 1-2 0V6.414l-6.182 6.182a1 1 0 0 1-1.414-1.414L17.586 5h-3.354a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), ArrowUpRightFromSquareSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function ArrowUpRightFromSquareSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ArrowUpRightFromSquareSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root43();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_143();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ArrowUpRightFromSquareSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_243();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ArrowUpRightFromSquareSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ArrowUpRightFromSquareSolid = hmr(ArrowUpRightFromSquareSolid, () => ArrowUpRightFromSquareSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightFromSquareSolid[HMR].source;
    set(ArrowUpRightFromSquareSolid[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightFromSquareSolid_default = ArrowUpRightFromSquareSolid;

// node_modules/flowbite-svelte-icons/dist/AtomOutline.svelte
AtomOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AtomOutline.svelte";
var root_144 = add_locations(from_svg(`<title> </title>`), AtomOutline[FILENAME], [[43, 4]]);
var root_244 = add_locations(from_svg(`<desc> </desc>`), AtomOutline[FILENAME], [[46, 4]]);
var root44 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M8.737 8.737a21.49 21.49 0 0 1 3.308-2.724m0 0c3.063-2.026 5.99-2.641 7.331-1.3 1.827 1.828.026 6.591-4.023 10.64-4.049 4.049-8.812 5.85-10.64 4.023-1.33-1.33-.736-4.218 1.249-7.253m6.083-6.11c-3.063-2.026-5.99-2.641-7.331-1.3-1.827 1.828-.026 6.591 4.023 10.64m3.308-9.34a21.497 21.497 0 0 1 3.308 2.724m2.775 3.386c1.985 3.035 2.579 5.923 1.248 7.253-1.336 1.337-4.245.732-7.295-1.275M14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AtomOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AtomOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AtomOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root44();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_144();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AtomOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_244();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AtomOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AtomOutline = hmr(AtomOutline, () => AtomOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AtomOutline[HMR].source;
    set(AtomOutline[HMR].source, module.default[HMR].original);
  });
}
var AtomOutline_default = AtomOutline;

// node_modules/flowbite-svelte-icons/dist/AwardOutline.svelte
AwardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwardOutline.svelte";
var root_145 = add_locations(from_svg(`<title> </title>`), AwardOutline[FILENAME], [[43, 4]]);
var root_245 = add_locations(from_svg(`<desc> </desc>`), AwardOutline[FILENAME], [[46, 4]]);
var root45 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7.171 12.906-2.153 6.411 2.672-.89 1.568 2.34 1.825-5.183m5.73-2.678 2.154 6.411-2.673-.89-1.568 2.34-1.825-5.183M9.165 4.3c.58.068 1.153-.17 1.515-.628a1.681 1.681 0 0 1 2.64 0 1.68 1.68 0 0 0 1.515.628 1.681 1.681 0 0 1 1.866 1.866c-.068.58.17 1.154.628 1.516a1.681 1.681 0 0 1 0 2.639 1.682 1.682 0 0 0-.628 1.515 1.681 1.681 0 0 1-1.866 1.866 1.681 1.681 0 0 0-1.516.628 1.681 1.681 0 0 1-2.639 0 1.681 1.681 0 0 0-1.515-.628 1.681 1.681 0 0 1-1.867-1.866 1.681 1.681 0 0 0-.627-1.515 1.681 1.681 0 0 1 0-2.64c.458-.361.696-.935.627-1.515A1.681 1.681 0 0 1 9.165 4.3ZM14 9a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AwardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function AwardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AwardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root45();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_145();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AwardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_245();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AwardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AwardOutline = hmr(AwardOutline, () => AwardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwardOutline[HMR].source;
    set(AwardOutline[HMR].source, module.default[HMR].original);
  });
}
var AwardOutline_default = AwardOutline;

// node_modules/flowbite-svelte-icons/dist/AwardSolid.svelte
AwardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwardSolid.svelte";
var root_146 = add_locations(from_svg(`<title> </title>`), AwardSolid[FILENAME], [[41, 4]]);
var root_246 = add_locations(from_svg(`<desc> </desc>`), AwardSolid[FILENAME], [[44, 4]]);
var root46 = add_locations(from_svg(`<svg><!><!><path d="M11 9a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z"></path><path fill-rule="evenodd" d="M9.896 3.051a2.681 2.681 0 0 1 4.208 0c.147.186.38.282.615.255a2.681 2.681 0 0 1 2.976 2.975.681.681 0 0 0 .254.615 2.681 2.681 0 0 1 0 4.208.682.682 0 0 0-.254.615 2.681 2.681 0 0 1-2.976 2.976.681.681 0 0 0-.615.254 2.682 2.682 0 0 1-4.208 0 .681.681 0 0 0-.614-.255 2.681 2.681 0 0 1-2.976-2.975.681.681 0 0 0-.255-.615 2.681 2.681 0 0 1 0-4.208.681.681 0 0 0 .255-.615 2.681 2.681 0 0 1 2.976-2.975.681.681 0 0 0 .614-.255ZM12 6a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" clip-rule="evenodd"></path><path d="M5.395 15.055 4.07 19a1 1 0 0 0 1.264 1.267l1.95-.65 1.144 1.707A1 1 0 0 0 10.2 21.1l1.12-3.18a4.641 4.641 0 0 1-2.515-1.208 4.667 4.667 0 0 1-3.411-1.656Zm7.269 2.867 1.12 3.177a1 1 0 0 0 1.773.224l1.144-1.707 1.95.65A1 1 0 0 0 19.915 19l-1.32-3.93a4.667 4.667 0 0 1-3.4 1.642 4.643 4.643 0 0 1-2.53 1.21Z"></path></svg>`), AwardSolid[FILENAME], [[30, 0, [[46, 2], [47, 2], [52, 2]]]]);
function AwardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AwardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root46();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_146();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AwardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_246();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AwardSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AwardSolid = hmr(AwardSolid, () => AwardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwardSolid[HMR].source;
    set(AwardSolid[HMR].source, module.default[HMR].original);
  });
}
var AwardSolid_default = AwardSolid;

// node_modules/flowbite-svelte-icons/dist/AwsSolid.svelte
AwsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwsSolid.svelte";
var root_147 = add_locations(from_svg(`<title> </title>`), AwsSolid[FILENAME], [[41, 4]]);
var root_247 = add_locations(from_svg(`<desc> </desc>`), AwsSolid[FILENAME], [[44, 4]]);
var root47 = add_locations(from_svg(`<svg><!><!><path d="M7.70858 10.176c-.0059.1918.02016.3833.07716.567.05635.1582.12675.3114.21041.4577.02989.0424.04691.0921.04909.1435-.00368.0394-.01708.0774-.03906.1107-.02198.0333-.05189.0609-.08718.0806l-.41382.2664c-.04921.0342-.10786.0533-.16833.0546-.03729-.0006-.07404-.0088-.10786-.0241-.03383-.0153-.06399-.0373-.08852-.0647-.09084-.0886-.17086-.1872-.23847-.2937-.06312-.1093-.12625-.2323-.19638-.3758-.23007.28-.52286.505-.85597.6577-.3331.1528-.69768.2293-1.0658.2236-.23782.0125-.47581-.0215-.69988-.1002-.22407-.0786-.42969-.2002-.60468-.3575-.16281-.1601-.28937-.3516-.37152-.5622s-.11806-.4357-.10542-.6607c-.0085-.2476.04-.49387.14195-.72084.10194-.22696.25475-.42883.44721-.59079.45708-.34704 1.02741-.5217 1.60615-.49187.23468-.00102.46912.01497.70137.04782.24549.03416.49097.08198.75048.13663V8.2153c.03746-.36552-.07329-.73083-.30861-1.0179-.30324-.22803-.68514-.33327-1.06609-.29376-.23624.00109-.47158.02859-.70138.08198-.23919.05528-.47367.12837-.70137.21861l-.23146.08198h-.09819c-.09819 0-.14027-.06832-.14027-.19812v-.31425c-.00622-.07522.00831-.15069.04208-.21861.05218-.0584.1168-.10503.18937-.13663.2626-.12306.53761-.21922.82061-.28693.33218-.08331.67398-.12464 1.01699-.12297.61832-.0525 1.23302.134 1.71136.5192.19644.21006.34589.45761.43886.72693.09297.26931.12744.55452.1012.83751L7.70858 10.176Zm-2.6512.9701c.23887.0003.47605-.039.70138-.1162.23999-.0798.45329-.2214.61721-.4099.10821-.114.18537-.2525.22444-.403.04532-.1811.06654-.36707.06312-.5534v-.28693c-.20607-.04171-.41451-.07136-.62422-.08881H5.4221c-.34289-.02679-.68477.06249-.9679.25277-.10942.08972-.19564.20325-.25168.33142-.05605.12815-.08036.26735-.07095.40635-.01155.1238.00371.2486.04479.3663.04108.1177.10706.2256.19367.3169.19501.1477.4422.214.68735.1845Zm5.25332.6831c-.0889.0081-.178-.0136-.2525-.0615-.07121-.069-.12-.1569-.14028-.2527l-1.529-4.91878c-.03108-.08355-.04997-.17094-.05611-.2596 0-.10247.04909-.15713.1543-.15713h.64527c.08889-.00805.17795.01364.25249.06149.06832.07011.11457.15783.13326.25277L10.6193 10.743l1.031-4.24242c.0108-.09596.0554-.1853.1263-.25277.0771-.04787.1684-.06949.2595-.06149h.526c.0933-.008.1868.01357.2665.06149.0658.07094.1096.15858.1263.25277l1.017 4.24242 1.1292-4.26292c.0187-.09493.0649-.18265.1332-.25277.0746-.04785.1636-.06953.2525-.06148h.6102c.0218-.00213.0437.00047.0643.00761.0205.00714.0392.01865.0547.03369.0154.01503.0272.03323.0345.05326.0074.02004.01.04141.0079.06257.0026.03411.0026.06836 0 .10247 0 0 0 .08881-.0421.15713l-1.5851 4.91874c-.0187.0949-.065.1826-.1333.2528-.0754.0459-.1638.0675-.2525.0614h-.5611c-.0922.0096-.1848-.0148-.2595-.0683-.0695-.0684-.1139-.1572-.1263-.2527l-1.0169-4.09899-1.01 4.09899c-.0124.0955-.0568.1843-.1263.2527-.0753.0524-.1674.0766-.2595.0683l-.5751.0137Zm8.4165.164c-.3399.0015-.6788-.0351-1.01-.1093-.2607-.051-.5131-.136-.7505-.2528-.0839-.039-.1545-.1006-.2034-.1776-.0272-.0579-.0415-.1208-.042-.1845v-.3211c0-.1298.0491-.1981.1473-.1981.0418-.0065.0844-.0065.1262 0l.1613.0683c.2248.0979.46.1712.7014.2186.2558.0543.5168.0818.7785.082.3323.0202.6634-.0534.9539-.2118.1055-.0624.1921-.1509.2512-.2565.0592-.1055.0886-.2244.0855-.3446.0033-.0818-.0106-.1633-.0407-.2397-.0302-.07633-.076-.14588-.1347-.20439-.1899-.16027-.4157-.27492-.6593-.33474l-.9468-.29376c-.4097-.1003-.7758-.32526-1.0451-.64217-.2118-.26596-.3277-.59251-.3296-.92909-.0039-.23873.0566-.47428.1753-.68316.1173-.2053.2774-.38447.4699-.52603.2109-.15082.4487-.26203.7014-.32792.2689-.07547.5478-.11229.8276-.1093.1448-.00996.2901-.00996.4349 0l.4278.06831.3717.10247.2736.10931c.0734.04221.1396.09522.1964.15713.0391.06392.0585.13741.0561.21178v.30058c0 .13664-.0491.20495-.1473.20495-.0891-.00994-.1751-.03786-.2525-.08198-.3981-.16851-.8285-.25236-1.2625-.24593-.3007-.01421-.6002.04695-.8697.17762-.1001.05934-.1817.14411-.236.24521-.0544.1011-.0795.21471-.0726.32864-.0003.08419.0169.16757.0507.24507.0337.07751.0833.14753.1457.20581.207.16139.4457.27994.7014.34842l.9258.28692c.3924.10142.7444.31568 1.01.61484.201.25675.3073.57207.3016.89491.0041.2554-.0535.5082-.1684.7378-.1126.22-.2758.4117-.4769.5602-.2081.163-.4461.2859-.7014.3621-.3061.0959-.6253.1465-.9468.1503l.021-.0068ZM1.95721 14.0043c.08851-.1117.25276-.1417.40291-.0501 2.956 1.6699 6.30435 2.5466 9.71118 2.5424 2.547-.0102 5.0667-.5176 7.4139-1.4927.2212-.0923.442-.0252.5504.1273.0544.0765.0784.1732.056.2731-.0223.0994-.088.1913-.1929.2664l-.0025.0018c-2.374 1.591-5.18 2.437-8.0499 2.4273-3.62804.0192-7.13297-1.2975-9.82873-3.6929.00006 0-.00007-.0001 0 0-.06599-.0585-.10575-.1289-.1154-.2033-.00962-.0742.01189-.1449.05504-.1993Z"></path><path d="M21.9852 13.2357c-.0506-.0587-.1329-.1058-.2258-.1441-.0959-.0396-.2151-.0746-.3508-.1035-.2719-.0579-.6185-.093-.9967-.0876-.7541.0108-1.6508.183-2.3341.6748-.1118.0805-.1949.1945-.1751.3147.0225.1362.1551.1917.2864.1917l.0241-.003c.375-.0465.9652-.1198 1.5-.134.2706-.0072.5225.0009.7232.0339.1003.0164.1845.0386.2506.0663.0667.028.1084.0591.1318.0896l.001.0013c.0211.0266.0396.072.0489.1434.0092.0704.0085.1579-.0018.2604-.0204.2049-.0773.456-.1527.723-.1173.4156-.2758.8577-.4014 1.2081-.0355.0991-.0684.1909-.097.2727-.0253.0645-.0344.13-.0204.1901.0147.063.0538.1145.1113.143.1108.0549.2469.0095.3548-.0833.6431-.5509 1.0488-1.3947 1.2591-2.1349.1055-.3712.1632-.7208.1764-1.0006.0065-.1398.0021-.2647-.0141-.3675-.0155-.099-.0442-.1922-.0977-.2545Z"></path></svg>`), AwsSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function AwsSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, AwsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root47();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_147();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      AwsSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_247();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      AwsSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  AwsSolid = hmr(AwsSolid, () => AwsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwsSolid[HMR].source;
    set(AwsSolid[HMR].source, module.default[HMR].original);
  });
}
var AwsSolid_default = AwsSolid;

// node_modules/flowbite-svelte-icons/dist/BackwardStepOutline.svelte
BackwardStepOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BackwardStepOutline.svelte";
var root_148 = add_locations(from_svg(`<title> </title>`), BackwardStepOutline[FILENAME], [[43, 4]]);
var root_248 = add_locations(from_svg(`<desc> </desc>`), BackwardStepOutline[FILENAME], [[46, 4]]);
var root48 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 6v12m8-12v12l-8-6 8-6Z"></path></svg>`), BackwardStepOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BackwardStepOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BackwardStepOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root48();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_148();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BackwardStepOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_248();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BackwardStepOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BackwardStepOutline = hmr(BackwardStepOutline, () => BackwardStepOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BackwardStepOutline[HMR].source;
    set(BackwardStepOutline[HMR].source, module.default[HMR].original);
  });
}
var BackwardStepOutline_default = BackwardStepOutline;

// node_modules/flowbite-svelte-icons/dist/BackwardStepSolid.svelte
BackwardStepSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BackwardStepSolid.svelte";
var root_149 = add_locations(from_svg(`<title> </title>`), BackwardStepSolid[FILENAME], [[41, 4]]);
var root_249 = add_locations(from_svg(`<desc> </desc>`), BackwardStepSolid[FILENAME], [[44, 4]]);
var root49 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7 6a1 1 0 0 1 2 0v4l6.4-4.8A1 1 0 0 1 17 6v12a1 1 0 0 1-1.6.8L9 14v4a1 1 0 1 1-2 0V6Z" clip-rule="evenodd"></path></svg>`), BackwardStepSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BackwardStepSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BackwardStepSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root49();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_149();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BackwardStepSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_249();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BackwardStepSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BackwardStepSolid = hmr(BackwardStepSolid, () => BackwardStepSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BackwardStepSolid[HMR].source;
    set(BackwardStepSolid[HMR].source, module.default[HMR].original);
  });
}
var BackwardStepSolid_default = BackwardStepSolid;

// node_modules/flowbite-svelte-icons/dist/BaconOutline.svelte
BaconOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BaconOutline.svelte";
var root_150 = add_locations(from_svg(`<title> </title>`), BaconOutline[FILENAME], [[43, 4]]);
var root_250 = add_locations(from_svg(`<desc> </desc>`), BaconOutline[FILENAME], [[46, 4]]);
var root50 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="M7.42584 18.2443c1.3169-2.2023 2.5334-1.5242 3.85026-3.7265 1.3169-2.2023.1004-2.8805 1.4173-5.08281 1.3169-2.20233 2.5335-1.52419 3.8504-3.72652M10.8472 20.1517c1.3169-2.2024 2.5334-1.5242 3.8503-3.7266 1.3169-2.2023.1004-2.8804 1.4173-5.0828 1.3169-2.20228 2.5334-1.52414 3.8503-3.72647l-6.8428-3.81455C11.8054 6.00361 10.5889 5.32547 9.272 7.5278s-.1004 2.8805-1.4173 5.0828c-1.3169 2.2023-2.5334 1.5242-3.85031 3.7265l6.84281 3.8146Z"></path></svg>`), BaconOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BaconOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BaconOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root50();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_150();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BaconOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_250();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BaconOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BaconOutline = hmr(BaconOutline, () => BaconOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BaconOutline[HMR].source;
    set(BaconOutline[HMR].source, module.default[HMR].original);
  });
}
var BaconOutline_default = BaconOutline;

// node_modules/flowbite-svelte-icons/dist/BaconSolid.svelte
BaconSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BaconSolid.svelte";
var root_151 = add_locations(from_svg(`<title> </title>`), BaconSolid[FILENAME], [[41, 4]]);
var root_251 = add_locations(from_svg(`<desc> </desc>`), BaconSolid[FILENAME], [[44, 4]]);
var root51 = add_locations(from_svg(`<svg><!><!><path d="m16.1325 4.33451-2.5233-1.40664c-.4721-.26314-1.0678-.1036-1.3452.36025-.5301.88653-.995 1.16623-1.5715 1.51306l-.0109.00653c-.68512.41222-1.48439.89668-2.26786 2.20693-.78556 1.31373-.82234 2.23251-.84978 3.01976l-.00064.0183c-.02242.6445-.04051 1.1644-.56688 2.0447-.53011.8866-.99504 1.1663-1.57156 1.5131l-.01086.0065c-.68515.4122-1.48441.8967-2.26789 2.207-.13881.2321-.17767.5106-.10769.7719.06998.2612.24281.483.47907.6147l2.62175 1.4615c.14127-.4135.30621-.7369.42823-.941.78347-1.3102 1.58276-1.7947 2.26791-2.2069l.01085-.0066c.57652-.3468 1.04146-.6265 1.57155-1.513.5264-.8803.5445-1.4003.5669-2.0448l.0006-.0183c.0275-.7872.0643-1.706.8498-3.01973.7835-1.31024 1.5828-1.79471 2.2679-2.20692l.0109-.00653c.5738-.34523 1.0371-.62397 1.5642-1.50087.1235-.22119.2956-.5451.4544-.87294ZM7.93136 19.6711l2.42894 1.354c.4721.2632 1.0678.1037 1.3452-.3602.5301-.8865.995-1.1662 1.5715-1.513l.0109-.0066c.6852-.4122 1.4844-.8967 2.2679-2.2069.7855-1.3137.8223-2.2325.8498-3.0198l.0006-.0183c.0224-.6444.0405-1.1644.5669-2.0447.5301-.8865.995-1.1662 1.5715-1.5131l.0109-.0065c.6852-.41221 1.4844-.89667 2.2679-2.20692.1388-.23214.1777-.51061.1077-.77188-.07-.26128-.2428-.48306-.479-.61477L17.882 5.30974c-.1678.34035-.34.6625-.4657.88717-.0047.00832-.0095.01658-.0143.02476-.7835 1.31025-1.5828 1.79471-2.2679 2.20693l-.0109.00653c-.5765.34683-1.0415.62653-1.5716 1.51306-.5263.88031-.5444 1.40031-.5668 2.04471l-.0007.0183c-.0274.7873-.0642 1.7061-.8498 3.0198-.7834 1.3102-1.5827 1.7947-2.26785 2.2069l-.01085.0065c-.57651.3469-1.04144.6266-1.57154 1.5131-.10167.17-.25746.4945-.3527.9136Z"></path></svg>`), BaconSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BaconSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BaconSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root51();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_151();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BaconSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_251();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BaconSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BaconSolid = hmr(BaconSolid, () => BaconSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BaconSolid[HMR].source;
    set(BaconSolid[HMR].source, module.default[HMR].original);
  });
}
var BaconSolid_default = BaconSolid;

// node_modules/flowbite-svelte-icons/dist/BadgeCheckOutline.svelte
BadgeCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BadgeCheckOutline.svelte";
var root_152 = add_locations(from_svg(`<title> </title>`), BadgeCheckOutline[FILENAME], [[43, 4]]);
var root_252 = add_locations(from_svg(`<desc> </desc>`), BadgeCheckOutline[FILENAME], [[46, 4]]);
var root52 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8.032 12 1.984 1.984 4.96-4.96m4.55 5.272.893-.893a1.984 1.984 0 0 0 0-2.806l-.893-.893a1.984 1.984 0 0 1-.581-1.403V7.04a1.984 1.984 0 0 0-1.984-1.984h-1.262a1.983 1.983 0 0 1-1.403-.581l-.893-.893a1.984 1.984 0 0 0-2.806 0l-.893.893a1.984 1.984 0 0 1-1.403.581H7.04A1.984 1.984 0 0 0 5.055 7.04v1.262c0 .527-.209 1.031-.581 1.403l-.893.893a1.984 1.984 0 0 0 0 2.806l.893.893c.372.372.581.876.581 1.403v1.262a1.984 1.984 0 0 0 1.984 1.984h1.262c.527 0 1.031.209 1.403.581l.893.893a1.984 1.984 0 0 0 2.806 0l.893-.893a1.985 1.985 0 0 1 1.403-.581h1.262a1.984 1.984 0 0 0 1.984-1.984V15.7c0-.527.209-1.031.581-1.403Z"></path></svg>`), BadgeCheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BadgeCheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BadgeCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root52();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_152();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BadgeCheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_252();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BadgeCheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BadgeCheckOutline = hmr(BadgeCheckOutline, () => BadgeCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BadgeCheckOutline[HMR].source;
    set(BadgeCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var BadgeCheckOutline_default = BadgeCheckOutline;

// node_modules/flowbite-svelte-icons/dist/BadgeCheckSolid.svelte
BadgeCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BadgeCheckSolid.svelte";
var root_153 = add_locations(from_svg(`<title> </title>`), BadgeCheckSolid[FILENAME], [[41, 4]]);
var root_253 = add_locations(from_svg(`<desc> </desc>`), BadgeCheckSolid[FILENAME], [[44, 4]]);
var root53 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2c-.791 0-1.55.314-2.11.874l-.893.893a.985.985 0 0 1-.696.288H7.04A2.984 2.984 0 0 0 4.055 7.04v1.262a.986.986 0 0 1-.288.696l-.893.893a2.984 2.984 0 0 0 0 4.22l.893.893a.985.985 0 0 1 .288.696v1.262a2.984 2.984 0 0 0 2.984 2.984h1.262c.261 0 .512.104.696.288l.893.893a2.984 2.984 0 0 0 4.22 0l.893-.893a.985.985 0 0 1 .696-.288h1.262a2.984 2.984 0 0 0 2.984-2.984V15.7c0-.261.104-.512.288-.696l.893-.893a2.984 2.984 0 0 0 0-4.22l-.893-.893a.985.985 0 0 1-.288-.696V7.04a2.984 2.984 0 0 0-2.984-2.984h-1.262a.985.985 0 0 1-.696-.288l-.893-.893A2.984 2.984 0 0 0 12 2Zm3.683 7.73a1 1 0 1 0-1.414-1.413l-4.253 4.253-1.277-1.277a1 1 0 0 0-1.415 1.414l1.985 1.984a1 1 0 0 0 1.414 0l4.96-4.96Z" clip-rule="evenodd"></path></svg>`), BadgeCheckSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BadgeCheckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BadgeCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root53();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_153();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BadgeCheckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_253();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BadgeCheckSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BadgeCheckSolid = hmr(BadgeCheckSolid, () => BadgeCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BadgeCheckSolid[HMR].source;
    set(BadgeCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var BadgeCheckSolid_default = BadgeCheckSolid;

// node_modules/flowbite-svelte-icons/dist/BanOutline.svelte
BanOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BanOutline.svelte";
var root_154 = add_locations(from_svg(`<title> </title>`), BanOutline[FILENAME], [[43, 4]]);
var root_254 = add_locations(from_svg(`<desc> </desc>`), BanOutline[FILENAME], [[46, 4]]);
var root54 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m6 6 12 12m3-6a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), BanOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BanOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BanOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root54();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_154();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BanOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_254();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BanOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BanOutline = hmr(BanOutline, () => BanOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BanOutline[HMR].source;
    set(BanOutline[HMR].source, module.default[HMR].original);
  });
}
var BanOutline_default = BanOutline;

// node_modules/flowbite-svelte-icons/dist/BarcodeOutline.svelte
BarcodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarcodeOutline.svelte";
var root_155 = add_locations(from_svg(`<title> </title>`), BarcodeOutline[FILENAME], [[43, 4]]);
var root_255 = add_locations(from_svg(`<desc> </desc>`), BarcodeOutline[FILENAME], [[46, 4]]);
var root55 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M2.9917 4.9834V18.917M9.96265 4.9834V18.917M15.9378 4.9834V18.917m2.9875-13.9336V18.917"></path><path stroke="currentColor" stroke-linecap="round" d="M5.47925 4.4834V19.417m1.9917-14.9336V19.417M21.4129 4.4834V19.417M13.4461 4.4834V19.417"></path></svg>`), BarcodeOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function BarcodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BarcodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root55();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_155();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BarcodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_255();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BarcodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  next();
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BarcodeOutline = hmr(BarcodeOutline, () => BarcodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarcodeOutline[HMR].source;
    set(BarcodeOutline[HMR].source, module.default[HMR].original);
  });
}
var BarcodeOutline_default = BarcodeOutline;

// node_modules/flowbite-svelte-icons/dist/BarsFromLeftOutline.svelte
BarsFromLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarsFromLeftOutline.svelte";
var root_156 = add_locations(from_svg(`<title> </title>`), BarsFromLeftOutline[FILENAME], [[43, 4]]);
var root_256 = add_locations(from_svg(`<desc> </desc>`), BarsFromLeftOutline[FILENAME], [[46, 4]]);
var root56 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 7h14M5 12h14M5 17h10"></path></svg>`), BarsFromLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BarsFromLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BarsFromLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root56();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_156();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BarsFromLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_256();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BarsFromLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BarsFromLeftOutline = hmr(BarsFromLeftOutline, () => BarsFromLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarsFromLeftOutline[HMR].source;
    set(BarsFromLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var BarsFromLeftOutline_default = BarsFromLeftOutline;

// node_modules/flowbite-svelte-icons/dist/BarsOutline.svelte
BarsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarsOutline.svelte";
var root_157 = add_locations(from_svg(`<title> </title>`), BarsOutline[FILENAME], [[43, 4]]);
var root_257 = add_locations(from_svg(`<desc> </desc>`), BarsOutline[FILENAME], [[46, 4]]);
var root57 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 7h14M5 12h14M5 17h14"></path></svg>`), BarsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BarsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BarsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root57();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_157();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BarsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_257();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BarsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BarsOutline = hmr(BarsOutline, () => BarsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarsOutline[HMR].source;
    set(BarsOutline[HMR].source, module.default[HMR].original);
  });
}
var BarsOutline_default = BarsOutline;

// node_modules/flowbite-svelte-icons/dist/BatteryOutline.svelte
BatteryOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BatteryOutline.svelte";
var root_158 = add_locations(from_svg(`<title> </title>`), BatteryOutline[FILENAME], [[43, 4]]);
var root_258 = add_locations(from_svg(`<desc> </desc>`), BatteryOutline[FILENAME], [[46, 4]]);
var root58 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M2.98755 7.97095c0-.55229.44771-1 1-1H16.9253c.5523 0 1 .44771 1 1v7.95855c0 .5522-.4477 1-1 1H3.98755c-.55229 0-1-.4478-1-1V7.97095ZM20.9129 12.9419v-1.9834c0-.5523-.4478-1-1-1h-.9876c-.5523 0-1 .4477-1 1v1.9834c0 .5523.4477 1 1 1h.9876c.5522 0 1-.4477 1-1Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M5.9751 9.9585h8.9627v3.9834H5.9751V9.9585Z"></path></svg>`), BatteryOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function BatteryOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BatteryOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root58();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_158();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BatteryOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_258();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BatteryOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BatteryOutline = hmr(BatteryOutline, () => BatteryOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BatteryOutline[HMR].source;
    set(BatteryOutline[HMR].source, module.default[HMR].original);
  });
}
var BatteryOutline_default = BatteryOutline;

// node_modules/flowbite-svelte-icons/dist/BatterySolid.svelte
BatterySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BatterySolid.svelte";
var root_159 = add_locations(from_svg(`<title> </title>`), BatterySolid[FILENAME], [[41, 4]]);
var root_259 = add_locations(from_svg(`<desc> </desc>`), BatterySolid[FILENAME], [[44, 4]]);
var root59 = add_locations(from_svg(`<svg><!><!><path d="M7 13v-2h7v2H7Z"></path><path fill-rule="evenodd" d="M2 8a2 2 0 0 1 2-2h13a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8Zm4 1a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1H6Z" clip-rule="evenodd"></path><path d="M22 14v-4a1 1 0 0 0-1-1h-1v6h1a1 1 0 0 0 1-1Z"></path></svg>`), BatterySolid[FILENAME], [[30, 0, [[46, 2], [47, 2], [51, 5]]]]);
function BatterySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BatterySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root59();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_159();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BatterySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_259();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BatterySolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BatterySolid = hmr(BatterySolid, () => BatterySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BatterySolid[HMR].source;
    set(BatterySolid[HMR].source, module.default[HMR].original);
  });
}
var BatterySolid_default = BatterySolid;

// node_modules/flowbite-svelte-icons/dist/BedOutline.svelte
BedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BedOutline.svelte";
var root_160 = add_locations(from_svg(`<title> </title>`), BedOutline[FILENAME], [[43, 4]]);
var root_260 = add_locations(from_svg(`<desc> </desc>`), BedOutline[FILENAME], [[46, 4]]);
var root60 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 17v2M12 5.5V10m-6 7v2m15-2v-4c0-1.6569-1.3431-3-3-3H6c-1.65685 0-3 1.3431-3 3v4h18Zm-2-7V8c0-1.65685-1.3431-3-3-3H8C6.34315 5 5 6.34315 5 8v2h14Z"></path></svg>`), BedOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BedOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root60();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_160();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BedOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_260();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BedOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BedOutline = hmr(BedOutline, () => BedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BedOutline[HMR].source;
    set(BedOutline[HMR].source, module.default[HMR].original);
  });
}
var BedOutline_default = BedOutline;

// node_modules/flowbite-svelte-icons/dist/BedSolid.svelte
BedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BedSolid.svelte";
var root_161 = add_locations(from_svg(`<title> </title>`), BedSolid[FILENAME], [[41, 4]]);
var root_261 = add_locations(from_svg(`<desc> </desc>`), BedSolid[FILENAME], [[44, 4]]);
var root61 = add_locations(from_svg(`<svg><!><!><path d="M2.535 11A3.981 3.981 0 0 0 2 13v4a1 1 0 0 0 1 1h2v1a1 1 0 1 0 2 0v-1h10v1a1 1 0 1 0 2 0v-1h2a1 1 0 0 0 1-1v-4c0-.729-.195-1.412-.535-2H2.535ZM20 9V8a4 4 0 0 0-4-4h-3v5h7Zm-9-5H8a4 4 0 0 0-4 4v1h7V4Z"></path></svg>`), BedSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BedSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root61();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_161();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BedSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_261();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BedSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BedSolid = hmr(BedSolid, () => BedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BedSolid[HMR].source;
    set(BedSolid[HMR].source, module.default[HMR].original);
  });
}
var BedSolid_default = BedSolid;

// node_modules/flowbite-svelte-icons/dist/BeerMugEmptyOutline.svelte
BeerMugEmptyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BeerMugEmptyOutline.svelte";
var root_162 = add_locations(from_svg(`<title> </title>`), BeerMugEmptyOutline[FILENAME], [[43, 4]]);
var root_262 = add_locations(from_svg(`<desc> </desc>`), BeerMugEmptyOutline[FILENAME], [[46, 4]]);
var root62 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.125 6H20v3.85927c0 1.33743-.6684 2.58633-1.7812 3.32823l-1.5791 1.0468M4.18754 17H16.8125M9.00004 7v7M12 7v7M4.94144 4.93762l-.875 13.99998C4.03046 19.5133 4.48767 20 5.06449 20H15.9356c.5768 0 1.034-.4867.998-1.0624l-.875-13.99998C16.0257 4.41059 15.5887 4 15.0606 4H5.93949c-.52806 0-.96511.41059-.99805.93762Z"></path></svg>`), BeerMugEmptyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BeerMugEmptyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BeerMugEmptyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root62();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_162();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BeerMugEmptyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_262();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BeerMugEmptyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BeerMugEmptyOutline = hmr(BeerMugEmptyOutline, () => BeerMugEmptyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BeerMugEmptyOutline[HMR].source;
    set(BeerMugEmptyOutline[HMR].source, module.default[HMR].original);
  });
}
var BeerMugEmptyOutline_default = BeerMugEmptyOutline;

// node_modules/flowbite-svelte-icons/dist/BeerMugEmptySolid.svelte
BeerMugEmptySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BeerMugEmptySolid.svelte";
var root_163 = add_locations(from_svg(`<title> </title>`), BeerMugEmptySolid[FILENAME], [[41, 4]]);
var root_263 = add_locations(from_svg(`<desc> </desc>`), BeerMugEmptySolid[FILENAME], [[44, 4]]);
var root63 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3.94343 4.87524C4.00931 3.82117 4.88341 3 5.93953 3h9.12107c1.0562 0 1.9303.82117 1.9961 1.87524L17.0645 5h2.9356c.5523 0 1 .44772 1 1v3.85927c0 1.67173-.8355 3.23293-2.2265 4.16023l-1.0995.733L17.752 16H3.24813l.6953-11.12476ZM17.5298 12.445l.1344-.0896c.8346-.5564 1.3359-1.4931 1.3359-2.49613V7h-1.8106l.3403 5.445ZM10 7c0-.55228-.44772-1-1-1s-1 .44772-1 1v7c0 .5523.44772 1 1 1s1-.4477 1-1V7Zm3 0c0-.55228-.4477-1-1-1s-1 .44772-1 1v7c0 .5523.4477 1 1 1s1-.4477 1-1V7Z" clip-rule="evenodd"></path><path d="m3.12313 18-.0547.8752C2.99647 20.0266 3.91089 21 5.06453 21H15.9356c1.1537 0 2.0681-.9734 1.9961-2.1248L17.877 18H3.12313Z"></path></svg>`), BeerMugEmptySolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function BeerMugEmptySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BeerMugEmptySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root63();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_163();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BeerMugEmptySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_263();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BeerMugEmptySolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BeerMugEmptySolid = hmr(BeerMugEmptySolid, () => BeerMugEmptySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BeerMugEmptySolid[HMR].source;
    set(BeerMugEmptySolid[HMR].source, module.default[HMR].original);
  });
}
var BeerMugEmptySolid_default = BeerMugEmptySolid;

// node_modules/flowbite-svelte-icons/dist/BellActiveAltOutline.svelte
BellActiveAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveAltOutline.svelte";
var root_164 = add_locations(from_svg(`<title> </title>`), BellActiveAltOutline[FILENAME], [[43, 4]]);
var root_264 = add_locations(from_svg(`<desc> </desc>`), BellActiveAltOutline[FILENAME], [[46, 4]]);
var root64 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.365V3m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175 0 .593 0 1.193-.538 1.193H5.538c-.538 0-.538-.6-.538-1.193 0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.365Zm-8.134 5.368a8.458 8.458 0 0 1 2.252-5.714m14.016 5.714a8.458 8.458 0 0 0-2.252-5.714M8.54 17.901a3.48 3.48 0 0 0 6.92 0H8.54Z"></path></svg>`), BellActiveAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BellActiveAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellActiveAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root64();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_164();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellActiveAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_264();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellActiveAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellActiveAltOutline = hmr(BellActiveAltOutline, () => BellActiveAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveAltOutline[HMR].source;
    set(BellActiveAltOutline[HMR].source, module.default[HMR].original);
  });
}
var BellActiveAltOutline_default = BellActiveAltOutline;

// node_modules/flowbite-svelte-icons/dist/BellActiveAltSolid.svelte
BellActiveAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveAltSolid.svelte";
var root_165 = add_locations(from_svg(`<title> </title>`), BellActiveAltSolid[FILENAME], [[41, 4]]);
var root_265 = add_locations(from_svg(`<desc> </desc>`), BellActiveAltSolid[FILENAME], [[44, 4]]);
var root65 = add_locations(from_svg(`<svg><!><!><path d="M17.133 12.632v-1.8a5.407 5.407 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.933.933 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175Zm-13.267-.8a1 1 0 0 1-1-1 9.424 9.424 0 0 1 2.517-6.391A1.001 1.001 0 1 1 6.854 5.8a7.43 7.43 0 0 0-1.988 5.037 1 1 0 0 1-1 .995Zm16.268 0a1 1 0 0 1-1-1A7.431 7.431 0 0 0 17.146 5.8a1 1 0 0 1 1.471-1.354 9.424 9.424 0 0 1 2.517 6.391 1 1 0 0 1-1 .995ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellActiveAltSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BellActiveAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellActiveAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root65();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_165();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellActiveAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_265();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellActiveAltSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellActiveAltSolid = hmr(BellActiveAltSolid, () => BellActiveAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveAltSolid[HMR].source;
    set(BellActiveAltSolid[HMR].source, module.default[HMR].original);
  });
}
var BellActiveAltSolid_default = BellActiveAltSolid;

// node_modules/flowbite-svelte-icons/dist/BellActiveOutline.svelte
BellActiveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveOutline.svelte";
var root_166 = add_locations(from_svg(`<title> </title>`), BellActiveOutline[FILENAME], [[43, 4]]);
var root_266 = add_locations(from_svg(`<desc> </desc>`), BellActiveOutline[FILENAME], [[46, 4]]);
var root66 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.827 5.465-.435-2.324m.435 2.324a5.338 5.338 0 0 1 6.033 4.333l.331 1.769c.44 2.345 2.383 2.588 2.6 3.761.11.586.22 1.171-.31 1.271l-12.7 2.377c-.529.099-.639-.488-.749-1.074C5.813 16.73 7.538 15.8 7.1 13.455c-.219-1.169.218 1.162-.33-1.769a5.338 5.338 0 0 1 4.058-6.221Zm-7.046 4.41c.143-1.877.822-3.461 2.086-4.856m2.646 13.633a3.472 3.472 0 0 0 6.728-.777l.09-.5-6.818 1.277Z"></path></svg>`), BellActiveOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BellActiveOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellActiveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root66();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_166();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellActiveOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_266();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellActiveOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellActiveOutline = hmr(BellActiveOutline, () => BellActiveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveOutline[HMR].source;
    set(BellActiveOutline[HMR].source, module.default[HMR].original);
  });
}
var BellActiveOutline_default = BellActiveOutline;

// node_modules/flowbite-svelte-icons/dist/BellActiveSolid.svelte
BellActiveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveSolid.svelte";
var root_167 = add_locations(from_svg(`<title> </title>`), BellActiveSolid[FILENAME], [[41, 4]]);
var root_267 = add_locations(from_svg(`<desc> </desc>`), BellActiveSolid[FILENAME], [[44, 4]]);
var root67 = add_locations(from_svg(`<svg><!><!><path d="M11.209 3.816a1 1 0 0 0-1.966.368l.325 1.74a5.338 5.338 0 0 0-2.8 5.762l.276 1.473.055.296c.258 1.374-.228 2.262-.63 2.998-.285.52-.527.964-.437 1.449.11.586.22 1.173.75 1.074l12.7-2.377c.528-.1.418-.685.308-1.27-.103-.564-.636-1.123-1.195-1.711-.606-.636-1.243-1.306-1.404-2.051-.233-1.085-.275-1.387-.303-1.587-.009-.063-.016-.117-.028-.182a5.338 5.338 0 0 0-5.353-4.39l-.298-1.592Z"></path><path fill-rule="evenodd" d="M6.539 4.278a1 1 0 0 1 .07 1.412c-1.115 1.23-1.705 2.605-1.83 4.26a1 1 0 0 1-1.995-.15c.16-2.099.929-3.893 2.342-5.453a1 1 0 0 1 1.413-.069Z" clip-rule="evenodd"></path><path d="M8.95 19.7c.7.8 1.7 1.3 2.8 1.3 1.6 0 2.9-1.1 3.3-2.5l-6.1 1.2Z"></path></svg>`), BellActiveSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [53, 5]]]]);
function BellActiveSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellActiveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root67();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_167();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellActiveSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_267();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellActiveSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellActiveSolid = hmr(BellActiveSolid, () => BellActiveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveSolid[HMR].source;
    set(BellActiveSolid[HMR].source, module.default[HMR].original);
  });
}
var BellActiveSolid_default = BellActiveSolid;

// node_modules/flowbite-svelte-icons/dist/BellOutline.svelte
BellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellOutline.svelte";
var root_168 = add_locations(from_svg(`<title> </title>`), BellOutline[FILENAME], [[43, 4]]);
var root_268 = add_locations(from_svg(`<desc> </desc>`), BellOutline[FILENAME], [[46, 4]]);
var root68 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.365V3m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175 0 .593 0 1.292-.538 1.292H5.538C5 18 5 17.301 5 16.708c0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.365ZM8.733 18c.094.852.306 1.54.944 2.112a3.48 3.48 0 0 0 4.646 0c.638-.572 1.236-1.26 1.33-2.112h-6.92Z"></path></svg>`), BellOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BellOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root68();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_168();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_268();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellOutline = hmr(BellOutline, () => BellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellOutline[HMR].source;
    set(BellOutline[HMR].source, module.default[HMR].original);
  });
}
var BellOutline_default = BellOutline;

// node_modules/flowbite-svelte-icons/dist/BellRingOutline.svelte
BellRingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellRingOutline.svelte";
var root_169 = add_locations(from_svg(`<title> </title>`), BellRingOutline[FILENAME], [[43, 4]]);
var root_269 = add_locations(from_svg(`<desc> </desc>`), BellRingOutline[FILENAME], [[46, 4]]);
var root69 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.464V3.099m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175C19 17.4 19 18 18.462 18H5.538C5 18 5 17.4 5 16.807c0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.464ZM6 5 5 4M4 9H3m15-4 1-1m1 5h1M8.54 18a3.48 3.48 0 0 0 6.92 0H8.54Z"></path></svg>`), BellRingOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BellRingOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellRingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root69();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_169();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellRingOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_269();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellRingOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellRingOutline = hmr(BellRingOutline, () => BellRingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellRingOutline[HMR].source;
    set(BellRingOutline[HMR].source, module.default[HMR].original);
  });
}
var BellRingOutline_default = BellRingOutline;

// node_modules/flowbite-svelte-icons/dist/BellRingSolid.svelte
BellRingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellRingSolid.svelte";
var root_170 = add_locations(from_svg(`<title> </title>`), BellRingSolid[FILENAME], [[41, 4]]);
var root_270 = add_locations(from_svg(`<desc> </desc>`), BellRingSolid[FILENAME], [[44, 4]]);
var root70 = add_locations(from_svg(`<svg><!><!><path d="M17.133 12.632v-1.8a5.406 5.406 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.955.955 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175ZM6 6a1 1 0 0 1-.707-.293l-1-1a1 1 0 0 1 1.414-1.414l1 1A1 1 0 0 1 6 6Zm-2 4H3a1 1 0 0 1 0-2h1a1 1 0 1 1 0 2Zm14-4a1 1 0 0 1-.707-1.707l1-1a1 1 0 1 1 1.414 1.414l-1 1A1 1 0 0 1 18 6Zm3 4h-1a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellRingSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BellRingSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellRingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root70();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_170();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellRingSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_270();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellRingSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellRingSolid = hmr(BellRingSolid, () => BellRingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellRingSolid[HMR].source;
    set(BellRingSolid[HMR].source, module.default[HMR].original);
  });
}
var BellRingSolid_default = BellRingSolid;

// node_modules/flowbite-svelte-icons/dist/BellSolid.svelte
BellSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellSolid.svelte";
var root_171 = add_locations(from_svg(`<title> </title>`), BellSolid[FILENAME], [[41, 4]]);
var root_271 = add_locations(from_svg(`<desc> </desc>`), BellSolid[FILENAME], [[44, 4]]);
var root71 = add_locations(from_svg(`<svg><!><!><path d="M17.133 12.632v-1.8a5.406 5.406 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.955.955 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BellSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BellSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root71();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_171();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BellSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_271();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BellSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BellSolid = hmr(BellSolid, () => BellSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellSolid[HMR].source;
    set(BellSolid[HMR].source, module.default[HMR].original);
  });
}
var BellSolid_default = BellSolid;

// node_modules/flowbite-svelte-icons/dist/BitcoinSolid.svelte
BitcoinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BitcoinSolid.svelte";
var root_172 = add_locations(from_svg(`<title> </title>`), BitcoinSolid[FILENAME], [[41, 4]]);
var root_272 = add_locations(from_svg(`<desc> </desc>`), BitcoinSolid[FILENAME], [[44, 4]]);
var root72 = add_locations(from_svg(`<svg><!><!><path d="M10.7367 14.5876c.895.2365 2.8528.754 3.1643-.4966.3179-1.2781-1.5795-1.7039-2.5053-1.9117-.1034-.0232-.1947-.0437-.2694-.0623l-.6025 2.4153c.0611.0152.1328.0341.2129.0553Zm.8452-3.5291c.7468.1993 2.3746.6335 2.6581-.5025.2899-1.16213-1.2929-1.5124-2.066-1.68348-.0869-.01923-.1635-.03619-.2262-.0518l-.5462 2.19058c.0517.0129.1123.0291.1803.0472Z"></path><path fill-rule="evenodd" d="M9.57909 21.7008c5.35781 1.3356 10.78401-1.9244 12.11971-7.2816 1.3356-5.35745-1.9247-10.78433-7.2822-12.11995C9.06034.963624 3.6344 4.22425 2.2994 9.58206.963461 14.9389 4.22377 20.3652 9.57909 21.7008ZM14.2085 8.0526c1.3853.47719 2.3984 1.1925 2.1997 2.5231-.1441.9741-.6844 1.4456-1.4013 1.6116.9844.5128 1.485 1.2987 1.0078 2.6612-.5915 1.6919-1.9987 1.8347-3.8697 1.4807l-.454 1.8196-1.0972-.2734.4481-1.7953c-.2844-.0706-.575-.1456-.8741-.2269l-.44996 1.8038-1.09594-.2735.45407-1.8234c-.10059-.0258-.20185-.0522-.30385-.0788-.15753-.0411-.3168-.0827-.47803-.1231l-1.42812-.3559.54468-1.2563s.80844.215.7975.1991c.31063.0769.44844-.1256.50282-.2606l.71781-2.8766.11562.0288c-.04375-.0175-.08343-.0288-.11406-.0366l.51188-2.05344c.01375-.23312-.06688-.52719-.51125-.63812.01718-.01157-.79688-.19813-.79688-.19813l.29188-1.17187 1.51313.37781-.0013.00562c.2275.05657.4619.11032.7007.16469l.4497-1.80187 1.0965.27343-.4406 1.76657c.2944.06718.5906.135.8787.20687l.4375-1.755 1.0975.27344-.4493 1.8025Z" clip-rule="evenodd"></path></svg>`), BitcoinSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function BitcoinSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BitcoinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root72();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_172();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BitcoinSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_272();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BitcoinSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BitcoinSolid = hmr(BitcoinSolid, () => BitcoinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BitcoinSolid[HMR].source;
    set(BitcoinSolid[HMR].source, module.default[HMR].original);
  });
}
var BitcoinSolid_default = BitcoinSolid;

// node_modules/flowbite-svelte-icons/dist/BlenderPhoneOutline.svelte
BlenderPhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BlenderPhoneOutline.svelte";
var root_173 = add_locations(from_svg(`<title> </title>`), BlenderPhoneOutline[FILENAME], [[43, 4]]);
var root_273 = add_locations(from_svg(`<desc> </desc>`), BlenderPhoneOutline[FILENAME], [[46, 4]]);
var root73 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20.283 8h-4.285m3.85 3h-3.85m4.061-6H11v11h8.27l1.715-9.847A.983.983 0 0 0 20.059 5ZM6.581 13.23h-.838A13.752 13.752 0 0 1 5.622 11c-.02-.745.02-1.49.12-2.23h1.04c.252 0 .496-.088.683-.245a.927.927 0 0 0 .329-.61l.2-1.872a.888.888 0 0 0-.045-.39.936.936 0 0 0-.212-.34 1.017 1.017 0 0 0-.341-.231A1.08 1.08 0 0 0 6.983 5h-2.06a1.27 1.27 0 0 0-.699.204 1.135 1.135 0 0 0-.442.543A15.066 15.066 0 0 0 3.007 11a15.656 15.656 0 0 0 .795 5.229c.165.462 1.342.771 1.864.771h1.116c.142 0 .283-.028.413-.082.13-.053.246-.132.341-.23a.936.936 0 0 0 .212-.34.889.889 0 0 0 .046-.391l-.201-1.873a.927.927 0 0 0-.33-.609 1.059 1.059 0 0 0-.682-.245ZM10 18v1h10v-1a2 2 0 0 0-2-2h-6a2 2 0 0 0-2 2Z"></path></svg>`), BlenderPhoneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BlenderPhoneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BlenderPhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root73();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_173();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BlenderPhoneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_273();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BlenderPhoneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BlenderPhoneOutline = hmr(BlenderPhoneOutline, () => BlenderPhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BlenderPhoneOutline[HMR].source;
    set(BlenderPhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var BlenderPhoneOutline_default = BlenderPhoneOutline;

// node_modules/flowbite-svelte-icons/dist/BlenderPhoneSolid.svelte
BlenderPhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BlenderPhoneSolid.svelte";
var root_174 = add_locations(from_svg(`<title> </title>`), BlenderPhoneSolid[FILENAME], [[41, 4]]);
var root_274 = add_locations(from_svg(`<desc> </desc>`), BlenderPhoneSolid[FILENAME], [[44, 4]]);
var root74 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11 4a1 1 0 0 0-1 1v10h10.459l.522-3H16a1 1 0 1 1 0-2h5.33l.174-1H16a1 1 0 1 1 0-2h5.852l.117-.67v-.003A1.983 1.983 0 0 0 20.06 4H11ZM9 18c0-.35.06-.687.17-1h11.66c.11.313.17.65.17 1v1a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1v-1Zm-6.991-7a17.8 17.8 0 0 0 .953 6.1c.198.54 1.61.9 2.237.9h1.34c.17 0 .339-.032.495-.095a1.24 1.24 0 0 0 .41-.27c.114-.114.2-.25.254-.396a1.01 1.01 0 0 0 .055-.456l-.242-2.185a1.073 1.073 0 0 0-.395-.71 1.292 1.292 0 0 0-.819-.286H5.291c-.12-.863-.17-1.732-.145-2.602-.024-.87.024-1.74.145-2.602H6.54c.302 0 .594-.102.818-.286a1.07 1.07 0 0 0 .396-.71l.24-2.185a1.01 1.01 0 0 0-.054-.456 1.088 1.088 0 0 0-.254-.397 1.223 1.223 0 0 0-.41-.269A1.328 1.328 0 0 0 6.78 4H4.307c-.3-.001-.592.082-.838.238a1.335 1.335 0 0 0-.531.634A17.127 17.127 0 0 0 2.008 11Z" clip-rule="evenodd"></path></svg>`), BlenderPhoneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BlenderPhoneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BlenderPhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root74();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_174();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BlenderPhoneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_274();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BlenderPhoneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BlenderPhoneSolid = hmr(BlenderPhoneSolid, () => BlenderPhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BlenderPhoneSolid[HMR].source;
    set(BlenderPhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var BlenderPhoneSolid_default = BlenderPhoneSolid;

// node_modules/flowbite-svelte-icons/dist/BoneOutline.svelte
BoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoneOutline.svelte";
var root_175 = add_locations(from_svg(`<title> </title>`), BoneOutline[FILENAME], [[43, 4]]);
var root_275 = add_locations(from_svg(`<desc> </desc>`), BoneOutline[FILENAME], [[46, 4]]);
var root75 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="M16.8879 7.11205c.1788-.77492-.1192-1.66905-.7153-2.26515-1.0133-1.01335-2.5632-1.01335-3.5765 0-1.0134 1.01336-1.0134 2.5632 0 3.57655L8.42342 12.5961c-1.01336-1.0134-2.5632-1.0134-3.57655 0-1.01336 1.0133-1.01336 2.5632 0 3.5765.59609.5961 1.49023.8942 2.26515.7154-.17883.7749.11921 1.669.71531 2.2651 1.01335 1.0134 2.56317 1.0134 3.57657 0 1.0133-1.0134 1.0133-2.5632 0-3.5765l4.1726-4.1727c1.0134 1.0134 2.5632 1.0134 3.5766 0 1.0133-1.0133 1.0133-2.56318 0-3.57654-.5961-.59609-1.4903-.89414-2.2652-.71531Z"></path></svg>`), BoneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BoneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root75();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_175();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BoneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_275();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BoneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BoneOutline = hmr(BoneOutline, () => BoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoneOutline[HMR].source;
    set(BoneOutline[HMR].source, module.default[HMR].original);
  });
}
var BoneOutline_default = BoneOutline;

// node_modules/flowbite-svelte-icons/dist/BoneSolid.svelte
BoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoneSolid.svelte";
var root_176 = add_locations(from_svg(`<title> </title>`), BoneSolid[FILENAME], [[41, 4]]);
var root_276 = add_locations(from_svg(`<desc> </desc>`), BoneSolid[FILENAME], [[44, 4]]);
var root76 = add_locations(from_svg(`<svg><!><!><path d="M4.13982 11.889c-1.40388 1.4039-1.40388 3.5869 0 4.9907.52114.5212 1.22247.8909 1.9657 1.0148.12387.7432.49363 1.4446 1.01476 1.9657 1.40388 1.4039 3.58692 1.4039 4.99072 0 1.1572-1.1571 1.3605-2.8435.6102-4.1867l2.9523-2.9523c1.3432.7503 3.0296.5469 4.1867-.6102 1.4039-1.4039 1.4039-3.58687 0-4.99075-.5211-.52113-1.2224-.89089-1.9657-1.01476-.1238-.74323-.4936-1.44456-1.0147-1.9657-1.4039-1.40388-3.5869-1.40388-4.9908 0-1.1571 1.15712-1.3605 2.84353-.6102 4.18672L8.32654 11.2788c-1.34319-.7503-3.0296-.5469-4.18672.6102Z"></path></svg>`), BoneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BoneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root76();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_176();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BoneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_276();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BoneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BoneSolid = hmr(BoneSolid, () => BoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoneSolid[HMR].source;
    set(BoneSolid[HMR].source, module.default[HMR].original);
  });
}
var BoneSolid_default = BoneSolid;

// node_modules/flowbite-svelte-icons/dist/BookmarkOutline.svelte
BookmarkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookmarkOutline.svelte";
var root_177 = add_locations(from_svg(`<title> </title>`), BookmarkOutline[FILENAME], [[43, 4]]);
var root_277 = add_locations(from_svg(`<desc> </desc>`), BookmarkOutline[FILENAME], [[46, 4]]);
var root77 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17 21-5-4-5 4V3.889a.92.92 0 0 1 .244-.629.808.808 0 0 1 .59-.26h8.333a.81.81 0 0 1 .589.26.92.92 0 0 1 .244.63V21Z"></path></svg>`), BookmarkOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BookmarkOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookmarkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root77();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_177();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookmarkOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_277();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookmarkOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookmarkOutline = hmr(BookmarkOutline, () => BookmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookmarkOutline[HMR].source;
    set(BookmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var BookmarkOutline_default = BookmarkOutline;

// node_modules/flowbite-svelte-icons/dist/BookmarkSolid.svelte
BookmarkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookmarkSolid.svelte";
var root_178 = add_locations(from_svg(`<title> </title>`), BookmarkSolid[FILENAME], [[41, 4]]);
var root_278 = add_locations(from_svg(`<desc> </desc>`), BookmarkSolid[FILENAME], [[44, 4]]);
var root78 = add_locations(from_svg(`<svg><!><!><path d="M7.833 2c-.507 0-.98.216-1.318.576A1.92 1.92 0 0 0 6 3.89V21a1 1 0 0 0 1.625.78L12 18.28l4.375 3.5A1 1 0 0 0 18 21V3.889c0-.481-.178-.954-.515-1.313A1.808 1.808 0 0 0 16.167 2H7.833Z"></path></svg>`), BookmarkSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BookmarkSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookmarkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root78();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_178();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookmarkSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_278();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookmarkSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookmarkSolid = hmr(BookmarkSolid, () => BookmarkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookmarkSolid[HMR].source;
    set(BookmarkSolid[HMR].source, module.default[HMR].original);
  });
}
var BookmarkSolid_default = BookmarkSolid;

// node_modules/flowbite-svelte-icons/dist/BookOpenOutline.svelte
BookOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenOutline.svelte";
var root_179 = add_locations(from_svg(`<title> </title>`), BookOpenOutline[FILENAME], [[43, 4]]);
var root_279 = add_locations(from_svg(`<desc> </desc>`), BookOpenOutline[FILENAME], [[46, 4]]);
var root79 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6.03v13m0-13c-2.819-.831-4.715-1.076-8.029-1.023A.99.99 0 0 0 3 6v11c0 .563.466 1.014 1.03 1.007 3.122-.043 5.018.212 7.97 1.023m0-13c2.819-.831 4.715-1.076 8.029-1.023A.99.99 0 0 1 21 6v11c0 .563-.466 1.014-1.03 1.007-3.122-.043-5.018.212-7.97 1.023"></path></svg>`), BookOpenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BookOpenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root79();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_179();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookOpenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_279();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookOpenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookOpenOutline = hmr(BookOpenOutline, () => BookOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenOutline[HMR].source;
    set(BookOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var BookOpenOutline_default = BookOpenOutline;

// node_modules/flowbite-svelte-icons/dist/BookOpenReaderOutline.svelte
BookOpenReaderOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenReaderOutline.svelte";
var root_180 = add_locations(from_svg(`<title> </title>`), BookOpenReaderOutline[FILENAME], [[43, 4]]);
var root_280 = add_locations(from_svg(`<desc> </desc>`), BookOpenReaderOutline[FILENAME], [[46, 4]]);
var root80 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M12.1429 11v9m0-9c-2.50543-.7107-3.19099-1.39543-6.13657-1.34968-.48057.00746-.86348.38718-.86348.84968v7.2884c0 .4824.41455.8682.91584.8617 2.77491-.0362 3.45995.6561 6.08421 1.3499m0-9c2.5053-.7107 3.1067-1.39542 6.0523-1.34968.4806.00746.9477.38718.9477.84968v7.2884c0 .4824-.4988.8682-1 .8617-2.775-.0362-3.3758.6561-6 1.3499m2-14c0 1.10457-.8955 2-2 2-1.1046 0-2-.89543-2-2s.8954-2 2-2c1.1045 0 2 .89543 2 2Z"></path></svg>`), BookOpenReaderOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BookOpenReaderOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookOpenReaderOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root80();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_180();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookOpenReaderOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_280();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookOpenReaderOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookOpenReaderOutline = hmr(BookOpenReaderOutline, () => BookOpenReaderOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenReaderOutline[HMR].source;
    set(BookOpenReaderOutline[HMR].source, module.default[HMR].original);
  });
}
var BookOpenReaderOutline_default = BookOpenReaderOutline;

// node_modules/flowbite-svelte-icons/dist/BookOpenReaderSolid.svelte
BookOpenReaderSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenReaderSolid.svelte";
var root_181 = add_locations(from_svg(`<title> </title>`), BookOpenReaderSolid[FILENAME], [[41, 4]]);
var root_281 = add_locations(from_svg(`<desc> </desc>`), BookOpenReaderSolid[FILENAME], [[44, 4]]);
var root81 = add_locations(from_svg(`<svg><!><!><path d="M9 6c0-1.65685 1.3431-3 3-3s3 1.34315 3 3-1.3431 3-3 3-3-1.34315-3-3Zm2 3.62992c-.1263-.04413-.25-.08799-.3721-.13131-1.33928-.47482-2.49256-.88372-4.77995-.8482C4.84875 8.66593 4 9.46413 4 10.5v7.2884c0 1.0878.91948 1.8747 1.92888 1.8616 1.283-.0168 2.04625.1322 2.79671.3587.29285.0883.57733.1863.90372.2987l.00249.0008c.11983.0413.24534.0845.379.1299.2989.1015.6242.2088.9892.3185V9.62992Zm2-.00374V20.7551c.5531-.1678 1.0379-.3374 1.4545-.4832.2956-.1034.5575-.1951.7846-.2653.7257-.2245 1.4655-.3734 2.7479-.3566.5019.0065.9806-.1791 1.3407-.4788.3618-.3011.6723-.781.6723-1.3828V10.5c0-.58114-.2923-1.05022-.6377-1.3503-.3441-.29904-.8047-.49168-1.2944-.49929-2.2667-.0352-3.386.36906-4.6847.83812-.1256.04539-.253.09138-.3832.13765Z"></path></svg>`), BookOpenReaderSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BookOpenReaderSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookOpenReaderSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root81();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_181();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookOpenReaderSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_281();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookOpenReaderSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookOpenReaderSolid = hmr(BookOpenReaderSolid, () => BookOpenReaderSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenReaderSolid[HMR].source;
    set(BookOpenReaderSolid[HMR].source, module.default[HMR].original);
  });
}
var BookOpenReaderSolid_default = BookOpenReaderSolid;

// node_modules/flowbite-svelte-icons/dist/BookOpenSolid.svelte
BookOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenSolid.svelte";
var root_182 = add_locations(from_svg(`<title> </title>`), BookOpenSolid[FILENAME], [[41, 4]]);
var root_282 = add_locations(from_svg(`<desc> </desc>`), BookOpenSolid[FILENAME], [[44, 4]]);
var root82 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11 4.717c-2.286-.58-4.16-.756-7.045-.71A1.99 1.99 0 0 0 2 6v11c0 1.133.934 2.022 2.044 2.007 2.759-.038 4.5.16 6.956.791V4.717Zm2 15.081c2.456-.631 4.198-.829 6.956-.791A2.013 2.013 0 0 0 22 16.999V6a1.99 1.99 0 0 0-1.955-1.993c-2.885-.046-4.76.13-7.045.71v15.081Z" clip-rule="evenodd"></path></svg>`), BookOpenSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BookOpenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root82();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_182();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookOpenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_282();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookOpenSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookOpenSolid = hmr(BookOpenSolid, () => BookOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenSolid[HMR].source;
    set(BookOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var BookOpenSolid_default = BookOpenSolid;

// node_modules/flowbite-svelte-icons/dist/BookOutline.svelte
BookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOutline.svelte";
var root_183 = add_locations(from_svg(`<title> </title>`), BookOutline[FILENAME], [[43, 4]]);
var root_283 = add_locations(from_svg(`<desc> </desc>`), BookOutline[FILENAME], [[46, 4]]);
var root83 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 19V4a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v13H7a2 2 0 0 0-2 2Zm0 0a2 2 0 0 0 2 2h12M9 3v14m7 0v4"></path></svg>`), BookOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BookOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root83();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_183();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_283();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookOutline = hmr(BookOutline, () => BookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOutline[HMR].source;
    set(BookOutline[HMR].source, module.default[HMR].original);
  });
}
var BookOutline_default = BookOutline;

// node_modules/flowbite-svelte-icons/dist/BookSolid.svelte
BookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookSolid.svelte";
var root_184 = add_locations(from_svg(`<title> </title>`), BookSolid[FILENAME], [[41, 4]]);
var root_284 = add_locations(from_svg(`<desc> </desc>`), BookSolid[FILENAME], [[44, 4]]);
var root84 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 2a2 2 0 0 0-2 2v15a3 3 0 0 0 3 3h12a1 1 0 1 0 0-2h-2v-2h2a1 1 0 0 0 1-1V4a2 2 0 0 0-2-2h-8v16h5v2H7a1 1 0 1 1 0-2h1V2H6Z" clip-rule="evenodd"></path></svg>`), BookSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BookSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root84();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_184();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BookSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_284();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BookSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BookSolid = hmr(BookSolid, () => BookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookSolid[HMR].source;
    set(BookSolid[HMR].source, module.default[HMR].original);
  });
}
var BookSolid_default = BookSolid;

// node_modules/flowbite-svelte-icons/dist/BoothCurtainOutline.svelte
BoothCurtainOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoothCurtainOutline.svelte";
var root_185 = add_locations(from_svg(`<title> </title>`), BoothCurtainOutline[FILENAME], [[43, 4]]);
var root_285 = add_locations(from_svg(`<desc> </desc>`), BoothCurtainOutline[FILENAME], [[46, 4]]);
var root85 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 5v14m14 0V8h2M3 8h6m0-2v8.5858c0 .8909 1.0771 1.3371 1.7071.7071l.5858-.5858c.3905-.3905 1.0237-.3905 1.4142 0l.5858.5858c.3905.3905 1.0237.3905 1.4142 0l.5858-.5858c.3905-.3905 1.0237-.3905 1.4142 0l.5858.5858c.63.63 1.7071.1838 1.7071-.7071V6c0-.55228-.4477-1-1-1h-8c-.55229 0-1 .44772-1 1Z"></path></svg>`), BoothCurtainOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BoothCurtainOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BoothCurtainOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root85();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_185();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BoothCurtainOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_285();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BoothCurtainOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BoothCurtainOutline = hmr(BoothCurtainOutline, () => BoothCurtainOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoothCurtainOutline[HMR].source;
    set(BoothCurtainOutline[HMR].source, module.default[HMR].original);
  });
}
var BoothCurtainOutline_default = BoothCurtainOutline;

// node_modules/flowbite-svelte-icons/dist/BoothCurtainSolid.svelte
BoothCurtainSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoothCurtainSolid.svelte";
var root_186 = add_locations(from_svg(`<title> </title>`), BoothCurtainSolid[FILENAME], [[41, 4]]);
var root_286 = add_locations(from_svg(`<desc> </desc>`), BoothCurtainSolid[FILENAME], [[44, 4]]);
var root86 = add_locations(from_svg(`<svg><!><!><path d="M4 5v2H3a1 1 0 0 0 0 2h1v10a1 1 0 1 0 2 0V9h2v5.586c0 1.782 2.154 2.674 3.414 1.414l.586-.586.586.586a2 2 0 0 0 2.828 0l.586-.586.586.586c.411.411.918.593 1.414.59V19a1 1 0 1 0 2 0V9h1a1 1 0 1 0 0-2h-1V6a2 2 0 0 0-2-2h-8a2 2 0 0 0-2 2v1H6V5a1 1 0 0 0-2 0Z"></path></svg>`), BoothCurtainSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BoothCurtainSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BoothCurtainSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root86();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_186();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BoothCurtainSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_286();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BoothCurtainSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BoothCurtainSolid = hmr(BoothCurtainSolid, () => BoothCurtainSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoothCurtainSolid[HMR].source;
    set(BoothCurtainSolid[HMR].source, module.default[HMR].original);
  });
}
var BoothCurtainSolid_default = BoothCurtainSolid;

// node_modules/flowbite-svelte-icons/dist/BowlFoodOutline.svelte
BowlFoodOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BowlFoodOutline.svelte";
var root_187 = add_locations(from_svg(`<title> </title>`), BowlFoodOutline[FILENAME], [[43, 4]]);
var root_287 = add_locations(from_svg(`<desc> </desc>`), BowlFoodOutline[FILENAME], [[46, 4]]);
var root87 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.011 13H20c-.367 2.5551-2.32 4.6825-4.9766 5.6162V20H8.97661v-1.3838C6.31996 17.6825 4.36697 15.5551 4 13h14.011Zm0 0c1.0995-.0059 1.989-.8991 1.989-2 0-.8637-.5475-1.59948-1.3143-1.87934M18.011 13H18m0-3.99997c.2409 0 .4718.04258.6857.12063m0 0c.8367-1.0335.7533-2.67022-.2802-3.50694-1.0335-.83672-2.5496-.6772-3.3864.35631-.293-1.50236-1.7485-2.15377-3.2509-1.8607-1.5023.29308-2.48263 1.74856-2.18956 3.25092C8.9805 6.17263 7.6182 5.26418 6.15462 6.00131 4.967 6.59945 4.45094 8.19239 5.04909 9.38002m0 0C4.37083 9.66467 4 10.3357 4 11.1174 4 12.1571 4.84288 13 5.88263 13m-.83354-3.61998c.2866-.12029 1.09613-.40074 2.04494.3418m5.27497-.89091c1.0047-.4589 2.1913-.01641 2.6502.98832"></path></svg>`), BowlFoodOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BowlFoodOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BowlFoodOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root87();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_187();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BowlFoodOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_287();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BowlFoodOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BowlFoodOutline = hmr(BowlFoodOutline, () => BowlFoodOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BowlFoodOutline[HMR].source;
    set(BowlFoodOutline[HMR].source, module.default[HMR].original);
  });
}
var BowlFoodOutline_default = BowlFoodOutline;

// node_modules/flowbite-svelte-icons/dist/BowlFoodSolid.svelte
BowlFoodSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BowlFoodSolid.svelte";
var root_188 = add_locations(from_svg(`<title> </title>`), BowlFoodSolid[FILENAME], [[41, 4]]);
var root_288 = add_locations(from_svg(`<desc> </desc>`), BowlFoodSolid[FILENAME], [[44, 4]]);
var root88 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M21 11.0001c0-.8815-.3799-1.6731-.984-2.22145.5031-1.33846.2177-2.97144-.9813-3.94213-1.059-.8574-2.4761-.97568-3.6271-.42051-.2908-.39083-.6632-.70423-1.0895-.93179-.8229-.43923-1.8026-.53949-2.7413-.35637-1.2172.23745-2.18257 1.03558-2.68037 2.07405-.08983-.05265-.18224-.10165-.27714-.14661-.86027-.40752-1.89128-.46242-2.91449.05292-1.40603.70815-2.13029 2.35257-1.84394 3.8504-.16121.14468-.30525.31046-.42787.49818C3.13246 9.91685 3 10.4482 3 11.0001c0 .5506.445.9972.99497.9999H20.005c.55-.0027.995-.4493.995-.9999Zm-6.8905-.7654c-.2294-.50238-.8227-.72362-1.325-.49417-.5024.22945-1.0956.00821-1.3251-.49415-.2294-.50237-.0082-1.09562.4942-1.32507 1.5071-.68836 3.2868-.02463 3.9752 1.48247.2294.50236.0082 1.09562-.4942 1.32502-.5024.2295-1.0956.0083-1.3251-.4941Z" clip-rule="evenodd"></path><path d="M20.3593 15.2241c.2828-.5949-.195-1.2241-.8537-1.2241H4.49439c-.6587 0-1.1365.6292-.85371 1.2241.85327 1.7951 2.4178 3.2323 4.33593 4.0722V20c0 .5523.44772 1 1 1h6.04679c.5523 0 1-.4477 1-1v-.7037c1.9181-.8399 3.4827-2.2771 4.3359-4.0722Z"></path></svg>`), BowlFoodSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function BowlFoodSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BowlFoodSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root88();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_188();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BowlFoodSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_288();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BowlFoodSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BowlFoodSolid = hmr(BowlFoodSolid, () => BowlFoodSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BowlFoodSolid[HMR].source;
    set(BowlFoodSolid[HMR].source, module.default[HMR].original);
  });
}
var BowlFoodSolid_default = BowlFoodSolid;

// node_modules/flowbite-svelte-icons/dist/BowlRiceOutline.svelte
BowlRiceOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BowlRiceOutline.svelte";
var root_189 = add_locations(from_svg(`<title> </title>`), BowlRiceOutline[FILENAME], [[43, 4]]);
var root_289 = add_locations(from_svg(`<desc> </desc>`), BowlRiceOutline[FILENAME], [[46, 4]]);
var root89 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 9.99999h.01m-5.01 0h.01m-5.01 0h.01m6.99-2h.01m-4.01 0h.01M6.5 13C5.11929 13 4 11.5609 4 9.78571c0-1.51294.45014-3.74021 2.96705-3.45229 0-2.59313 4.39355-3.02689 5.16885-1.10126.5-.64286 1.5465-1.20611 2.5405-1.09637 1.2588.13899 2.0504 1.03413 2.2104 2.19763 1.7674 0 3.3338 1.31661 3.1132 3.45229C20 11.5609 18.8807 13 17.5 13m-8.52339 5.6162V20h6.04679v-1.3838C17.68 17.6825 19.633 15.5551 20 13H4c.36697 2.5551 2.31996 4.6825 4.97661 5.6162Z"></path></svg>`), BowlRiceOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BowlRiceOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BowlRiceOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root89();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_189();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BowlRiceOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_289();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BowlRiceOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BowlRiceOutline = hmr(BowlRiceOutline, () => BowlRiceOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BowlRiceOutline[HMR].source;
    set(BowlRiceOutline[HMR].source, module.default[HMR].original);
  });
}
var BowlRiceOutline_default = BowlRiceOutline;

// node_modules/flowbite-svelte-icons/dist/BowlRiceSolid.svelte
BowlRiceSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BowlRiceSolid.svelte";
var root_190 = add_locations(from_svg(`<title> </title>`), BowlRiceSolid[FILENAME], [[41, 4]]);
var root_290 = add_locations(from_svg(`<desc> </desc>`), BowlRiceSolid[FILENAME], [[44, 4]]);
var root90 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.2605 3.79368c-.281-.22353-.5975-.3898-.9173-.5062-.7024-.25567-1.49918-.30568-2.24095-.18661-1.15818.18592-2.51613.88193-2.97474 2.22764-.40442.04107-.77944.1442-1.12195.31017-.59942.29046-1.02697.73841-1.32274 1.22999C3.11436 7.81349 3 8.97014 3 9.78568c0 .89142.27124 1.65012.76053 2.21432H20.3218c.0101-.0125.0201-.0251.0301-.0379.4919-.6324.6411-1.4185.6479-2.12509.1233-1.32715-.3036-2.47-1.0971-3.27874-.6018-.6132-1.3829-1.00304-2.2193-1.15392-.431-1.19435-1.444-2.10209-2.8973-2.26254-.9135-.10087-1.819.19102-2.5256.65187ZM9 8c0-.55228.44772-1 1-1h.01c.5523 0 1 .44772 1 1s-.4477 1-1 1H10c-.55228 0-1-.44772-1-1Zm4 0c0-.55228.4477-1 1-1h.01c.5523 0 1 .44772 1 1s-.4477 1-1 1H14c-.5523 0-1-.44772-1-1Zm-7 2c0-.55228.44772-1 1-1h.01c.55228 0 1 .44772 1 1 0 .5523-.44772 1-1 1H7c-.55228 0-1-.4477-1-1Zm5 0c0-.55228.4477-1 1-1h.01c.5523 0 1 .44772 1 1 0 .5523-.4477 1-1 1H12c-.5523 0-1-.4477-1-1Zm5 0c0-.55228.4477-1 1-1h.01c.5523 0 1 .44772 1 1 0 .5523-.4477 1-1 1H17c-.5523 0-1-.4477-1-1Z" clip-rule="evenodd"></path><path d="M20.6134 14.6222c.1145-.3088-.1249-.6222-.4542-.6222H3.84086c-.32935 0-.56875.3134-.45429.6222.76918 2.0753 2.462 3.7423 4.59004 4.6741V20c0 .5523.44772 1 1 1h6.04679c.5523 0 1-.4477 1-1v-.7037c2.128-.9318 3.8209-2.5988 4.59-4.6741Z"></path></svg>`), BowlRiceSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function BowlRiceSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BowlRiceSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root90();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_190();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BowlRiceSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_290();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BowlRiceSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BowlRiceSolid = hmr(BowlRiceSolid, () => BowlRiceSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BowlRiceSolid[HMR].source;
    set(BowlRiceSolid[HMR].source, module.default[HMR].original);
  });
}
var BowlRiceSolid_default = BowlRiceSolid;

// node_modules/flowbite-svelte-icons/dist/BrainOutline.svelte
BrainOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BrainOutline.svelte";
var root_191 = add_locations(from_svg(`<title> </title>`), BrainOutline[FILENAME], [[43, 4]]);
var root_291 = add_locations(from_svg(`<desc> </desc>`), BrainOutline[FILENAME], [[46, 4]]);
var root91 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 18.5A2.493 2.493 0 0 1 7.51 20H7.5a2.468 2.468 0 0 1-2.4-3.154 2.98 2.98 0 0 1-.85-5.274 2.468 2.468 0 0 1 .92-3.182 2.477 2.477 0 0 1 1.876-3.344 2.5 2.5 0 0 1 3.41-1.856A2.5 2.5 0 0 1 12 5.5m0 13v-13m0 13a2.493 2.493 0 0 0 4.49 1.5h.01a2.468 2.468 0 0 0 2.403-3.154 2.98 2.98 0 0 0 .847-5.274 2.468 2.468 0 0 0-.921-3.182 2.477 2.477 0 0 0-1.875-3.344A2.5 2.5 0 0 0 14.5 3 2.5 2.5 0 0 0 12 5.5m-8 5a2.5 2.5 0 0 1 3.48-2.3m-.28 8.551a3 3 0 0 1-2.953-5.185M20 10.5a2.5 2.5 0 0 0-3.481-2.3m.28 8.551a3 3 0 0 0 2.954-5.185"></path></svg>`), BrainOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BrainOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BrainOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root91();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_191();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BrainOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_291();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BrainOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BrainOutline = hmr(BrainOutline, () => BrainOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BrainOutline[HMR].source;
    set(BrainOutline[HMR].source, module.default[HMR].original);
  });
}
var BrainOutline_default = BrainOutline;

// node_modules/flowbite-svelte-icons/dist/BrainSolid.svelte
BrainSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BrainSolid.svelte";
var root_192 = add_locations(from_svg(`<title> </title>`), BrainSolid[FILENAME], [[41, 4]]);
var root_292 = add_locations(from_svg(`<desc> </desc>`), BrainSolid[FILENAME], [[44, 4]]);
var root92 = add_locations(from_svg(`<svg><!><!><path d="M11 21V2.352A3.451 3.451 0 0 0 9.5 2a3.5 3.5 0 0 0-3.261 2.238A3.5 3.5 0 0 0 4.04 8.015a3.518 3.518 0 0 0-.766 1.128c-.042.1-.064.209-.1.313a3.34 3.34 0 0 0-.106.344 3.463 3.463 0 0 0 .02 1.468A4.017 4.017 0 0 0 2.3 12.5l-.015.036a3.861 3.861 0 0 0-.216.779A3.968 3.968 0 0 0 2 14c.003.24.027.48.072.716a4 4 0 0 0 .235.832c.006.014.015.027.021.041a3.85 3.85 0 0 0 .417.727c.105.146.219.285.342.415.072.076.148.146.225.216.1.091.205.179.315.26.11.081.2.14.308.2.02.013.039.028.059.04v.053a3.506 3.506 0 0 0 3.03 3.469 3.426 3.426 0 0 0 4.154.577A.972.972 0 0 1 11 21Zm10.934-7.68a3.956 3.956 0 0 0-.215-.779l-.017-.038a4.016 4.016 0 0 0-.79-1.235 3.417 3.417 0 0 0 .017-1.468 3.387 3.387 0 0 0-.1-.333c-.034-.108-.057-.22-.1-.324a3.517 3.517 0 0 0-.766-1.128 3.5 3.5 0 0 0-2.202-3.777A3.5 3.5 0 0 0 14.5 2a3.451 3.451 0 0 0-1.5.352V21a.972.972 0 0 1-.184.546 3.426 3.426 0 0 0 4.154-.577A3.506 3.506 0 0 0 20 17.5v-.049c.02-.012.039-.027.059-.04.106-.064.208-.13.308-.2s.214-.169.315-.26c.077-.07.153-.14.225-.216a4.007 4.007 0 0 0 .459-.588c.115-.176.215-.361.3-.554.006-.014.015-.027.021-.041.087-.213.156-.434.205-.659.013-.057.024-.115.035-.173.046-.237.07-.478.073-.72a3.948 3.948 0 0 0-.066-.68Z"></path></svg>`), BrainSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BrainSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BrainSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root92();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_192();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BrainSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_292();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BrainSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BrainSolid = hmr(BrainSolid, () => BrainSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BrainSolid[HMR].source;
    set(BrainSolid[HMR].source, module.default[HMR].original);
  });
}
var BrainSolid_default = BrainSolid;

// node_modules/flowbite-svelte-icons/dist/BreadSliceOutline.svelte
BreadSliceOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BreadSliceOutline.svelte";
var root_193 = add_locations(from_svg(`<title> </title>`), BreadSliceOutline[FILENAME], [[43, 4]]);
var root_293 = add_locations(from_svg(`<desc> </desc>`), BreadSliceOutline[FILENAME], [[46, 4]]);
var root93 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 19v-9c-1.5 0-2-1.5-2-2.49997 0-.99997.5-2 2-2.50003 2.36416-.64329 4.2009-.97557 6-.98904 1.7991.01347 3.6358.34575 6 .98904 1.5.50003 2 1.50006 2 2.50003C20 8.5 19.5 10 18 10v9c0 .5523-.4477 1-1 1H7c-.55228 0-1-.4477-1-1Z"></path></svg>`), BreadSliceOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BreadSliceOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BreadSliceOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root93();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_193();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BreadSliceOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_293();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BreadSliceOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BreadSliceOutline = hmr(BreadSliceOutline, () => BreadSliceOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BreadSliceOutline[HMR].source;
    set(BreadSliceOutline[HMR].source, module.default[HMR].original);
  });
}
var BreadSliceOutline_default = BreadSliceOutline;

// node_modules/flowbite-svelte-icons/dist/BreadSliceSolid.svelte
BreadSliceSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BreadSliceSolid.svelte";
var root_194 = add_locations(from_svg(`<title> </title>`), BreadSliceSolid[FILENAME], [[41, 4]]);
var root_294 = add_locations(from_svg(`<desc> </desc>`), BreadSliceSolid[FILENAME], [[44, 4]]);
var root94 = add_locations(from_svg(`<svg><!><!><path d="M11.9925 3.01102c-1.9214.01439-3.85188.37019-6.25505 1.0241-.01805.00491-.03595.01032-.05369.01624-.91244.30416-1.60323.7905-2.06 1.42998C3.16866 6.1185 3 6.83191 3 7.50006c0 .63697.15395 1.45811.5895 2.15498.31425.50276.78203.94286 1.4105 1.17356V19c0 1.1046.89543 2 2 2h10c1.1046 0 2-.8954 2-2v-8.1714c.6285-.2307 1.0962-.6708 1.4105-1.17356C20.846 8.95817 21 8.13703 21 7.50006c0-.66815-.1687-1.38156-.6238-2.01872-.4567-.63948-1.1475-1.12582-2.06-1.42998-.0177-.00592-.0356-.01133-.0536-.01624-2.4032-.65391-4.3337-1.00971-6.2551-1.0241h-.015Z"></path></svg>`), BreadSliceSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BreadSliceSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BreadSliceSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root94();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_194();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BreadSliceSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_294();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BreadSliceSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BreadSliceSolid = hmr(BreadSliceSolid, () => BreadSliceSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BreadSliceSolid[HMR].source;
    set(BreadSliceSolid[HMR].source, module.default[HMR].original);
  });
}
var BreadSliceSolid_default = BreadSliceSolid;

// node_modules/flowbite-svelte-icons/dist/BriefcaseOutline.svelte
BriefcaseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BriefcaseOutline.svelte";
var root_195 = add_locations(from_svg(`<title> </title>`), BriefcaseOutline[FILENAME], [[43, 4]]);
var root_295 = add_locations(from_svg(`<desc> </desc>`), BriefcaseOutline[FILENAME], [[46, 4]]);
var root95 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 7H5a2 2 0 0 0-2 2v4m5-6h8M8 7V5a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m0 0h3a2 2 0 0 1 2 2v4m0 0v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6m18 0s-4 2-9 2-9-2-9-2m9-2h.01"></path></svg>`), BriefcaseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BriefcaseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BriefcaseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root95();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_195();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BriefcaseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_295();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BriefcaseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BriefcaseOutline = hmr(BriefcaseOutline, () => BriefcaseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BriefcaseOutline[HMR].source;
    set(BriefcaseOutline[HMR].source, module.default[HMR].original);
  });
}
var BriefcaseOutline_default = BriefcaseOutline;

// node_modules/flowbite-svelte-icons/dist/BriefcaseSolid.svelte
BriefcaseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BriefcaseSolid.svelte";
var root_196 = add_locations(from_svg(`<title> </title>`), BriefcaseSolid[FILENAME], [[41, 4]]);
var root_296 = add_locations(from_svg(`<desc> </desc>`), BriefcaseSolid[FILENAME], [[44, 4]]);
var root96 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10 2a3 3 0 0 0-3 3v1H5a3 3 0 0 0-3 3v2.382l1.447.723.005.003.027.013.12.056c.108.05.272.123.486.212.429.177 1.056.416 1.834.655C7.481 13.524 9.63 14 12 14c2.372 0 4.52-.475 6.08-.956.78-.24 1.406-.478 1.835-.655a14.028 14.028 0 0 0 .606-.268l.027-.013.005-.002L22 11.381V9a3 3 0 0 0-3-3h-2V5a3 3 0 0 0-3-3h-4Zm5 4V5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v1h6Zm6.447 7.894.553-.276V19a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3v-5.382l.553.276.002.002.004.002.013.006.041.02.151.07c.13.06.318.144.557.242.478.198 1.163.46 2.01.72C7.019 15.476 9.37 16 12 16c2.628 0 4.98-.525 6.67-1.044a22.95 22.95 0 0 0 2.01-.72 15.994 15.994 0 0 0 .707-.312l.041-.02.013-.006.004-.002.001-.001-.431-.866.432.865ZM12 10a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), BriefcaseSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BriefcaseSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BriefcaseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root96();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_196();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BriefcaseSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_296();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BriefcaseSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BriefcaseSolid = hmr(BriefcaseSolid, () => BriefcaseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BriefcaseSolid[HMR].source;
    set(BriefcaseSolid[HMR].source, module.default[HMR].original);
  });
}
var BriefcaseSolid_default = BriefcaseSolid;

// node_modules/flowbite-svelte-icons/dist/BugOutline.svelte
BugOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BugOutline.svelte";
var root_197 = add_locations(from_svg(`<title> </title>`), BugOutline[FILENAME], [[43, 4]]);
var root_297 = add_locations(from_svg(`<desc> </desc>`), BugOutline[FILENAME], [[46, 4]]);
var root97 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 5 9 4V3m5 2 1-1V3m-3 6v11m0-11a5 5 0 0 1 5 5m-5-5a5 5 0 0 0-5 5m5-5a4.959 4.959 0 0 1 2.973 1H15V8a3 3 0 0 0-6 0v2h.027A4.959 4.959 0 0 1 12 9Zm-5 5H5m2 0v2a5 5 0 0 0 10 0v-2m2.025 0H17m-9.975 4H6a1 1 0 0 0-1 1v2m12-3h1.025a1 1 0 0 1 1 1v2M16 11h1a1 1 0 0 0 1-1V8m-9.975 3H7a1 1 0 0 1-1-1V8"></path></svg>`), BugOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BugOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BugOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root97();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_197();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BugOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_297();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BugOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BugOutline = hmr(BugOutline, () => BugOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BugOutline[HMR].source;
    set(BugOutline[HMR].source, module.default[HMR].original);
  });
}
var BugOutline_default = BugOutline;

// node_modules/flowbite-svelte-icons/dist/BugSolid.svelte
BugSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BugSolid.svelte";
var root_198 = add_locations(from_svg(`<title> </title>`), BugSolid[FILENAME], [[41, 4]]);
var root_298 = add_locations(from_svg(`<desc> </desc>`), BugSolid[FILENAME], [[44, 4]]);
var root98 = add_locations(from_svg(`<svg><!><!><path d="M18 17h-.09c.058-.33.088-.665.09-1v-1h1a1 1 0 0 0 0-2h-1.09a5.97 5.97 0 0 0-.26-1H17a2 2 0 0 0 2-2V8a1 1 0 1 0-2 0v2h-.54a6.239 6.239 0 0 0-.46-.46V8a3.963 3.963 0 0 0-.986-2.6l.693-.693A1 1 0 0 0 16 4V3a1 1 0 1 0-2 0v.586l-.661.661a3.753 3.753 0 0 0-2.678 0L10 3.586V3a1 1 0 1 0-2 0v1a1 1 0 0 0 .293.707l.693.693A3.963 3.963 0 0 0 8 8v1.54a6.239 6.239 0 0 0-.46.46H7V8a1 1 0 0 0-2 0v2a2 2 0 0 0 2 2h-.65a5.97 5.97 0 0 0-.26 1H5a1 1 0 0 0 0 2h1v1a6 6 0 0 0 .09 1H6a2 2 0 0 0-2 2v2a1 1 0 1 0 2 0v-2h.812A6.012 6.012 0 0 0 11 21.907V12a1 1 0 0 1 2 0v9.907A6.011 6.011 0 0 0 17.188 19H18v2a1 1 0 0 0 2 0v-2a2 2 0 0 0-2-2Zm-4-8.65a5.922 5.922 0 0 0-.941-.251l-.111-.017a5.52 5.52 0 0 0-1.9 0l-.111.017A5.925 5.925 0 0 0 10 8.35V8a2 2 0 1 1 4 0v.35Z"></path></svg>`), BugSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BugSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BugSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root98();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_198();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BugSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_298();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BugSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BugSolid = hmr(BugSolid, () => BugSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BugSolid[HMR].source;
    set(BugSolid[HMR].source, module.default[HMR].original);
  });
}
var BugSolid_default = BugSolid;

// node_modules/flowbite-svelte-icons/dist/BuildingOutline.svelte
BuildingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BuildingOutline.svelte";
var root_199 = add_locations(from_svg(`<title> </title>`), BuildingOutline[FILENAME], [[43, 4]]);
var root_299 = add_locations(from_svg(`<desc> </desc>`), BuildingOutline[FILENAME], [[46, 4]]);
var root99 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 4h12M6 4v16M6 4H5m13 0v16m0-16h1m-1 16H6m12 0h1M6 20H5M9 7h1v1H9V7Zm5 0h1v1h-1V7Zm-5 4h1v1H9v-1Zm5 0h1v1h-1v-1Zm-3 4h2a1 1 0 0 1 1 1v4h-4v-4a1 1 0 0 1 1-1Z"></path></svg>`), BuildingOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BuildingOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BuildingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root99();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_199();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BuildingOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_299();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BuildingOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BuildingOutline = hmr(BuildingOutline, () => BuildingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BuildingOutline[HMR].source;
    set(BuildingOutline[HMR].source, module.default[HMR].original);
  });
}
var BuildingOutline_default = BuildingOutline;

// node_modules/flowbite-svelte-icons/dist/BuildingSolid.svelte
BuildingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BuildingSolid.svelte";
var root_1100 = add_locations(from_svg(`<title> </title>`), BuildingSolid[FILENAME], [[41, 4]]);
var root_2100 = add_locations(from_svg(`<desc> </desc>`), BuildingSolid[FILENAME], [[44, 4]]);
var root100 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2v14a1 1 0 1 1 0 2H5a1 1 0 1 1 0-2V5a1 1 0 0 1-1-1Zm5 2a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H9Zm5 0a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1h-1Zm-5 4a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1H9Zm5 0a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1h-1Zm-3 4a2 2 0 0 0-2 2v3h2v-3h2v3h2v-3a2 2 0 0 0-2-2h-2Z" clip-rule="evenodd"></path></svg>`), BuildingSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BuildingSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BuildingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root100();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1100();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BuildingSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2100();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BuildingSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BuildingSolid = hmr(BuildingSolid, () => BuildingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BuildingSolid[HMR].source;
    set(BuildingSolid[HMR].source, module.default[HMR].original);
  });
}
var BuildingSolid_default = BuildingSolid;

// node_modules/flowbite-svelte-icons/dist/BullhornOutline.svelte
BullhornOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BullhornOutline.svelte";
var root_1101 = add_locations(from_svg(`<title> </title>`), BullhornOutline[FILENAME], [[43, 4]]);
var root_2101 = add_locations(from_svg(`<desc> </desc>`), BullhornOutline[FILENAME], [[46, 4]]);
var root101 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 9H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h6m0-6v6m0-6 5.419-3.87A1 1 0 0 1 18 5.942v12.114a1 1 0 0 1-1.581.814L11 15m7 0a3 3 0 0 0 0-6M6 15h3v5H6v-5Z"></path></svg>`), BullhornOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BullhornOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BullhornOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root101();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1101();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BullhornOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2101();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BullhornOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BullhornOutline = hmr(BullhornOutline, () => BullhornOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BullhornOutline[HMR].source;
    set(BullhornOutline[HMR].source, module.default[HMR].original);
  });
}
var BullhornOutline_default = BullhornOutline;

// node_modules/flowbite-svelte-icons/dist/BullhornSolid.svelte
BullhornSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BullhornSolid.svelte";
var root_1102 = add_locations(from_svg(`<title> </title>`), BullhornSolid[FILENAME], [[41, 4]]);
var root_2102 = add_locations(from_svg(`<desc> </desc>`), BullhornSolid[FILENAME], [[44, 4]]);
var root102 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M18.458 3.11A1 1 0 0 1 19 4v16a1 1 0 0 1-1.581.814L12 16.944V7.056l5.419-3.87a1 1 0 0 1 1.039-.076ZM22 12c0 1.48-.804 2.773-2 3.465v-6.93c1.196.692 2 1.984 2 3.465ZM10 8H4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6V8Zm0 9H5v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3Z" clip-rule="evenodd"></path></svg>`), BullhornSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function BullhornSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BullhornSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root102();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1102();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BullhornSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2102();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BullhornSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BullhornSolid = hmr(BullhornSolid, () => BullhornSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BullhornSolid[HMR].source;
    set(BullhornSolid[HMR].source, module.default[HMR].original);
  });
}
var BullhornSolid_default = BullhornSolid;

// node_modules/flowbite-svelte-icons/dist/BurgerOutline.svelte
BurgerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BurgerOutline.svelte";
var root_1103 = add_locations(from_svg(`<title> </title>`), BurgerOutline[FILENAME], [[43, 4]]);
var root_2103 = add_locations(from_svg(`<desc> </desc>`), BurgerOutline[FILENAME], [[46, 4]]);
var root103 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4 12 2.66667-1 2.66666 1L12 11l2.6667 1 2.6666-1L20 12m-1 5H5v1c0 1.1046.89543 2 2 2h10c1.1046 0 2-.8954 2-2v-1ZM5 9.00003h14v-1c0-2.20914-1.7909-4-4-4H9c-2.20914 0-4 1.79086-4 4v1ZM18.5 14h-13c-.82843 0-1.5.6716-1.5 1.5 0 .8285.67157 1.5 1.5 1.5h13c.8284 0 1.5-.6715 1.5-1.5 0-.8284-.6716-1.5-1.5-1.5Z"></path></svg>`), BurgerOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function BurgerOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BurgerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root103();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1103();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BurgerOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2103();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BurgerOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BurgerOutline = hmr(BurgerOutline, () => BurgerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BurgerOutline[HMR].source;
    set(BurgerOutline[HMR].source, module.default[HMR].original);
  });
}
var BurgerOutline_default = BurgerOutline;

// node_modules/flowbite-svelte-icons/dist/BurgerSolid.svelte
BurgerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BurgerSolid.svelte";
var root_1104 = add_locations(from_svg(`<title> </title>`), BurgerSolid[FILENAME], [[41, 4]]);
var root_2104 = add_locations(from_svg(`<desc> </desc>`), BurgerSolid[FILENAME], [[44, 4]]);
var root104 = add_locations(from_svg(`<svg><!><!><path d="M15 3.00009H9.00003c-2.76143 0-5 2.23858-5 5v1c0 .55229.44771 1.00001 1 1.00001H19c.5523 0 1-.44773 1-1.00001v-1c0-2.76142-2.2386-5-5-5Z"></path><path d="m4.35115 12.9364 2.31554-.8683 2.31555.8683c.22638.0849.47586.0849.70224 0L12 12.0681l2.3156.8683c.2264.0849.4758.0849.7022 0l2.3156-.8683 2.3155.8683c.5171.1939 1.0935-.0681 1.2875-.5852.1939-.5171-.0681-1.0935-.5852-1.2874l-2.6667-1c-.2264-.08493-.4759-.08493-.7023 0l-2.3155.8683-2.3155-.8683c-.2264-.08493-.4759-.08493-.7023 0l-2.31554.8683-2.31554-.8683c-.22639-.08493-.47586-.08493-.70225 0l-2.66667 1c-.51712.1939-.77912.7703-.5852 1.2874.19392.5171.77033.7791 1.28745.5852Z"></path><path d="M21 15.5001c0 .8179-.3927 1.5441-1 2.0002v.4998c0 1.6568-1.3431 3-3 3H7.00003c-1.65686 0-3-1.3432-3-3v-.4998c-.60723-.4561-1-1.1823-1-2.0002 0-1.3807 1.11928-2.5 2.5-2.5H18.5c1.3807 0 2.5 1.1193 2.5 2.5Z"></path></svg>`), BurgerSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [52, 2]]]]);
function BurgerSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, BurgerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root104();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1104();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      BurgerSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2104();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      BurgerSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  BurgerSolid = hmr(BurgerSolid, () => BurgerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BurgerSolid[HMR].source;
    set(BurgerSolid[HMR].source, module.default[HMR].original);
  });
}
var BurgerSolid_default = BurgerSolid;

// node_modules/flowbite-svelte-icons/dist/CakeCandlesOutline.svelte
CakeCandlesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CakeCandlesOutline.svelte";
var root_1105 = add_locations(from_svg(`<title> </title>`), CakeCandlesOutline[FILENAME], [[43, 4]]);
var root_2105 = add_locations(from_svg(`<desc> </desc>`), CakeCandlesOutline[FILENAME], [[46, 4]]);
var root105 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 17.4302V15h4.33332M5 17.4302V21h14v-6h-4.3333M5 17.4302c.38672.3365.923.5698 1.66666.5698 2.66664 0 2.66666-3 2.66666-3m5.33338 0H9.33332m5.33338 0s0 3-2.6667 3c-2.66668 0-2.66668-3-2.66668-3m5.33338 0s0 3 2.6666 3c.7437 0 1.28-.2333 1.6667-.5698m-7-9.43017c.1093 0 2-1.11929 2-2.5s-1.9079-2.5-2-2.5c-.0921 0-2 1.11929-2 2.5s1.8947 2.5 2 2.5Zm0 0V11m-6 0v4h12v-4H6Z"></path></svg>`), CakeCandlesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CakeCandlesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CakeCandlesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root105();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1105();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CakeCandlesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2105();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CakeCandlesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CakeCandlesOutline = hmr(CakeCandlesOutline, () => CakeCandlesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CakeCandlesOutline[HMR].source;
    set(CakeCandlesOutline[HMR].source, module.default[HMR].original);
  });
}
var CakeCandlesOutline_default = CakeCandlesOutline;

// node_modules/flowbite-svelte-icons/dist/CakeCandlesSolid.svelte
CakeCandlesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CakeCandlesSolid.svelte";
var root_1106 = add_locations(from_svg(`<title> </title>`), CakeCandlesSolid[FILENAME], [[41, 4]]);
var root_2106 = add_locations(from_svg(`<desc> </desc>`), CakeCandlesSolid[FILENAME], [[44, 4]]);
var root106 = add_locations(from_svg(`<svg><!><!><path d="M11.6643 2.05648c.0197-.00699.1589-.05645.3357-.05645.1768 0 .316.04946.3357.05645l.0019.00067c.0461.01577.0846.03229.1092.04332.0514.02304.1015.04898.1449.07268.0896.04898.1957.11302.3102.18855.2291.15109.521.36725.8121.63689C14.247 3.49218 15 4.37 15 5.50003c0 1.12688-.7447 2.00396-1.2779 2.49995-.2531.23541-.5075.43043-.7221.57742V10h5c.5523 0 1 .4477 1 1v3h-4c-.0568 0-.1125.0048-.1667.0139-.0542-.0091-.1099-.0139-.1667-.0139H5v-3c0-.5523.44772-1 1-1h5V8.57622c-.2139-.14666-.4676-.34115-.7202-.57589C9.74664 7.50489 9 6.62764 9 5.50003c0-1.13003.753-2.00785 1.286-2.50144.2911-.26964.583-.4858.8121-.63689.1145-.07553.2206-.13957.3102-.18855.0434-.0237.0935-.04964.1449-.07268.0246-.01103.0631-.02755.1092-.04332l.0019-.00067ZM4 17.8377V21c0 .5523.44772 1 1 1h14c.5523 0 1-.4477 1-1v-2.8243c-.0609.0534-.1248.1054-.1917.1556-.56.42-1.274.6687-2.1416.6687-.8677 0-1.5817-.2487-2.1417-.6687-.281-.2108-.5081-.4531-.6917-.7045-.1835.2514-.4106.4937-.6917.7045-.5599.42-1.2739.6687-2.1416.6687-.8677 0-1.5817-.2487-2.14169-.6687-.20142-.1511-.37514-.3184-.52499-.4936-.14984.1752-.32356.3425-.52499.4936-.55999.42-1.27398.6687-2.14166.6687s-1.58168-.2487-2.14167-.6687c-.20143-.1511-.37515-.3184-.525-.4936ZM5.2078 16c.0124.0314.0255.0628.03934.0939.11841.2664.27553.4856.47786.6374.19001.1425.47602.2687.94167.2687s.75165-.1262.94166-.2687c.20234-.1518.35945-.371.47786-.6374.01384-.0311.02694-.0625.03934-.0939H5.2078Zm5.3727.0939c-.0139-.0311-.027-.0625-.0394-.0939h2.9177c-.0124.0314-.0255.0628-.0393.0939-.1184.2664-.2755.4856-.4779.6374-.19.1425-.476.2687-.9416.2687-.4657 0-.7517-.1262-.9417-.2687-.2023-.1518-.3594-.371-.4778-.6374Zm5.6666 0c-.0138-.0311-.0269-.0625-.0393-.0939h2.9177c-.0124.0314-.0255.0628-.0393.0939-.1184.2664-.2755.4856-.4779.6374-.19.1425-.476.2687-.9416.2687-.4657 0-.7517-.1262-.9417-.2687-.2023-.1518-.3594-.371-.4779-.6374Z"></path></svg>`), CakeCandlesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CakeCandlesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CakeCandlesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root106();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1106();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CakeCandlesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2106();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CakeCandlesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CakeCandlesSolid = hmr(CakeCandlesSolid, () => CakeCandlesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CakeCandlesSolid[HMR].source;
    set(CakeCandlesSolid[HMR].source, module.default[HMR].original);
  });
}
var CakeCandlesSolid_default = CakeCandlesSolid;

// node_modules/flowbite-svelte-icons/dist/CalendarEditOutline.svelte
CalendarEditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarEditOutline.svelte";
var root_1107 = add_locations(from_svg(`<title> </title>`), CalendarEditOutline[FILENAME], [[43, 4]]);
var root_2107 = add_locations(from_svg(`<desc> </desc>`), CalendarEditOutline[FILENAME], [[46, 4]]);
var root107 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m11.5 11.5 2.071 1.994M4 10h5m11 0h-1.5M12 7V4M7 7V4m10 3V4m-7 13H8v-2l5.227-5.292a1.46 1.46 0 0 1 2.065 2.065L10 17Zm-5 3h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), CalendarEditOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CalendarEditOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarEditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root107();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1107();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarEditOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2107();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarEditOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarEditOutline = hmr(CalendarEditOutline, () => CalendarEditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarEditOutline[HMR].source;
    set(CalendarEditOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarEditOutline_default = CalendarEditOutline;

// node_modules/flowbite-svelte-icons/dist/CalendarEditSolid.svelte
CalendarEditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarEditSolid.svelte";
var root_1108 = add_locations(from_svg(`<title> </title>`), CalendarEditSolid[FILENAME], [[41, 4]]);
var root_2108 = add_locations(from_svg(`<desc> </desc>`), CalendarEditSolid[FILENAME], [[44, 4]]);
var root108 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.512 8.72a2.46 2.46 0 0 1 3.479 0 2.461 2.461 0 0 1 0 3.479l-.004.005-1.094 1.08a.998.998 0 0 0-.194-.272l-3-3a1 1 0 0 0-.272-.193l1.085-1.1Zm-2.415 2.445L7.28 14.017a1 1 0 0 0-.289.702v2a1 1 0 0 0 1 1h2a1 1 0 0 0 .703-.288l2.851-2.816a.995.995 0 0 1-.26-.189l-3-3a.998.998 0 0 1-.19-.26Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M7 3a1 1 0 0 1 1 1v1h3V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h1a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h1V4a1 1 0 0 1 1-1Zm10.67 8H19v8H5v-8h3.855l.53-.537a1 1 0 0 1 .87-.285c.097.015.233.13.277.087.045-.043-.073-.18-.09-.276a1 1 0 0 1 .274-.873l1.09-1.104a3.46 3.46 0 0 1 4.892 0l.001.002A3.461 3.461 0 0 1 17.67 11Z" clip-rule="evenodd"></path></svg>`), CalendarEditSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function CalendarEditSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarEditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root108();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1108();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarEditSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2108();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarEditSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarEditSolid = hmr(CalendarEditSolid, () => CalendarEditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarEditSolid[HMR].source;
    set(CalendarEditSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarEditSolid_default = CalendarEditSolid;

// node_modules/flowbite-svelte-icons/dist/CalendarMonthOutline.svelte
CalendarMonthOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarMonthOutline.svelte";
var root_1109 = add_locations(from_svg(`<title> </title>`), CalendarMonthOutline[FILENAME], [[43, 4]]);
var root_2109 = add_locations(from_svg(`<desc> </desc>`), CalendarMonthOutline[FILENAME], [[46, 4]]);
var root109 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 10h16m-8-3V4M7 7V4m10 3V4M5 20h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Zm3-7h.01v.01H8V13Zm4 0h.01v.01H12V13Zm4 0h.01v.01H16V13Zm-8 4h.01v.01H8V17Zm4 0h.01v.01H12V17Zm4 0h.01v.01H16V17Z"></path></svg>`), CalendarMonthOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CalendarMonthOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarMonthOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root109();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1109();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarMonthOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2109();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarMonthOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarMonthOutline = hmr(CalendarMonthOutline, () => CalendarMonthOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarMonthOutline[HMR].source;
    set(CalendarMonthOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarMonthOutline_default = CalendarMonthOutline;

// node_modules/flowbite-svelte-icons/dist/CalendarMonthSolid.svelte
CalendarMonthSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarMonthSolid.svelte";
var root_1110 = add_locations(from_svg(`<title> </title>`), CalendarMonthSolid[FILENAME], [[41, 4]]);
var root_2110 = add_locations(from_svg(`<desc> </desc>`), CalendarMonthSolid[FILENAME], [[44, 4]]);
var root110 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 5a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1h1a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1h1a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1 2 2 0 0 1 2 2v1a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a2 2 0 0 1 2-2ZM3 19v-7a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm6.01-6a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm2 0a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm6 0a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm-10 4a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm6 0a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm2 0a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z" clip-rule="evenodd"></path></svg>`), CalendarMonthSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarMonthSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarMonthSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root110();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1110();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarMonthSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2110();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarMonthSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarMonthSolid = hmr(CalendarMonthSolid, () => CalendarMonthSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarMonthSolid[HMR].source;
    set(CalendarMonthSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarMonthSolid_default = CalendarMonthSolid;

// node_modules/flowbite-svelte-icons/dist/CalendarPlusOutline.svelte
CalendarPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarPlusOutline.svelte";
var root_1111 = add_locations(from_svg(`<title> </title>`), CalendarPlusOutline[FILENAME], [[42, 4]]);
var root_2111 = add_locations(from_svg(`<desc> </desc>`), CalendarPlusOutline[FILENAME], [[45, 4]]);
var root111 = add_locations(from_svg(`<svg><!><!><path d="M4 9.05H3v2h1v-2Zm16 2h1v-2h-1v2ZM10 14a1 1 0 1 0 0 2v-2Zm4 2a1 1 0 1 0 0-2v2Zm-3 1a1 1 0 1 0 2 0h-2Zm2-4a1 1 0 1 0-2 0h2Zm-2-5.95a1 1 0 1 0 2 0h-2Zm2-3a1 1 0 1 0-2 0h2Zm-7 3a1 1 0 0 0 2 0H6Zm2-3a1 1 0 1 0-2 0h2Zm8 3a1 1 0 1 0 2 0h-2Zm2-3a1 1 0 1 0-2 0h2Zm-13 3h14v-2H5v2Zm14 0v12h2v-12h-2Zm0 12H5v2h14v-2Zm-14 0v-12H3v12h2Zm0 0H3a2 2 0 0 0 2 2v-2Zm14 0v2a2 2 0 0 0 2-2h-2Zm0-12h2a2 2 0 0 0-2-2v2Zm-14-2a2 2 0 0 0-2 2h2v-2Zm-1 6h16v-2H4v2ZM10 16h4v-2h-4v2Zm3 1v-4h-2v4h2Zm0-9.95v-3h-2v3h2Zm-5 0v-3H6v3h2Zm10 0v-3h-2v3h2Z"></path></svg>`), CalendarPlusOutline[FILENAME], [[30, 0, [[47, 2]]]]);
function CalendarPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root111();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1111();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarPlusOutline,
      41,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2111();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarPlusOutline,
      44,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarPlusOutline = hmr(CalendarPlusOutline, () => CalendarPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarPlusOutline[HMR].source;
    set(CalendarPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarPlusOutline_default = CalendarPlusOutline;

// node_modules/flowbite-svelte-icons/dist/CalendarPlusSolid.svelte
CalendarPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarPlusSolid.svelte";
var root_1112 = add_locations(from_svg(`<title> </title>`), CalendarPlusSolid[FILENAME], [[41, 4]]);
var root_2112 = add_locations(from_svg(`<desc> </desc>`), CalendarPlusSolid[FILENAME], [[44, 4]]);
var root112 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M18 5.05h1a2 2 0 0 1 2 2v2H3v-2a2 2 0 0 1 2-2h1v-1a1 1 0 1 1 2 0v1h3v-1a1 1 0 1 1 2 0v1h3v-1a1 1 0 1 1 2 0v1Zm-15 6v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-8H3ZM11 18a1 1 0 1 0 2 0v-1h1a1 1 0 1 0 0-2h-1v-1a1 1 0 1 0-2 0v1h-1a1 1 0 1 0 0 2h1v1Z" clip-rule="evenodd"></path></svg>`), CalendarPlusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root112();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1112();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2112();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarPlusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarPlusSolid = hmr(CalendarPlusSolid, () => CalendarPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarPlusSolid[HMR].source;
    set(CalendarPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarPlusSolid_default = CalendarPlusSolid;

// node_modules/flowbite-svelte-icons/dist/CalendarWeekOutline.svelte
CalendarWeekOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarWeekOutline.svelte";
var root_1113 = add_locations(from_svg(`<title> </title>`), CalendarWeekOutline[FILENAME], [[43, 4]]);
var root_2113 = add_locations(from_svg(`<desc> </desc>`), CalendarWeekOutline[FILENAME], [[46, 4]]);
var root113 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 10h16M8 14h8m-4-7V4M7 7V4m10 3V4M5 20h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), CalendarWeekOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CalendarWeekOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarWeekOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root113();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1113();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarWeekOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2113();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarWeekOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarWeekOutline = hmr(CalendarWeekOutline, () => CalendarWeekOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarWeekOutline[HMR].source;
    set(CalendarWeekOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarWeekOutline_default = CalendarWeekOutline;

// node_modules/flowbite-svelte-icons/dist/CalendarWeekSolid.svelte
CalendarWeekSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarWeekSolid.svelte";
var root_1114 = add_locations(from_svg(`<title> </title>`), CalendarWeekSolid[FILENAME], [[41, 4]]);
var root_2114 = add_locations(from_svg(`<desc> </desc>`), CalendarWeekSolid[FILENAME], [[44, 4]]);
var root114 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 5V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h1a2 2 0 0 1 2 2v2H3V7a2 2 0 0 1 2-2h1ZM3 19v-8h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm5-6a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Z" clip-rule="evenodd"></path></svg>`), CalendarWeekSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarWeekSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CalendarWeekSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root114();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1114();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CalendarWeekSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2114();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CalendarWeekSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CalendarWeekSolid = hmr(CalendarWeekSolid, () => CalendarWeekSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarWeekSolid[HMR].source;
    set(CalendarWeekSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarWeekSolid_default = CalendarWeekSolid;

// node_modules/flowbite-svelte-icons/dist/CameraPhotoOutline.svelte
CameraPhotoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CameraPhotoOutline.svelte";
var root_1115 = add_locations(from_svg(`<title> </title>`), CameraPhotoOutline[FILENAME], [[43, 4]]);
var root_2115 = add_locations(from_svg(`<desc> </desc>`), CameraPhotoOutline[FILENAME], [[46, 4]]);
var root115 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 18V8a1 1 0 0 1 1-1h1.5l1.707-1.707A1 1 0 0 1 8.914 5h6.172a1 1 0 0 1 .707.293L17.5 7H19a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), CameraPhotoOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function CameraPhotoOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CameraPhotoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root115();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1115();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CameraPhotoOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2115();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CameraPhotoOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CameraPhotoOutline = hmr(CameraPhotoOutline, () => CameraPhotoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CameraPhotoOutline[HMR].source;
    set(CameraPhotoOutline[HMR].source, module.default[HMR].original);
  });
}
var CameraPhotoOutline_default = CameraPhotoOutline;

// node_modules/flowbite-svelte-icons/dist/CameraPhotoSolid.svelte
CameraPhotoSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CameraPhotoSolid.svelte";
var root_1116 = add_locations(from_svg(`<title> </title>`), CameraPhotoSolid[FILENAME], [[41, 4]]);
var root_2116 = add_locations(from_svg(`<desc> </desc>`), CameraPhotoSolid[FILENAME], [[44, 4]]);
var root116 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7.5 4.586A2 2 0 0 1 8.914 4h6.172a2 2 0 0 1 1.414.586L17.914 6H19a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h1.086L7.5 4.586ZM10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z" clip-rule="evenodd"></path></svg>`), CameraPhotoSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CameraPhotoSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CameraPhotoSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root116();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1116();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CameraPhotoSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2116();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CameraPhotoSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CameraPhotoSolid = hmr(CameraPhotoSolid, () => CameraPhotoSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CameraPhotoSolid[HMR].source;
    set(CameraPhotoSolid[HMR].source, module.default[HMR].original);
  });
}
var CameraPhotoSolid_default = CameraPhotoSolid;

// node_modules/flowbite-svelte-icons/dist/CandyCaneOutline.svelte
CandyCaneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CandyCaneOutline.svelte";
var root_1117 = add_locations(from_svg(`<title> </title>`), CandyCaneOutline[FILENAME], [[43, 4]]);
var root_2117 = add_locations(from_svg(`<desc> </desc>`), CandyCaneOutline[FILENAME], [[46, 4]]);
var root117 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 8.00003c0-.82843.5-2 2-2m-2 2V10.5c0 .8285-.67157 1.5-1.5 1.5S7 11.3285 7 10.5V7.50003m3 .5-3-.5m5-1.5c1.5 0 2 1.17157 2 2m-2-2v-3m-5 4.5c0-2.48528 2.51472-4.5 5-4.5m0 0c2.4853 0 5 2.01472 5 4.5V19.5c0 .8285-.6716 1.5-1.5 1.5s-1.5-.6715-1.5-1.5V8.00003m0 0h3M14 12h3m-3 4h3"></path></svg>`), CandyCaneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CandyCaneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CandyCaneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root117();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1117();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CandyCaneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2117();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CandyCaneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CandyCaneOutline = hmr(CandyCaneOutline, () => CandyCaneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CandyCaneOutline[HMR].source;
    set(CandyCaneOutline[HMR].source, module.default[HMR].original);
  });
}
var CandyCaneOutline_default = CandyCaneOutline;

// node_modules/flowbite-svelte-icons/dist/CandyCaneSolid.svelte
CandyCaneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CandyCaneSolid.svelte";
var root_1118 = add_locations(from_svg(`<title> </title>`), CandyCaneSolid[FILENAME], [[41, 4]]);
var root_2118 = add_locations(from_svg(`<desc> </desc>`), CandyCaneSolid[FILENAME], [[44, 4]]);
var root118 = add_locations(from_svg(`<svg><!><!><path d="m11 9.16318-5-.8017V10.5C6 11.8807 7.11929 13 8.5 13s2.5-1.1193 2.5-2.5V9.16318ZM6.1404 6.35844 11 7.13764V2.08771c-1.14494.19988-2.22828.73028-3.08702 1.47474-.83378.72283-1.49585 1.68517-1.77258 2.79599ZM13 2.08771v4.91232h4.9734c-.1477-1.38214-.8959-2.57887-1.8864-3.43758-.8587-.74446-1.9421-1.27485-3.087-1.47474Zm5 6.91232h-5V11h5V9.00003ZM18 13h-5v2h5v-2Zm0 4h-5v2.5c0 1.3807 1.1193 2.5 2.5 2.5s2.5-1.1193 2.5-2.5V17Z"></path></svg>`), CandyCaneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CandyCaneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CandyCaneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root118();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1118();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CandyCaneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2118();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CandyCaneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CandyCaneSolid = hmr(CandyCaneSolid, () => CandyCaneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CandyCaneSolid[HMR].source;
    set(CandyCaneSolid[HMR].source, module.default[HMR].original);
  });
}
var CandyCaneSolid_default = CandyCaneSolid;

// node_modules/flowbite-svelte-icons/dist/CaptionOutline.svelte
CaptionOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaptionOutline.svelte";
var root_1119 = add_locations(from_svg(`<title> </title>`), CaptionOutline[FILENAME], [[43, 4]]);
var root_2119 = add_locations(from_svg(`<desc> </desc>`), CaptionOutline[FILENAME], [[46, 4]]);
var root119 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.855 14.322a2.475 2.475 0 1 1 .133-4.241m6.053 4.241a2.475 2.475 0 1 1 .133-4.241M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), CaptionOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaptionOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaptionOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root119();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1119();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaptionOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2119();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaptionOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaptionOutline = hmr(CaptionOutline, () => CaptionOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaptionOutline[HMR].source;
    set(CaptionOutline[HMR].source, module.default[HMR].original);
  });
}
var CaptionOutline_default = CaptionOutline;

// node_modules/flowbite-svelte-icons/dist/CaptionSolid.svelte
CaptionSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaptionSolid.svelte";
var root_1120 = add_locations(from_svg(`<title> </title>`), CaptionSolid[FILENAME], [[41, 4]]);
var root_2120 = add_locations(from_svg(`<desc> </desc>`), CaptionSolid[FILENAME], [[44, 4]]);
var root120 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm6.962 4.856a1.475 1.475 0 0 1 1.484.066A1 1 0 1 0 11.53 9.24a3.475 3.475 0 1 0-.187 5.955 1 1 0 1 0-.976-1.746 1.474 1.474 0 1 1-1.405-2.593Zm6.186 0a1.475 1.475 0 0 1 1.484.066 1 1 0 1 0 1.084-1.682 3.475 3.475 0 1 0-.187 5.955 1 1 0 1 0-.976-1.746 1.474 1.474 0 1 1-1.405-2.593Z" clip-rule="evenodd"></path></svg>`), CaptionSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaptionSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaptionSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root120();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1120();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaptionSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2120();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaptionSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaptionSolid = hmr(CaptionSolid, () => CaptionSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaptionSolid[HMR].source;
    set(CaptionSolid[HMR].source, module.default[HMR].original);
  });
}
var CaptionSolid_default = CaptionSolid;

// node_modules/flowbite-svelte-icons/dist/CaretDownOutline.svelte
CaretDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretDownOutline.svelte";
var root_1121 = add_locations(from_svg(`<title> </title>`), CaretDownOutline[FILENAME], [[43, 4]]);
var root_2121 = add_locations(from_svg(`<desc> </desc>`), CaretDownOutline[FILENAME], [[46, 4]]);
var root121 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.119 8h9.762a1 1 0 0 1 .772 1.636l-4.881 5.927a1 1 0 0 1-1.544 0l-4.88-5.927A1 1 0 0 1 7.118 8Z"></path></svg>`), CaretDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaretDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root121();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1121();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2121();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretDownOutline = hmr(CaretDownOutline, () => CaretDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretDownOutline[HMR].source;
    set(CaretDownOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretDownOutline_default = CaretDownOutline;

// node_modules/flowbite-svelte-icons/dist/CaretDownSolid.svelte
CaretDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretDownSolid.svelte";
var root_1122 = add_locations(from_svg(`<title> </title>`), CaretDownSolid[FILENAME], [[41, 4]]);
var root_2122 = add_locations(from_svg(`<desc> </desc>`), CaretDownSolid[FILENAME], [[44, 4]]);
var root122 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M18.425 10.271C19.499 8.967 18.57 7 16.88 7H7.12c-1.69 0-2.618 1.967-1.544 3.271l4.881 5.927a2 2 0 0 0 3.088 0l4.88-5.927Z" clip-rule="evenodd"></path></svg>`), CaretDownSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretDownSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root122();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1122();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretDownSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2122();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretDownSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretDownSolid = hmr(CaretDownSolid, () => CaretDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretDownSolid[HMR].source;
    set(CaretDownSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretDownSolid_default = CaretDownSolid;

// node_modules/flowbite-svelte-icons/dist/CaretLeftOutline.svelte
CaretLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretLeftOutline.svelte";
var root_1123 = add_locations(from_svg(`<title> </title>`), CaretLeftOutline[FILENAME], [[43, 4]]);
var root_2123 = add_locations(from_svg(`<desc> </desc>`), CaretLeftOutline[FILENAME], [[46, 4]]);
var root123 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 16.881V7.119a1 1 0 0 0-1.636-.772l-5.927 4.881a1 1 0 0 0 0 1.544l5.927 4.88a1 1 0 0 0 1.636-.77Z"></path></svg>`), CaretLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaretLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root123();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1123();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2123();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretLeftOutline = hmr(CaretLeftOutline, () => CaretLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretLeftOutline[HMR].source;
    set(CaretLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretLeftOutline_default = CaretLeftOutline;

// node_modules/flowbite-svelte-icons/dist/CaretLeftSolid.svelte
CaretLeftSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretLeftSolid.svelte";
var root_1124 = add_locations(from_svg(`<title> </title>`), CaretLeftSolid[FILENAME], [[41, 4]]);
var root_2124 = add_locations(from_svg(`<desc> </desc>`), CaretLeftSolid[FILENAME], [[44, 4]]);
var root124 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13.729 5.575c1.304-1.074 3.27-.146 3.27 1.544v9.762c0 1.69-1.966 2.618-3.27 1.544l-5.927-4.881a2 2 0 0 1 0-3.088l5.927-4.88Z" clip-rule="evenodd"></path></svg>`), CaretLeftSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretLeftSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretLeftSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root124();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1124();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretLeftSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2124();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretLeftSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretLeftSolid = hmr(CaretLeftSolid, () => CaretLeftSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretLeftSolid[HMR].source;
    set(CaretLeftSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretLeftSolid_default = CaretLeftSolid;

// node_modules/flowbite-svelte-icons/dist/CaretRightOutline.svelte
CaretRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretRightOutline.svelte";
var root_1125 = add_locations(from_svg(`<title> </title>`), CaretRightOutline[FILENAME], [[43, 4]]);
var root_2125 = add_locations(from_svg(`<desc> </desc>`), CaretRightOutline[FILENAME], [[46, 4]]);
var root125 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 16.881V7.119a1 1 0 0 1 1.636-.772l5.927 4.881a1 1 0 0 1 0 1.544l-5.927 4.88A1 1 0 0 1 8 16.882Z"></path></svg>`), CaretRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaretRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root125();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1125();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2125();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretRightOutline = hmr(CaretRightOutline, () => CaretRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretRightOutline[HMR].source;
    set(CaretRightOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretRightOutline_default = CaretRightOutline;

// node_modules/flowbite-svelte-icons/dist/CaretRightSolid.svelte
CaretRightSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretRightSolid.svelte";
var root_1126 = add_locations(from_svg(`<title> </title>`), CaretRightSolid[FILENAME], [[41, 4]]);
var root_2126 = add_locations(from_svg(`<desc> </desc>`), CaretRightSolid[FILENAME], [[44, 4]]);
var root126 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10.271 5.575C8.967 4.501 7 5.43 7 7.12v9.762c0 1.69 1.967 2.618 3.271 1.544l5.927-4.881a2 2 0 0 0 0-3.088l-5.927-4.88Z" clip-rule="evenodd"></path></svg>`), CaretRightSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretRightSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretRightSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root126();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1126();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretRightSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2126();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretRightSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretRightSolid = hmr(CaretRightSolid, () => CaretRightSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretRightSolid[HMR].source;
    set(CaretRightSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretRightSolid_default = CaretRightSolid;

// node_modules/flowbite-svelte-icons/dist/CaretSortOutline.svelte
CaretSortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretSortOutline.svelte";
var root_1127 = add_locations(from_svg(`<title> </title>`), CaretSortOutline[FILENAME], [[43, 4]]);
var root_2127 = add_locations(from_svg(`<desc> </desc>`), CaretSortOutline[FILENAME], [[46, 4]]);
var root127 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 10 4-6 4 6H8Zm8 4-4 6-4-6h8Z"></path></svg>`), CaretSortOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaretSortOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretSortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root127();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1127();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretSortOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2127();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretSortOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretSortOutline = hmr(CaretSortOutline, () => CaretSortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretSortOutline[HMR].source;
    set(CaretSortOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretSortOutline_default = CaretSortOutline;

// node_modules/flowbite-svelte-icons/dist/CaretSortSolid.svelte
CaretSortSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretSortSolid.svelte";
var root_1128 = add_locations(from_svg(`<title> </title>`), CaretSortSolid[FILENAME], [[41, 4]]);
var root_2128 = add_locations(from_svg(`<desc> </desc>`), CaretSortSolid[FILENAME], [[44, 4]]);
var root128 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.832 3.445a1 1 0 0 0-1.664 0l-4 6A1 1 0 0 0 8 11h8a1 1 0 0 0 .832-1.555l-4-6Zm-1.664 17.11a1 1 0 0 0 1.664 0l4-6A1 1 0 0 0 16 13H8a1 1 0 0 0-.832 1.555l4 6Z" clip-rule="evenodd"></path></svg>`), CaretSortSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretSortSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretSortSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root128();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1128();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretSortSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2128();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretSortSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretSortSolid = hmr(CaretSortSolid, () => CaretSortSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretSortSolid[HMR].source;
    set(CaretSortSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretSortSolid_default = CaretSortSolid;

// node_modules/flowbite-svelte-icons/dist/CaretUpOutline.svelte
CaretUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretUpOutline.svelte";
var root_1129 = add_locations(from_svg(`<title> </title>`), CaretUpOutline[FILENAME], [[43, 4]]);
var root_2129 = add_locations(from_svg(`<desc> </desc>`), CaretUpOutline[FILENAME], [[46, 4]]);
var root129 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.881 16H7.119a1 1 0 0 1-.772-1.636l4.881-5.927a1 1 0 0 1 1.544 0l4.88 5.927a1 1 0 0 1-.77 1.636Z"></path></svg>`), CaretUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CaretUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root129();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1129();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2129();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretUpOutline = hmr(CaretUpOutline, () => CaretUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretUpOutline[HMR].source;
    set(CaretUpOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretUpOutline_default = CaretUpOutline;

// node_modules/flowbite-svelte-icons/dist/CaretUpSolid.svelte
CaretUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretUpSolid.svelte";
var root_1130 = add_locations(from_svg(`<title> </title>`), CaretUpSolid[FILENAME], [[41, 4]]);
var root_2130 = add_locations(from_svg(`<desc> </desc>`), CaretUpSolid[FILENAME], [[44, 4]]);
var root130 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.575 13.729C4.501 15.033 5.43 17 7.12 17h9.762c1.69 0 2.618-1.967 1.544-3.271l-4.881-5.927a2 2 0 0 0-3.088 0l-4.88 5.927Z" clip-rule="evenodd"></path></svg>`), CaretUpSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretUpSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CaretUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root130();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1130();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CaretUpSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2130();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CaretUpSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CaretUpSolid = hmr(CaretUpSolid, () => CaretUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretUpSolid[HMR].source;
    set(CaretUpSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretUpSolid_default = CaretUpSolid;

// node_modules/flowbite-svelte-icons/dist/CarrotOutline.svelte
CarrotOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CarrotOutline.svelte";
var root_1131 = add_locations(from_svg(`<title> </title>`), CarrotOutline[FILENAME], [[43, 4]]);
var root_2131 = add_locations(from_svg(`<desc> </desc>`), CarrotOutline[FILENAME], [[46, 4]]);
var root131 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="M16.0001 7.99997c-1.629-1.629-3.9007-1.91488-6.06614.25057C7.76851 10.416 2.82151 18.0286 4.4505 19.6576c1.629 1.629 9.2416-3.318 11.4071-5.4834 2.0932-2.0933 1.7715-4.54524.1425-6.17423Zm0 0 3.2595-3.15144m-3.2595 3.15144V4m0 3.99997 4 .00002m-3.7978 5.80211-2.1999-2.2155M8.30216 10.211l2.07194 2.0421m-1.25873 3.1838 2.11173 2.1633"></path></svg>`), CarrotOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CarrotOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CarrotOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root131();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1131();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CarrotOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2131();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CarrotOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CarrotOutline = hmr(CarrotOutline, () => CarrotOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarrotOutline[HMR].source;
    set(CarrotOutline[HMR].source, module.default[HMR].original);
  });
}
var CarrotOutline_default = CarrotOutline;

// node_modules/flowbite-svelte-icons/dist/CarrotSolid.svelte
CarrotSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CarrotSolid.svelte";
var root_1132 = add_locations(from_svg(`<title> </title>`), CarrotSolid[FILENAME], [[41, 4]]);
var root_2132 = add_locations(from_svg(`<desc> </desc>`), CarrotSolid[FILENAME], [[44, 4]]);
var root132 = add_locations(from_svg(`<svg><!><!><path d="M16.0001 3c.5522 0 1 .44772 1 1v1.64215l1.5644-1.51254c.397-.38389 1.0301-.37322 1.414.02383.3839.39705.3732 1.03013-.0239 1.41401L18.473 6.99998l1.5271.00001c.5522 0 1 .44772.9999 1 0 .55229-.4477 1-1 1l-2.1048-.00001c.263.59002.4154 1.22712.4292 1.89222.0195.9368-.2372 1.8739-.7777 2.7561l-2.8459-2.7774c-.3952-.3857-1.0284-.378-1.4141.0173-.3857.3952-.378 1.0283.0172 1.4141l2.9486 2.8774c-.8296.7625-2.1057 1.7284-3.5125 2.6476-.0039-.0043-.0079-.0086-.0119-.0129l-2.88472-3.0631c-.37864-.402-1.01152-.421-1.41358-.0424-.40206.3787-.42104 1.0115-.0424 1.4136l2.6129 2.7745c-.189.1089-.3781.2152-.5666.3186-1.21703.6674-2.4674 1.2427-3.553 1.5412-.54097.1487-1.09271.2436-1.60567.2207-.51242-.0228-1.08874-.1699-1.53164-.6128-.44291-.4429-.58999-1.0192-.61281-1.5316-.02284-.513.07199-1.0647.22074-1.6057.29851-1.0856.87376-2.336 1.54118-3.553.62156-1.1334 1.35187-2.2891 2.07312-3.3185l2.71447 2.617c.39761.3834 1.03061.3718 1.41401-.0258.3833-.3976.3717-1.0306-.0259-1.414L8.17235 8.74115c.3837-.47727.7425-.88572 1.05449-1.19772 1.22356-1.22358 2.57606-1.84689 3.94556-1.84108.6464.00273 1.2596.1455 1.8277.39684V4c0-.55228.4477-1 1-1Z"></path></svg>`), CarrotSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CarrotSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CarrotSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root132();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1132();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CarrotSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2132();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CarrotSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CarrotSolid = hmr(CarrotSolid, () => CarrotSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarrotSolid[HMR].source;
    set(CarrotSolid[HMR].source, module.default[HMR].original);
  });
}
var CarrotSolid_default = CarrotSolid;

// node_modules/flowbite-svelte-icons/dist/CartOutline.svelte
CartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartOutline.svelte";
var root_1133 = add_locations(from_svg(`<title> </title>`), CartOutline[FILENAME], [[43, 4]]);
var root_2133 = add_locations(from_svg(`<desc> </desc>`), CartOutline[FILENAME], [[46, 4]]);
var root133 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 4h1.5L9 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-8.5-3h9.25L19 7H7.312"></path></svg>`), CartOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CartOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root133();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1133();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2133();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartOutline = hmr(CartOutline, () => CartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartOutline[HMR].source;
    set(CartOutline[HMR].source, module.default[HMR].original);
  });
}
var CartOutline_default = CartOutline;

// node_modules/flowbite-svelte-icons/dist/CartPlusAltOutline.svelte
CartPlusAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusAltOutline.svelte";
var root_1134 = add_locations(from_svg(`<title> </title>`), CartPlusAltOutline[FILENAME], [[43, 4]]);
var root_2134 = add_locations(from_svg(`<desc> </desc>`), CartPlusAltOutline[FILENAME], [[46, 4]]);
var root134 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4h1.5L8 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm.75-3H7.5M11 7H6.312M17 4v6m-3-3h6"></path></svg>`), CartPlusAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CartPlusAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartPlusAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root134();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1134();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartPlusAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2134();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartPlusAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartPlusAltOutline = hmr(CartPlusAltOutline, () => CartPlusAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusAltOutline[HMR].source;
    set(CartPlusAltOutline[HMR].source, module.default[HMR].original);
  });
}
var CartPlusAltOutline_default = CartPlusAltOutline;

// node_modules/flowbite-svelte-icons/dist/CartPlusAltSolid.svelte
CartPlusAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusAltSolid.svelte";
var root_1135 = add_locations(from_svg(`<title> </title>`), CartPlusAltSolid[FILENAME], [[41, 4]]);
var root_2135 = add_locations(from_svg(`<desc> </desc>`), CartPlusAltSolid[FILENAME], [[44, 4]]);
var root135 = add_locations(from_svg(`<svg><!><!><path d="M12.268 6A2 2 0 0 0 14 9h1v1a2 2 0 0 0 3.04 1.708l-.311 1.496a1 1 0 0 1-.979.796H8.605l.208 1H16a3 3 0 1 1-2.83 2h-2.34a3 3 0 1 1-4.009-1.76L4.686 5H4a1 1 0 0 1 0-2h1.5a1 1 0 0 1 .979.796L6.939 6h5.329Z"></path><path d="M18 4a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0V8h2a1 1 0 1 0 0-2h-2V4Z"></path></svg>`), CartPlusAltSolid[FILENAME], [[30, 0, [[46, 2], [48, 5]]]]);
function CartPlusAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartPlusAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root135();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1135();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartPlusAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2135();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartPlusAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartPlusAltSolid = hmr(CartPlusAltSolid, () => CartPlusAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusAltSolid[HMR].source;
    set(CartPlusAltSolid[HMR].source, module.default[HMR].original);
  });
}
var CartPlusAltSolid_default = CartPlusAltSolid;

// node_modules/flowbite-svelte-icons/dist/CartPlusOutline.svelte
CartPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusOutline.svelte";
var root_1136 = add_locations(from_svg(`<title> </title>`), CartPlusOutline[FILENAME], [[43, 4]]);
var root_2136 = add_locations(from_svg(`<desc> </desc>`), CartPlusOutline[FILENAME], [[46, 4]]);
var root136 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 4h1.5L9 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-8.5-3h9.25L19 7h-1M8 7h-.688M13 5v4m-2-2h4"></path></svg>`), CartPlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CartPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root136();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1136();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartPlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2136();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartPlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartPlusOutline = hmr(CartPlusOutline, () => CartPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusOutline[HMR].source;
    set(CartPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CartPlusOutline_default = CartPlusOutline;

// node_modules/flowbite-svelte-icons/dist/CartPlusSolid.svelte
CartPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusSolid.svelte";
var root_1137 = add_locations(from_svg(`<title> </title>`), CartPlusSolid[FILENAME], [[41, 4]]);
var root_2137 = add_locations(from_svg(`<desc> </desc>`), CartPlusSolid[FILENAME], [[44, 4]]);
var root137 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a1 1 0 0 0 0 2h.687L7.82 15.24A3 3 0 1 0 11.83 17h2.34A3 3 0 1 0 17 15H9.813l-.208-1h8.145a1 1 0 0 0 .979-.796l1.25-6A1 1 0 0 0 19 6h-2.268A2 2 0 0 1 15 9a2 2 0 1 1-4 0 2 2 0 0 1-1.732-3h-1.33L7.48 3.796A1 1 0 0 0 6.5 3H5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 5a1 1 0 1 0-2 0v1h-1a1 1 0 1 0 0 2h1v1a1 1 0 1 0 2 0V8h1a1 1 0 1 0 0-2h-1V5Z" clip-rule="evenodd"></path></svg>`), CartPlusSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function CartPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root137();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1137();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2137();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartPlusSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartPlusSolid = hmr(CartPlusSolid, () => CartPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusSolid[HMR].source;
    set(CartPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CartPlusSolid_default = CartPlusSolid;

// node_modules/flowbite-svelte-icons/dist/CartSolid.svelte
CartSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartSolid.svelte";
var root_1138 = add_locations(from_svg(`<title> </title>`), CartSolid[FILENAME], [[41, 4]]);
var root_2138 = add_locations(from_svg(`<desc> </desc>`), CartSolid[FILENAME], [[44, 4]]);
var root138 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a1 1 0 0 1 1-1h1.5a1 1 0 0 1 .979.796L7.939 6H19a1 1 0 0 1 .979 1.204l-1.25 6a1 1 0 0 1-.979.796H9.605l.208 1H17a3 3 0 1 1-2.83 2h-2.34a3 3 0 1 1-4.009-1.76L5.686 5H5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CartSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CartSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CartSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root138();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1138();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CartSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2138();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CartSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CartSolid = hmr(CartSolid, () => CartSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartSolid[HMR].source;
    set(CartSolid[HMR].source, module.default[HMR].original);
  });
}
var CartSolid_default = CartSolid;

// node_modules/flowbite-svelte-icons/dist/CashOutline.svelte
CashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashOutline.svelte";
var root_1139 = add_locations(from_svg(`<title> </title>`), CashOutline[FILENAME], [[43, 4]]);
var root_2139 = add_locations(from_svg(`<desc> </desc>`), CashOutline[FILENAME], [[46, 4]]);
var root139 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M8 7V6a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-1M3 18v-7a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm8-3.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z"></path></svg>`), CashOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CashOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root139();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1139();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CashOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2139();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CashOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CashOutline = hmr(CashOutline, () => CashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashOutline[HMR].source;
    set(CashOutline[HMR].source, module.default[HMR].original);
  });
}
var CashOutline_default = CashOutline;

// node_modules/flowbite-svelte-icons/dist/CashRegisterOutline.svelte
CashRegisterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashRegisterOutline.svelte";
var root_1140 = add_locations(from_svg(`<title> </title>`), CashRegisterOutline[FILENAME], [[43, 4]]);
var root_2140 = add_locations(from_svg(`<desc> </desc>`), CashRegisterOutline[FILENAME], [[46, 4]]);
var root140 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 18h14M5 18v3h14v-3M5 18l1-9h12l1 9M16 6v3m-4-3v3m-2-6h8v3h-8V3Zm-1 9h.01v.01H9V12Zm3 0h.01v.01H12V12Zm3 0h.01v.01H15V12Zm-6 3h.01v.01H9V15Zm3 0h.01v.01H12V15Zm3 0h.01v.01H15V15Z"></path></svg>`), CashRegisterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CashRegisterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CashRegisterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root140();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1140();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CashRegisterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2140();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CashRegisterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CashRegisterOutline = hmr(CashRegisterOutline, () => CashRegisterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashRegisterOutline[HMR].source;
    set(CashRegisterOutline[HMR].source, module.default[HMR].original);
  });
}
var CashRegisterOutline_default = CashRegisterOutline;

// node_modules/flowbite-svelte-icons/dist/CashRegisterSolid.svelte
CashRegisterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashRegisterSolid.svelte";
var root_1141 = add_locations(from_svg(`<title> </title>`), CashRegisterSolid[FILENAME], [[41, 4]]);
var root_2141 = add_locations(from_svg(`<desc> </desc>`), CashRegisterSolid[FILENAME], [[44, 4]]);
var root141 = add_locations(from_svg(`<svg><!><!><path d="M4 19v2c0 .5523.44772 1 1 1h14c.5523 0 1-.4477 1-1v-2H4Z"></path><path fill-rule="evenodd" d="M9 3c0-.55228.44772-1 1-1h8c.5523 0 1 .44772 1 1v3c0 .55228-.4477 1-1 1h-2v1h2c.5096 0 .9376.38314.9939.88957L19.8951 17H4.10498l.90116-8.11043C5.06241 8.38314 5.49047 8 6.00002 8H12V7h-2c-.55228 0-1-.44772-1-1V3Zm1.01 8H8.00002v2.01H10.01V11Zm.99 0h2.01v2.01H11V11Zm5.01 0H14v2.01h2.01V11Zm-8.00998 3H10.01v2.01H8.00002V14ZM13.01 14H11v2.01h2.01V14Zm.99 0h2.01v2.01H14V14ZM11 4h6v1h-6V4Z" clip-rule="evenodd"></path></svg>`), CashRegisterSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function CashRegisterSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CashRegisterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root141();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1141();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CashRegisterSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2141();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CashRegisterSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CashRegisterSolid = hmr(CashRegisterSolid, () => CashRegisterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashRegisterSolid[HMR].source;
    set(CashRegisterSolid[HMR].source, module.default[HMR].original);
  });
}
var CashRegisterSolid_default = CashRegisterSolid;

// node_modules/flowbite-svelte-icons/dist/CashSolid.svelte
CashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashSolid.svelte";
var root_1142 = add_locations(from_svg(`<title> </title>`), CashSolid[FILENAME], [[41, 4]]);
var root_2142 = add_locations(from_svg(`<desc> </desc>`), CashSolid[FILENAME], [[44, 4]]);
var root142 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7 6a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2h-2v-4a3 3 0 0 0-3-3H7V6Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M2 11a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-7Zm7.5 1a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Z" clip-rule="evenodd"></path><path d="M10.5 14.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`), CashSolid[FILENAME], [[30, 0, [[46, 2], [51, 2], [55, 5]]]]);
function CashSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root142();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1142();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CashSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2142();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CashSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CashSolid = hmr(CashSolid, () => CashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashSolid[HMR].source;
    set(CashSolid[HMR].source, module.default[HMR].original);
  });
}
var CashSolid_default = CashSolid;

// node_modules/flowbite-svelte-icons/dist/CellAttributesOutline.svelte
CellAttributesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CellAttributesOutline.svelte";
var root_1143 = add_locations(from_svg(`<title> </title>`), CellAttributesOutline[FILENAME], [[43, 4]]);
var root_2143 = add_locations(from_svg(`<desc> </desc>`), CellAttributesOutline[FILENAME], [[46, 4]]);
var root143 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h8v-8m-9 4v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v4M3 11h11m6.25 5c0 1.2426-1.0073 2.25-2.25 2.25M20.25 16c0-1.2426-1.0073-2.25-2.25-2.25M20.25 16H21m-3 2.25c-1.2426 0-2.25-1.0074-2.25-2.25M18 18.25V19m-2.25-3c0-1.2426 1.0074-2.25 2.25-2.25M15.75 16H15m3-2.25V13m-1.591 1.409-.5303-.5303m4.2426 4.2426-.5303-.5303m-3.182 0-.5303.5303m4.2426-4.2426-.5303.5303"></path></svg>`), CellAttributesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CellAttributesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CellAttributesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root143();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1143();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CellAttributesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2143();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CellAttributesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CellAttributesOutline = hmr(CellAttributesOutline, () => CellAttributesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CellAttributesOutline[HMR].source;
    set(CellAttributesOutline[HMR].source, module.default[HMR].original);
  });
}
var CellAttributesOutline_default = CellAttributesOutline;

// node_modules/flowbite-svelte-icons/dist/ChalkboardOutline.svelte
ChalkboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChalkboardOutline.svelte";
var root_1144 = add_locations(from_svg(`<title> </title>`), ChalkboardOutline[FILENAME], [[43, 4]]);
var root_2144 = add_locations(from_svg(`<desc> </desc>`), ChalkboardOutline[FILENAME], [[46, 4]]);
var root144 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 14H4m6.5 3L8 20m5.5-3 2.5 3M4.88889 17H19.1111c.4909 0 .8889-.4157.8889-.9286V4.92857C20 4.41574 19.602 4 19.1111 4H4.88889C4.39797 4 4 4.41574 4 4.92857V16.0714c0 .5129.39797.9286.88889.9286ZM13 14v-3h4v3h-4Z"></path></svg>`), ChalkboardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChalkboardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChalkboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root144();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1144();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChalkboardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2144();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChalkboardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChalkboardOutline = hmr(ChalkboardOutline, () => ChalkboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChalkboardOutline[HMR].source;
    set(ChalkboardOutline[HMR].source, module.default[HMR].original);
  });
}
var ChalkboardOutline_default = ChalkboardOutline;

// node_modules/flowbite-svelte-icons/dist/ChalkboardSolid.svelte
ChalkboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChalkboardSolid.svelte";
var root_1145 = add_locations(from_svg(`<title> </title>`), ChalkboardSolid[FILENAME], [[41, 4]]);
var root_2145 = add_locations(from_svg(`<desc> </desc>`), ChalkboardSolid[FILENAME], [[44, 4]]);
var root145 = add_locations(from_svg(`<svg><!><!><path d="M3 4.92857C3 3.90506 3.80497 3 4.88889 3H19.1111C20.195 3 21 3.90506 21 4.92857V13h-3v-2c0-.5523-.4477-1-1-1h-4c-.5523 0-1 .4477-1 1v2H3V4.92857ZM3 15v1.0714C3 17.0949 3.80497 18 4.88889 18h3.47608L7.2318 19.3598c-.35356.4243-.29624 1.0548.12804 1.4084.42428.3536 1.05484.2962 1.40841-.128L10.9684 18h2.0632l2.2002 2.6402c.3535.4242.9841.4816 1.4084.128.4242-.3536.4816-.9841.128-1.4084L15.635 18h3.4761C20.195 18 21 17.0949 21 16.0714V15H3Z"></path><path d="M16 12v1h-2v-1h2Z"></path></svg>`), ChalkboardSolid[FILENAME], [[30, 0, [[46, 2], [48, 5]]]]);
function ChalkboardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChalkboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root145();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1145();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChalkboardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2145();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChalkboardSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChalkboardSolid = hmr(ChalkboardSolid, () => ChalkboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChalkboardSolid[HMR].source;
    set(ChalkboardSolid[HMR].source, module.default[HMR].original);
  });
}
var ChalkboardSolid_default = ChalkboardSolid;

// node_modules/flowbite-svelte-icons/dist/ChalkboardUserOutline.svelte
ChalkboardUserOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChalkboardUserOutline.svelte";
var root_1146 = add_locations(from_svg(`<title> </title>`), ChalkboardUserOutline[FILENAME], [[43, 4]]);
var root_2146 = add_locations(from_svg(`<desc> </desc>`), ChalkboardUserOutline[FILENAME], [[46, 4]]);
var root146 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.7141 15h4.268c.4043 0 .732-.3838.732-.8571V3.85714c0-.47338-.3277-.85714-.732-.85714H6.71411c-.55228 0-1 .44772-1 1v4m10.99999 7v-3h3v3h-3Zm-3 6H6.71411c-.55228 0-1-.4477-1-1 0-1.6569 1.34315-3 3-3h2.99999c1.6569 0 3 1.3431 3 3 0 .5523-.4477 1-1 1Zm-1-9.5c0 1.3807-1.1193 2.5-2.5 2.5s-2.49999-1.1193-2.49999-2.5S8.8334 9 10.2141 9s2.5 1.1193 2.5 2.5Z"></path></svg>`), ChalkboardUserOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChalkboardUserOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChalkboardUserOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root146();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1146();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChalkboardUserOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2146();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChalkboardUserOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChalkboardUserOutline = hmr(ChalkboardUserOutline, () => ChalkboardUserOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChalkboardUserOutline[HMR].source;
    set(ChalkboardUserOutline[HMR].source, module.default[HMR].original);
  });
}
var ChalkboardUserOutline_default = ChalkboardUserOutline;

// node_modules/flowbite-svelte-icons/dist/ChalkboardUserSolid.svelte
ChalkboardUserSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChalkboardUserSolid.svelte";
var root_1147 = add_locations(from_svg(`<title> </title>`), ChalkboardUserSolid[FILENAME], [[41, 4]]);
var root_2147 = add_locations(from_svg(`<desc> </desc>`), ChalkboardUserSolid[FILENAME], [[44, 4]]);
var root147 = add_locations(from_svg(`<svg><!><!><path d="M6 2c-1.10457 0-2 .89543-2 2v4c0 .55228.44772 1 1 1s1-.44772 1-1V4h12v7h-2c-.5523 0-1 .4477-1 1v2h-1c-.5523 0-1 .4477-1 1s.4477 1 1 1h5c.5523 0 1-.4477 1-1V3.85714C20 2.98529 19.3667 2 18.268 2H6Z"></path><path d="M6 11.5C6 9.567 7.567 8 9.5 8S13 9.567 13 11.5 11.433 15 9.5 15 6 13.433 6 11.5ZM4 20c0-2.2091 1.79086-4 4-4h3c2.2091 0 4 1.7909 4 4 0 1.1046-.8954 2-2 2H6c-1.10457 0-2-.8954-2-2Z"></path></svg>`), ChalkboardUserSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function ChalkboardUserSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChalkboardUserSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root147();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1147();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChalkboardUserSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2147();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChalkboardUserSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChalkboardUserSolid = hmr(ChalkboardUserSolid, () => ChalkboardUserSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChalkboardUserSolid[HMR].source;
    set(ChalkboardUserSolid[HMR].source, module.default[HMR].original);
  });
}
var ChalkboardUserSolid_default = ChalkboardUserSolid;

// node_modules/flowbite-svelte-icons/dist/ChampagneGlassesOutline.svelte
ChampagneGlassesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChampagneGlassesOutline.svelte";
var root_1148 = add_locations(from_svg(`<title> </title>`), ChampagneGlassesOutline[FILENAME], [[43, 4]]);
var root_2148 = add_locations(from_svg(`<desc> </desc>`), ChampagneGlassesOutline[FILENAME], [[46, 4]]);
var root148 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 15c1.65685 0 3-1.3431 3-3V6H4v6c0 1.6569 1.34315 3 3 3Zm0 0v5m-2 0h4M4 9h6m6.6083 4.4863c1.5775-.5067 2.4456-2.1962 1.939-3.77367L16.7126 4 11 5.83463l1.8346 5.71267c.5066 1.5775 2.1962 2.4456 3.7737 1.939Zm0 0 1.5288 4.7605m-1.9042.6115 3.8084-1.2231m-8.124-8.94426 5.7126-1.83463"></path></svg>`), ChampagneGlassesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChampagneGlassesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChampagneGlassesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root148();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1148();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChampagneGlassesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2148();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChampagneGlassesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChampagneGlassesOutline = hmr(ChampagneGlassesOutline, () => ChampagneGlassesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChampagneGlassesOutline[HMR].source;
    set(ChampagneGlassesOutline[HMR].source, module.default[HMR].original);
  });
}
var ChampagneGlassesOutline_default = ChampagneGlassesOutline;

// node_modules/flowbite-svelte-icons/dist/ChampagneGlassesSolid.svelte
ChampagneGlassesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChampagneGlassesSolid.svelte";
var root_1149 = add_locations(from_svg(`<title> </title>`), ChampagneGlassesSolid[FILENAME], [[41, 4]]);
var root_2149 = add_locations(from_svg(`<desc> </desc>`), ChampagneGlassesSolid[FILENAME], [[44, 4]]);
var root149 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17.6647 3.69423c-.0811-.25251-.2591-.46247-.495-.58368-.2359-.12121-.5103-.14375-.7628-.06265l-5.7127 1.83462c-.1263.04057-.2389.10389-.3349.18397C10.2478 5.02354 10.1266 5 10 5H4c-.55228 0-1 .44772-1 1v6c0 1.8638 1.27477 3.4299 3 3.874V19H5c-.55228 0-1 .4477-1 1s.44772 1 1 1h4c.55228 0 1-.4477 1-1s-.44772-1-1-1H8v-3.126c1.72523-.4441 3-2.0102 3-3.874V9.10505l.8825 2.74795c.5699 1.7746 2.2625 2.8759 4.0409 2.7712l.9558 2.9763-.9521.3057c-.5258.1689-.8152.7321-.6463 1.2579.1689.5258.732.8152 1.2579.6463l3.8084-1.2231c.5258-.1688.8152-.732.6463-1.2578-.1688-.5259-.732-.8152-1.2578-.6464l-.9522.3058-.9558-2.9763c1.5068-.9503 2.2417-2.8312 1.6718-4.60574l-1.8347-5.71263ZM9 7v1H5V7h4Zm7.0663-1.74212.3058.9521-3.8085 1.22309-.3057-.95211 3.8084-1.22308Z" clip-rule="evenodd"></path></svg>`), ChampagneGlassesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ChampagneGlassesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChampagneGlassesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root149();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1149();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChampagneGlassesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2149();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChampagneGlassesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChampagneGlassesSolid = hmr(ChampagneGlassesSolid, () => ChampagneGlassesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChampagneGlassesSolid[HMR].source;
    set(ChampagneGlassesSolid[HMR].source, module.default[HMR].original);
  });
}
var ChampagneGlassesSolid_default = ChampagneGlassesSolid;

// node_modules/flowbite-svelte-icons/dist/ChartLineDownOutline.svelte
ChartLineDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartLineDownOutline.svelte";
var root_1150 = add_locations(from_svg(`<title> </title>`), ChartLineDownOutline[FILENAME], [[43, 4]]);
var root_2150 = add_locations(from_svg(`<desc> </desc>`), ChartLineDownOutline[FILENAME], [[46, 4]]);
var root150 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4.5V19a1 1 0 0 0 1 1h15M7 10l4 4 4-4 5 5m0 0h-3.207M20 15v-3.207"></path></svg>`), ChartLineDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChartLineDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartLineDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root150();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1150();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartLineDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2150();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartLineDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartLineDownOutline = hmr(ChartLineDownOutline, () => ChartLineDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartLineDownOutline[HMR].source;
    set(ChartLineDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartLineDownOutline_default = ChartLineDownOutline;

// node_modules/flowbite-svelte-icons/dist/ChartLineUpOutline.svelte
ChartLineUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartLineUpOutline.svelte";
var root_1151 = add_locations(from_svg(`<title> </title>`), ChartLineUpOutline[FILENAME], [[43, 4]]);
var root_2151 = add_locations(from_svg(`<desc> </desc>`), ChartLineUpOutline[FILENAME], [[46, 4]]);
var root151 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4.5V19a1 1 0 0 0 1 1h15M7 14l4-4 4 4 5-5m0 0h-3.207M20 9v3.207"></path></svg>`), ChartLineUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChartLineUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartLineUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root151();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1151();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartLineUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2151();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartLineUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartLineUpOutline = hmr(ChartLineUpOutline, () => ChartLineUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartLineUpOutline[HMR].source;
    set(ChartLineUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartLineUpOutline_default = ChartLineUpOutline;

// node_modules/flowbite-svelte-icons/dist/ChartMixedDollarOutline.svelte
ChartMixedDollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedDollarOutline.svelte";
var root_1152 = add_locations(from_svg(`<title> </title>`), ChartMixedDollarOutline[FILENAME], [[43, 4]]);
var root_2152 = add_locations(from_svg(`<desc> </desc>`), ChartMixedDollarOutline[FILENAME], [[46, 4]]);
var root152 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.6 16.733c.234.269.548.456.895.534a1.4 1.4 0 0 0 1.75-.762c.172-.615-.446-1.287-1.242-1.481-.796-.194-1.41-.861-1.241-1.481a1.4 1.4 0 0 1 1.75-.762c.343.077.654.26.888.524m-1.358 4.017v.617m0-5.939v.725M4 15v4m3-6v6M6 8.5 10.5 5 14 7.5 18 4m0 0h-3.5M18 4v3m2 8a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"></path></svg>`), ChartMixedDollarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChartMixedDollarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartMixedDollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root152();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1152();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartMixedDollarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2152();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartMixedDollarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartMixedDollarOutline = hmr(ChartMixedDollarOutline, () => ChartMixedDollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedDollarOutline[HMR].source;
    set(ChartMixedDollarOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedDollarOutline_default = ChartMixedDollarOutline;

// node_modules/flowbite-svelte-icons/dist/ChartMixedDollarSolid.svelte
ChartMixedDollarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedDollarSolid.svelte";
var root_1153 = add_locations(from_svg(`<title> </title>`), ChartMixedDollarSolid[FILENAME], [[41, 4]]);
var root_2153 = add_locations(from_svg(`<desc> </desc>`), ChartMixedDollarSolid[FILENAME], [[44, 4]]);
var root153 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 15a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm3.845-1.855a2.4 2.4 0 0 1 1.2-1.226 1 1 0 0 1 1.992-.026c.426.15.809.408 1.111.749a1 1 0 1 1-1.496 1.327.682.682 0 0 0-.36-.213.997.997 0 0 1-.113-.032.4.4 0 0 0-.394.074.93.93 0 0 0 .455.254 2.914 2.914 0 0 1 1.504.9c.373.433.669 1.092.464 1.823a.996.996 0 0 1-.046.129c-.226.519-.627.94-1.132 1.192a1 1 0 0 1-1.956.093 2.68 2.68 0 0 1-1.227-.798 1 1 0 1 1 1.506-1.315.682.682 0 0 0 .363.216c.038.009.075.02.111.032a.4.4 0 0 0 .395-.074.93.93 0 0 0-.455-.254 2.91 2.91 0 0 1-1.503-.9c-.375-.433-.666-1.089-.466-1.817a.994.994 0 0 1 .047-.134Zm1.884.573.003.008c-.003-.005-.003-.008-.003-.008Zm.55 2.613s-.002-.002-.003-.007a.032.032 0 0 1 .003.007ZM4 14a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0v-4a1 1 0 0 1 1-1Zm3-2a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Zm6.5-8a1 1 0 0 1 1-1H18a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-.796l-2.341 2.049a1 1 0 0 1-1.24.06l-2.894-2.066L6.614 9.29a1 1 0 1 1-1.228-1.578l4.5-3.5a1 1 0 0 1 1.195-.025l2.856 2.04L15.34 5h-.84a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), ChartMixedDollarSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartMixedDollarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartMixedDollarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root153();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1153();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartMixedDollarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2153();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartMixedDollarSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartMixedDollarSolid = hmr(ChartMixedDollarSolid, () => ChartMixedDollarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedDollarSolid[HMR].source;
    set(ChartMixedDollarSolid[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedDollarSolid_default = ChartMixedDollarSolid;

// node_modules/flowbite-svelte-icons/dist/ChartMixedOutline.svelte
ChartMixedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedOutline.svelte";
var root_1154 = add_locations(from_svg(`<title> </title>`), ChartMixedOutline[FILENAME], [[43, 4]]);
var root_2154 = add_locations(from_svg(`<desc> </desc>`), ChartMixedOutline[FILENAME], [[46, 4]]);
var root154 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v4m6-6v6m6-4v4m6-6v6M3 11l6-5 6 5 5.5-5.5"></path></svg>`), ChartMixedOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChartMixedOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartMixedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root154();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1154();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartMixedOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2154();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartMixedOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartMixedOutline = hmr(ChartMixedOutline, () => ChartMixedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedOutline[HMR].source;
    set(ChartMixedOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedOutline_default = ChartMixedOutline;

// node_modules/flowbite-svelte-icons/dist/ChartOutline.svelte
ChartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartOutline.svelte";
var root_1155 = add_locations(from_svg(`<title> </title>`), ChartOutline[FILENAME], [[43, 4]]);
var root_2155 = add_locations(from_svg(`<desc> </desc>`), ChartOutline[FILENAME], [[46, 4]]);
var root155 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4v15a1 1 0 0 0 1 1h15M8 16l2.5-5.5 3 3L17.273 7 20 9.667"></path></svg>`), ChartOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChartOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root155();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1155();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2155();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartOutline = hmr(ChartOutline, () => ChartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartOutline[HMR].source;
    set(ChartOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartOutline_default = ChartOutline;

// node_modules/flowbite-svelte-icons/dist/ChartPieOutline.svelte
ChartPieOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartPieOutline.svelte";
var root_1156 = add_locations(from_svg(`<title> </title>`), ChartPieOutline[FILENAME], [[43, 4]]);
var root_2156 = add_locations(from_svg(`<desc> </desc>`), ChartPieOutline[FILENAME], [[46, 4]]);
var root156 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 6.025A7.5 7.5 0 1 0 17.975 14H10V6.025Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 3c-.169 0-.334.014-.5.025V11h7.975c.011-.166.025-.331.025-.5A7.5 7.5 0 0 0 13.5 3Z"></path></svg>`), ChartPieOutline[FILENAME], [[31, 0, [[48, 2], [55, 2]]]]);
function ChartPieOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartPieOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root156();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1156();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartPieOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2156();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartPieOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartPieOutline = hmr(ChartPieOutline, () => ChartPieOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartPieOutline[HMR].source;
    set(ChartPieOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartPieOutline_default = ChartPieOutline;

// node_modules/flowbite-svelte-icons/dist/ChartPieSolid.svelte
ChartPieSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartPieSolid.svelte";
var root_1157 = add_locations(from_svg(`<title> </title>`), ChartPieSolid[FILENAME], [[41, 4]]);
var root_2157 = add_locations(from_svg(`<desc> </desc>`), ChartPieSolid[FILENAME], [[44, 4]]);
var root157 = add_locations(from_svg(`<svg><!><!><path d="M13.5 2c-.178 0-.356.013-.492.022l-.074.005a1 1 0 0 0-.934.998V11a1 1 0 0 0 1 1h7.975a1 1 0 0 0 .998-.934l.005-.074A7.04 7.04 0 0 0 22 10.5 8.5 8.5 0 0 0 13.5 2Z"></path><path d="M11 6.025a1 1 0 0 0-1.065-.998 8.5 8.5 0 1 0 9.038 9.039A1 1 0 0 0 17.975 13H11V6.025Z"></path></svg>`), ChartPieSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function ChartPieSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChartPieSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root157();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1157();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChartPieSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2157();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChartPieSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChartPieSolid = hmr(ChartPieSolid, () => ChartPieSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartPieSolid[HMR].source;
    set(ChartPieSolid[HMR].source, module.default[HMR].original);
  });
}
var ChartPieSolid_default = ChartPieSolid;

// node_modules/flowbite-svelte-icons/dist/CheckCircleOutline.svelte
CheckCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckCircleOutline.svelte";
var root_1158 = add_locations(from_svg(`<title> </title>`), CheckCircleOutline[FILENAME], [[43, 4]]);
var root_2158 = add_locations(from_svg(`<desc> </desc>`), CheckCircleOutline[FILENAME], [[46, 4]]);
var root158 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.5 11.5 11 14l4-4m6 2a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CheckCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CheckCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheckCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root158();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1158();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheckCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2158();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheckCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheckCircleOutline = hmr(CheckCircleOutline, () => CheckCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckCircleOutline[HMR].source;
    set(CheckCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckCircleOutline_default = CheckCircleOutline;

// node_modules/flowbite-svelte-icons/dist/CheckCircleSolid.svelte
CheckCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckCircleSolid.svelte";
var root_1159 = add_locations(from_svg(`<title> </title>`), CheckCircleSolid[FILENAME], [[41, 4]]);
var root_2159 = add_locations(from_svg(`<desc> </desc>`), CheckCircleSolid[FILENAME], [[44, 4]]);
var root159 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm13.707-1.293a1 1 0 0 0-1.414-1.414L11 12.586l-1.793-1.793a1 1 0 0 0-1.414 1.414l2.5 2.5a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), CheckCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CheckCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheckCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root159();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1159();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheckCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2159();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheckCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheckCircleSolid = hmr(CheckCircleSolid, () => CheckCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckCircleSolid[HMR].source;
    set(CheckCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CheckCircleSolid_default = CheckCircleSolid;

// node_modules/flowbite-svelte-icons/dist/CheckOutline.svelte
CheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckOutline.svelte";
var root_1160 = add_locations(from_svg(`<title> </title>`), CheckOutline[FILENAME], [[43, 4]]);
var root_2160 = add_locations(from_svg(`<desc> </desc>`), CheckOutline[FILENAME], [[46, 4]]);
var root160 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 11.917 9.724 16.5 19 7.5"></path></svg>`), CheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root160();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1160();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2160();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheckOutline = hmr(CheckOutline, () => CheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckOutline[HMR].source;
    set(CheckOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckOutline_default = CheckOutline;

// node_modules/flowbite-svelte-icons/dist/CheckPlusCircleOutline.svelte
CheckPlusCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckPlusCircleOutline.svelte";
var root_1161 = add_locations(from_svg(`<title> </title>`), CheckPlusCircleOutline[FILENAME], [[43, 4]]);
var root_2161 = add_locations(from_svg(`<desc> </desc>`), CheckPlusCircleOutline[FILENAME], [[46, 4]]);
var root161 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 1 0-18c1.052 0 2.062.18 3 .512M7 9.577l3.923 3.923 8.5-8.5M17 14v6m-3-3h6"></path></svg>`), CheckPlusCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CheckPlusCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheckPlusCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root161();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1161();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheckPlusCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2161();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheckPlusCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheckPlusCircleOutline = hmr(CheckPlusCircleOutline, () => CheckPlusCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckPlusCircleOutline[HMR].source;
    set(CheckPlusCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckPlusCircleOutline_default = CheckPlusCircleOutline;

// node_modules/flowbite-svelte-icons/dist/CheckPlusCircleSolid.svelte
CheckPlusCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckPlusCircleSolid.svelte";
var root_1162 = add_locations(from_svg(`<title> </title>`), CheckPlusCircleSolid[FILENAME], [[41, 4]]);
var root_2162 = add_locations(from_svg(`<desc> </desc>`), CheckPlusCircleSolid[FILENAME], [[44, 4]]);
var root162 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M18 14a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M15.026 21.534A9.994 9.994 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2c2.51 0 4.802.924 6.558 2.45l-7.635 7.636L7.707 8.87a1 1 0 0 0-1.414 1.414l3.923 3.923a1 1 0 0 0 1.414 0l8.3-8.3A9.956 9.956 0 0 1 22 12a9.994 9.994 0 0 1-.466 3.026A2.49 2.49 0 0 0 20 14.5h-.5V14a2.5 2.5 0 0 0-5 0v.5H14a2.5 2.5 0 0 0 0 5h.5v.5c0 .578.196 1.11.526 1.534Z" clip-rule="evenodd"></path></svg>`), CheckPlusCircleSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function CheckPlusCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheckPlusCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root162();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1162();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheckPlusCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2162();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheckPlusCircleSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheckPlusCircleSolid = hmr(CheckPlusCircleSolid, () => CheckPlusCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckPlusCircleSolid[HMR].source;
    set(CheckPlusCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CheckPlusCircleSolid_default = CheckPlusCircleSolid;

// node_modules/flowbite-svelte-icons/dist/CheeseOutline.svelte
CheeseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheeseOutline.svelte";
var root_1163 = add_locations(from_svg(`<title> </title>`), CheeseOutline[FILENAME], [[43, 4]]);
var root_2163 = add_locations(from_svg(`<desc> </desc>`), CheeseOutline[FILENAME], [[46, 4]]);
var root163 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4 12 6.4267-4.65924c.6372.89667 1.8922 1.10897 2.7888.4718.8967-.63718 1.3493-1.69135.4681-2.80084C13.6373 4.95345 14.9106 4 15 4c.0894 0 5 1 5 8M4 12h16M4 12v8h16v-8M8 15h.01M12 17h.01M16 15h.01"></path></svg>`), CheeseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CheeseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheeseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root163();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1163();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheeseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2163();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheeseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheeseOutline = hmr(CheeseOutline, () => CheeseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheeseOutline[HMR].source;
    set(CheeseOutline[HMR].source, module.default[HMR].original);
  });
}
var CheeseOutline_default = CheeseOutline;

// node_modules/flowbite-svelte-icons/dist/CheeseSolid.svelte
CheeseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheeseSolid.svelte";
var root_1164 = add_locations(from_svg(`<title> </title>`), CheeseSolid[FILENAME], [[41, 4]]);
var root_2164 = add_locations(from_svg(`<desc> </desc>`), CheeseSolid[FILENAME], [[44, 4]]);
var root164 = add_locations(from_svg(`<svg><!><!><path d="M15 3c-.1786 0-.3148.04901-.3477.06086l-.0019.00067c-.0536.01922-.0966.03945-.1218.05185-.0518.02551-.0982.05265-.1303.07208-.0678.04099-.1431.0911-.2151.14063-.1473.10137-.3263.23197-.4968.36132-.1692.12838-.3437.266-.4787.38123-.0636.05432-.1392.12126-.2038.18822-.0266.02752-.088.09218-.1456.17829-.0249.03726-.0901.13788-.133.281-.0354.11767-.1317.53104.1752.91753.2792.35149.2765.58359.2431.72327-.0431.18039-.193.41708-.5073.64046-.4465.31726-1.0772.21057-1.3944-.2359-.1546-.21753-.3897-.36425-.653-.40752-.2634-.04326-.5331.02052-.74913.17715L3.67565 11H20.9672c-.2133-3.17401-1.4351-5.16089-2.7614-6.3653-.7159-.65012-1.4371-1.04951-1.9922-1.28791-.2778-.11933-.5168-.19955-.6971-.25131-.0899-.02583-.1674-.04518-.2298-.05899-.0308-.0068-.0614-.01302-.0904-.01815-.0141-.00248-.0326-.00556-.0533-.00839C15.1364 3.00899 15.0741 3 15 3Z"></path><path fill-rule="evenodd" d="M21 13H3v7c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-7ZM7 15c0-.5523.44772-1 1-1h.01c.55228 0 1 .4477 1 1s-.44772 1-1 1H8c-.55228 0-1-.4477-1-1Zm8 0c0-.5523.4477-1 1-1h.01c.5523 0 1 .4477 1 1s-.4477 1-1 1H16c-.5523 0-1-.4477-1-1Zm-4 2c0-.5523.4477-1 1-1h.01c.5523 0 1 .4477 1 1s-.4477 1-1 1H12c-.5523 0-1-.4477-1-1Z" clip-rule="evenodd"></path></svg>`), CheeseSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function CheeseSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CheeseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root164();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1164();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CheeseSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2164();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CheeseSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CheeseSolid = hmr(CheeseSolid, () => CheeseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheeseSolid[HMR].source;
    set(CheeseSolid[HMR].source, module.default[HMR].original);
  });
}
var CheeseSolid_default = CheeseSolid;

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleDownOutline.svelte
ChevronDoubleDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleDownOutline.svelte";
var root_1165 = add_locations(from_svg(`<title> </title>`), ChevronDoubleDownOutline[FILENAME], [[43, 4]]);
var root_2165 = add_locations(from_svg(`<desc> </desc>`), ChevronDoubleDownOutline[FILENAME], [[46, 4]]);
var root165 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 7 4 4 4-4m-8 6 4 4 4-4"></path></svg>`), ChevronDoubleDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronDoubleDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronDoubleDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root165();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1165();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronDoubleDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2165();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronDoubleDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronDoubleDownOutline = hmr(ChevronDoubleDownOutline, () => ChevronDoubleDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleDownOutline[HMR].source;
    set(ChevronDoubleDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleDownOutline_default = ChevronDoubleDownOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleLeftOutline.svelte
ChevronDoubleLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleLeftOutline.svelte";
var root_1166 = add_locations(from_svg(`<title> </title>`), ChevronDoubleLeftOutline[FILENAME], [[43, 4]]);
var root_2166 = add_locations(from_svg(`<desc> </desc>`), ChevronDoubleLeftOutline[FILENAME], [[46, 4]]);
var root166 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17 16-4-4 4-4m-6 8-4-4 4-4"></path></svg>`), ChevronDoubleLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronDoubleLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronDoubleLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root166();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1166();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronDoubleLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2166();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronDoubleLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronDoubleLeftOutline = hmr(ChevronDoubleLeftOutline, () => ChevronDoubleLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleLeftOutline[HMR].source;
    set(ChevronDoubleLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleLeftOutline_default = ChevronDoubleLeftOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleRightOutline.svelte
ChevronDoubleRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleRightOutline.svelte";
var root_1167 = add_locations(from_svg(`<title> </title>`), ChevronDoubleRightOutline[FILENAME], [[43, 4]]);
var root_2167 = add_locations(from_svg(`<desc> </desc>`), ChevronDoubleRightOutline[FILENAME], [[46, 4]]);
var root167 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7 16 4-4-4-4m6 8 4-4-4-4"></path></svg>`), ChevronDoubleRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronDoubleRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronDoubleRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root167();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1167();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronDoubleRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2167();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronDoubleRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronDoubleRightOutline = hmr(ChevronDoubleRightOutline, () => ChevronDoubleRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleRightOutline[HMR].source;
    set(ChevronDoubleRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleRightOutline_default = ChevronDoubleRightOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleUpOutline.svelte
ChevronDoubleUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleUpOutline.svelte";
var root_1168 = add_locations(from_svg(`<title> </title>`), ChevronDoubleUpOutline[FILENAME], [[43, 4]]);
var root_2168 = add_locations(from_svg(`<desc> </desc>`), ChevronDoubleUpOutline[FILENAME], [[46, 4]]);
var root168 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 17-4-4-4 4m8-6-4-4-4 4"></path></svg>`), ChevronDoubleUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronDoubleUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronDoubleUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root168();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1168();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronDoubleUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2168();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronDoubleUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronDoubleUpOutline = hmr(ChevronDoubleUpOutline, () => ChevronDoubleUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleUpOutline[HMR].source;
    set(ChevronDoubleUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleUpOutline_default = ChevronDoubleUpOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronDownOutline.svelte
ChevronDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDownOutline.svelte";
var root_1169 = add_locations(from_svg(`<title> </title>`), ChevronDownOutline[FILENAME], [[43, 4]]);
var root_2169 = add_locations(from_svg(`<desc> </desc>`), ChevronDownOutline[FILENAME], [[46, 4]]);
var root169 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 10 4 4 4-4"></path></svg>`), ChevronDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root169();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1169();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2169();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronDownOutline = hmr(ChevronDownOutline, () => ChevronDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDownOutline[HMR].source;
    set(ChevronDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDownOutline_default = ChevronDownOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronLeftOutline.svelte
ChevronLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronLeftOutline.svelte";
var root_1170 = add_locations(from_svg(`<title> </title>`), ChevronLeftOutline[FILENAME], [[43, 4]]);
var root_2170 = add_locations(from_svg(`<desc> </desc>`), ChevronLeftOutline[FILENAME], [[46, 4]]);
var root170 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m14 8-4 4 4 4"></path></svg>`), ChevronLeftOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronLeftOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root170();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1170();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronLeftOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2170();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronLeftOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronLeftOutline = hmr(ChevronLeftOutline, () => ChevronLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronLeftOutline[HMR].source;
    set(ChevronLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronLeftOutline_default = ChevronLeftOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronRightOutline.svelte
ChevronRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronRightOutline.svelte";
var root_1171 = add_locations(from_svg(`<title> </title>`), ChevronRightOutline[FILENAME], [[43, 4]]);
var root_2171 = add_locations(from_svg(`<desc> </desc>`), ChevronRightOutline[FILENAME], [[46, 4]]);
var root171 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10 16 4-4-4-4"></path></svg>`), ChevronRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root171();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1171();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2171();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronRightOutline = hmr(ChevronRightOutline, () => ChevronRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronRightOutline[HMR].source;
    set(ChevronRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronRightOutline_default = ChevronRightOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronSortOutline.svelte
ChevronSortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronSortOutline.svelte";
var root_1172 = add_locations(from_svg(`<title> </title>`), ChevronSortOutline[FILENAME], [[43, 4]]);
var root_2172 = add_locations(from_svg(`<desc> </desc>`), ChevronSortOutline[FILENAME], [[46, 4]]);
var root172 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 15 4 4 4-4m0-6-4-4-4 4"></path></svg>`), ChevronSortOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronSortOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronSortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root172();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1172();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronSortOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2172();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronSortOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronSortOutline = hmr(ChevronSortOutline, () => ChevronSortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronSortOutline[HMR].source;
    set(ChevronSortOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronSortOutline_default = ChevronSortOutline;

// node_modules/flowbite-svelte-icons/dist/ChevronUpOutline.svelte
ChevronUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronUpOutline.svelte";
var root_1173 = add_locations(from_svg(`<title> </title>`), ChevronUpOutline[FILENAME], [[43, 4]]);
var root_2173 = add_locations(from_svg(`<desc> </desc>`), ChevronUpOutline[FILENAME], [[46, 4]]);
var root173 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 14-4-4-4 4"></path></svg>`), ChevronUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ChevronUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ChevronUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root173();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1173();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ChevronUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2173();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ChevronUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ChevronUpOutline = hmr(ChevronUpOutline, () => ChevronUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronUpOutline[HMR].source;
    set(ChevronUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronUpOutline_default = ChevronUpOutline;

// node_modules/flowbite-svelte-icons/dist/CircleMinusOutline.svelte
CircleMinusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CircleMinusOutline.svelte";
var root_1174 = add_locations(from_svg(`<title> </title>`), CircleMinusOutline[FILENAME], [[43, 4]]);
var root_2174 = add_locations(from_svg(`<desc> </desc>`), CircleMinusOutline[FILENAME], [[46, 4]]);
var root174 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.757 12h8.486M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CircleMinusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CircleMinusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CircleMinusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root174();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1174();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CircleMinusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2174();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CircleMinusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CircleMinusOutline = hmr(CircleMinusOutline, () => CircleMinusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CircleMinusOutline[HMR].source;
    set(CircleMinusOutline[HMR].source, module.default[HMR].original);
  });
}
var CircleMinusOutline_default = CircleMinusOutline;

// node_modules/flowbite-svelte-icons/dist/CircleMinusSolid.svelte
CircleMinusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CircleMinusSolid.svelte";
var root_1175 = add_locations(from_svg(`<title> </title>`), CircleMinusSolid[FILENAME], [[41, 4]]);
var root_2175 = add_locations(from_svg(`<desc> </desc>`), CircleMinusSolid[FILENAME], [[44, 4]]);
var root175 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm5.757-1a1 1 0 1 0 0 2h8.486a1 1 0 1 0 0-2H7.757Z" clip-rule="evenodd"></path></svg>`), CircleMinusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CircleMinusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CircleMinusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root175();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1175();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CircleMinusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2175();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CircleMinusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CircleMinusSolid = hmr(CircleMinusSolid, () => CircleMinusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CircleMinusSolid[HMR].source;
    set(CircleMinusSolid[HMR].source, module.default[HMR].original);
  });
}
var CircleMinusSolid_default = CircleMinusSolid;

// node_modules/flowbite-svelte-icons/dist/CirclePauseOutline.svelte
CirclePauseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePauseOutline.svelte";
var root_1176 = add_locations(from_svg(`<title> </title>`), CirclePauseOutline[FILENAME], [[43, 4]]);
var root_2176 = add_locations(from_svg(`<desc> </desc>`), CirclePauseOutline[FILENAME], [[46, 4]]);
var root176 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CirclePauseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CirclePauseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CirclePauseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root176();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1176();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CirclePauseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2176();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CirclePauseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CirclePauseOutline = hmr(CirclePauseOutline, () => CirclePauseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePauseOutline[HMR].source;
    set(CirclePauseOutline[HMR].source, module.default[HMR].original);
  });
}
var CirclePauseOutline_default = CirclePauseOutline;

// node_modules/flowbite-svelte-icons/dist/CirclePauseSolid.svelte
CirclePauseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePauseSolid.svelte";
var root_1177 = add_locations(from_svg(`<title> </title>`), CirclePauseSolid[FILENAME], [[41, 4]]);
var root_2177 = add_locations(from_svg(`<desc> </desc>`), CirclePauseSolid[FILENAME], [[44, 4]]);
var root177 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9-3a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0V9Zm4 0a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0V9Z" clip-rule="evenodd"></path></svg>`), CirclePauseSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CirclePauseSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CirclePauseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root177();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1177();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CirclePauseSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2177();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CirclePauseSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CirclePauseSolid = hmr(CirclePauseSolid, () => CirclePauseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePauseSolid[HMR].source;
    set(CirclePauseSolid[HMR].source, module.default[HMR].original);
  });
}
var CirclePauseSolid_default = CirclePauseSolid;

// node_modules/flowbite-svelte-icons/dist/CirclePlusOutline.svelte
CirclePlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePlusOutline.svelte";
var root_1178 = add_locations(from_svg(`<title> </title>`), CirclePlusOutline[FILENAME], [[43, 4]]);
var root_2178 = add_locations(from_svg(`<desc> </desc>`), CirclePlusOutline[FILENAME], [[46, 4]]);
var root178 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 7.757v8.486M7.757 12h8.486M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CirclePlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CirclePlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CirclePlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root178();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1178();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CirclePlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2178();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CirclePlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CirclePlusOutline = hmr(CirclePlusOutline, () => CirclePlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePlusOutline[HMR].source;
    set(CirclePlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CirclePlusOutline_default = CirclePlusOutline;

// node_modules/flowbite-svelte-icons/dist/CirclePlusSolid.svelte
CirclePlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePlusSolid.svelte";
var root_1179 = add_locations(from_svg(`<title> </title>`), CirclePlusSolid[FILENAME], [[41, 4]]);
var root_2179 = add_locations(from_svg(`<desc> </desc>`), CirclePlusSolid[FILENAME], [[44, 4]]);
var root179 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4.243a1 1 0 1 0-2 0V11H7.757a1 1 0 1 0 0 2H11v3.243a1 1 0 1 0 2 0V13h3.243a1 1 0 1 0 0-2H13V7.757Z" clip-rule="evenodd"></path></svg>`), CirclePlusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CirclePlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CirclePlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root179();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1179();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CirclePlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2179();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CirclePlusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CirclePlusSolid = hmr(CirclePlusSolid, () => CirclePlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePlusSolid[HMR].source;
    set(CirclePlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CirclePlusSolid_default = CirclePlusSolid;

// node_modules/flowbite-svelte-icons/dist/ClapperboardPlayOutline.svelte
ClapperboardPlayOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClapperboardPlayOutline.svelte";
var root_1180 = add_locations(from_svg(`<title> </title>`), ClapperboardPlayOutline[FILENAME], [[43, 4]]);
var root_2180 = add_locations(from_svg(`<desc> </desc>`), ClapperboardPlayOutline[FILENAME], [[46, 4]]);
var root180 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 4H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1Zm0 0-4 4m5 0H4m1 0 4-4m1 4 4-4m-4 7v6l4-3-4-3Z"></path></svg>`), ClapperboardPlayOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClapperboardPlayOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClapperboardPlayOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root180();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1180();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClapperboardPlayOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2180();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClapperboardPlayOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClapperboardPlayOutline = hmr(ClapperboardPlayOutline, () => ClapperboardPlayOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClapperboardPlayOutline[HMR].source;
    set(ClapperboardPlayOutline[HMR].source, module.default[HMR].original);
  });
}
var ClapperboardPlayOutline_default = ClapperboardPlayOutline;

// node_modules/flowbite-svelte-icons/dist/ClapperboardPlaySolid.svelte
ClapperboardPlaySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClapperboardPlaySolid.svelte";
var root_1181 = add_locations(from_svg(`<title> </title>`), ClapperboardPlaySolid[FILENAME], [[41, 4]]);
var root_2181 = add_locations(from_svg(`<desc> </desc>`), ClapperboardPlaySolid[FILENAME], [[44, 4]]);
var root181 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M19.003 3A2 2 0 0 1 21 5v2h-2V5.414L17.414 7h-2.828l2-2h-2.172l-2 2H9.586l2-2H9.414l-2 2H3V5a2 2 0 0 1 2-2h14.003ZM3 9v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9H3Zm2-2.414L6.586 5H5v1.586Zm4.553 4.52a1 1 0 0 1 1.047.094l4 3a1 1 0 0 1 0 1.6l-4 3A1 1 0 0 1 9 18v-6a1 1 0 0 1 .553-.894Z" clip-rule="evenodd"></path></svg>`), ClapperboardPlaySolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClapperboardPlaySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClapperboardPlaySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root181();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1181();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClapperboardPlaySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2181();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClapperboardPlaySolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClapperboardPlaySolid = hmr(ClapperboardPlaySolid, () => ClapperboardPlaySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClapperboardPlaySolid[HMR].source;
    set(ClapperboardPlaySolid[HMR].source, module.default[HMR].original);
  });
}
var ClapperboardPlaySolid_default = ClapperboardPlaySolid;

// node_modules/flowbite-svelte-icons/dist/ClipboardCheckOutline.svelte
ClipboardCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCheckOutline.svelte";
var root_1182 = add_locations(from_svg(`<title> </title>`), ClipboardCheckOutline[FILENAME], [[43, 4]]);
var root_2182 = add_locations(from_svg(`<desc> </desc>`), ClipboardCheckOutline[FILENAME], [[46, 4]]);
var root182 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-6 7 2 2 4-4m-5-9v4h4V3h-4Z"></path></svg>`), ClipboardCheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClipboardCheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root182();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1182();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardCheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2182();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardCheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardCheckOutline = hmr(ClipboardCheckOutline, () => ClipboardCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCheckOutline[HMR].source;
    set(ClipboardCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCheckOutline_default = ClipboardCheckOutline;

// node_modules/flowbite-svelte-icons/dist/ClipboardCheckSolid.svelte
ClipboardCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCheckSolid.svelte";
var root_1183 = add_locations(from_svg(`<title> </title>`), ClipboardCheckSolid[FILENAME], [[41, 4]]);
var root_2183 = add_locations(from_svg(`<desc> </desc>`), ClipboardCheckSolid[FILENAME], [[44, 4]]);
var root183 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2a1 1 0 0 0-1 1H6a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-2a1 1 0 0 0-1-1H9Zm1 2h4v2h1a1 1 0 1 1 0 2H9a1 1 0 0 1 0-2h1V4Zm5.707 8.707a1 1 0 0 0-1.414-1.414L11 14.586l-1.293-1.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), ClipboardCheckSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardCheckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root183();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1183();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardCheckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2183();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardCheckSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardCheckSolid = hmr(ClipboardCheckSolid, () => ClipboardCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCheckSolid[HMR].source;
    set(ClipboardCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCheckSolid_default = ClipboardCheckSolid;

// node_modules/flowbite-svelte-icons/dist/ClipboardCleanOutline.svelte
ClipboardCleanOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCleanOutline.svelte";
var root_1184 = add_locations(from_svg(`<title> </title>`), ClipboardCleanOutline[FILENAME], [[43, 4]]);
var root_2184 = add_locations(from_svg(`<desc> </desc>`), ClipboardCleanOutline[FILENAME], [[46, 4]]);
var root184 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-5-4v4h4V3h-4Z"></path></svg>`), ClipboardCleanOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClipboardCleanOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardCleanOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root184();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1184();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardCleanOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2184();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardCleanOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardCleanOutline = hmr(ClipboardCleanOutline, () => ClipboardCleanOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCleanOutline[HMR].source;
    set(ClipboardCleanOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCleanOutline_default = ClipboardCleanOutline;

// node_modules/flowbite-svelte-icons/dist/ClipboardCleanSolid.svelte
ClipboardCleanSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCleanSolid.svelte";
var root_1185 = add_locations(from_svg(`<title> </title>`), ClipboardCleanSolid[FILENAME], [[41, 4]]);
var root_2185 = add_locations(from_svg(`<desc> </desc>`), ClipboardCleanSolid[FILENAME], [[44, 4]]);
var root185 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Z" clip-rule="evenodd"></path></svg>`), ClipboardCleanSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardCleanSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardCleanSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root185();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1185();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardCleanSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2185();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardCleanSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardCleanSolid = hmr(ClipboardCleanSolid, () => ClipboardCleanSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCleanSolid[HMR].source;
    set(ClipboardCleanSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCleanSolid_default = ClipboardCleanSolid;

// node_modules/flowbite-svelte-icons/dist/ClipboardListOutline.svelte
ClipboardListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardListOutline.svelte";
var root_1186 = add_locations(from_svg(`<title> </title>`), ClipboardListOutline[FILENAME], [[43, 4]]);
var root_2186 = add_locations(from_svg(`<desc> </desc>`), ClipboardListOutline[FILENAME], [[46, 4]]);
var root186 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-3 5h3m-6 0h.01M12 16h3m-6 0h.01M10 3v4h4V3h-4Z"></path></svg>`), ClipboardListOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClipboardListOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root186();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1186();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardListOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2186();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardListOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardListOutline = hmr(ClipboardListOutline, () => ClipboardListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardListOutline[HMR].source;
    set(ClipboardListOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardListOutline_default = ClipboardListOutline;

// node_modules/flowbite-svelte-icons/dist/ClipboardListSolid.svelte
ClipboardListSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardListSolid.svelte";
var root_1187 = add_locations(from_svg(`<title> </title>`), ClipboardListSolid[FILENAME], [[41, 4]]);
var root_2187 = add_locations(from_svg(`<desc> </desc>`), ClipboardListSolid[FILENAME], [[44, 4]]);
var root187 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Zm-3 8a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-2-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H9Zm2 5a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-2-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ClipboardListSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardListSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardListSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root187();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1187();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardListSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2187();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardListSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardListSolid = hmr(ClipboardListSolid, () => ClipboardListSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardListSolid[HMR].source;
    set(ClipboardListSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardListSolid_default = ClipboardListSolid;

// node_modules/flowbite-svelte-icons/dist/ClipboardOutline.svelte
ClipboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardOutline.svelte";
var root_1188 = add_locations(from_svg(`<title> </title>`), ClipboardOutline[FILENAME], [[43, 4]]);
var root_2188 = add_locations(from_svg(`<desc> </desc>`), ClipboardOutline[FILENAME], [[46, 4]]);
var root188 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-6 5h6m-6 4h6M10 3v4h4V3h-4Z"></path></svg>`), ClipboardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClipboardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root188();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1188();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2188();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardOutline = hmr(ClipboardOutline, () => ClipboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardOutline[HMR].source;
    set(ClipboardOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardOutline_default = ClipboardOutline;

// node_modules/flowbite-svelte-icons/dist/ClipboardSolid.svelte
ClipboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardSolid.svelte";
var root_1189 = add_locations(from_svg(`<title> </title>`), ClipboardSolid[FILENAME], [[41, 4]]);
var root_2189 = add_locations(from_svg(`<desc> </desc>`), ClipboardSolid[FILENAME], [[44, 4]]);
var root189 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Zm-6 8a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm1 3a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ClipboardSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClipboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root189();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1189();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClipboardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2189();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClipboardSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClipboardSolid = hmr(ClipboardSolid, () => ClipboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardSolid[HMR].source;
    set(ClipboardSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardSolid_default = ClipboardSolid;

// node_modules/flowbite-svelte-icons/dist/ClockArrowOutline.svelte
ClockArrowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClockArrowOutline.svelte";
var root_1190 = add_locations(from_svg(`<title> </title>`), ClockArrowOutline[FILENAME], [[43, 4]]);
var root_2190 = add_locations(from_svg(`<desc> </desc>`), ClockArrowOutline[FILENAME], [[46, 4]]);
var root190 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3M3.22302 14C4.13247 18.008 7.71683 21 12 21c4.9706 0 9-4.0294 9-9 0-4.97056-4.0294-9-9-9-3.72916 0-6.92858 2.26806-8.29409 5.5M7 9H3V5"></path></svg>`), ClockArrowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClockArrowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClockArrowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root190();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1190();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClockArrowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2190();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClockArrowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClockArrowOutline = hmr(ClockArrowOutline, () => ClockArrowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClockArrowOutline[HMR].source;
    set(ClockArrowOutline[HMR].source, module.default[HMR].original);
  });
}
var ClockArrowOutline_default = ClockArrowOutline;

// node_modules/flowbite-svelte-icons/dist/ClockOutline.svelte
ClockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClockOutline.svelte";
var root_1191 = add_locations(from_svg(`<title> </title>`), ClockOutline[FILENAME], [[43, 4]]);
var root_2191 = add_locations(from_svg(`<desc> </desc>`), ClockOutline[FILENAME], [[46, 4]]);
var root191 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), ClockOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ClockOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root191();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1191();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClockOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2191();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClockOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClockOutline = hmr(ClockOutline, () => ClockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClockOutline[HMR].source;
    set(ClockOutline[HMR].source, module.default[HMR].original);
  });
}
var ClockOutline_default = ClockOutline;

// node_modules/flowbite-svelte-icons/dist/ClockSolid.svelte
ClockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClockSolid.svelte";
var root_1192 = add_locations(from_svg(`<title> </title>`), ClockSolid[FILENAME], [[41, 4]]);
var root_2192 = add_locations(from_svg(`<desc> </desc>`), ClockSolid[FILENAME], [[44, 4]]);
var root192 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4a1 1 0 1 0-2 0v4a1 1 0 0 0 .293.707l3 3a1 1 0 0 0 1.414-1.414L13 11.586V8Z" clip-rule="evenodd"></path></svg>`), ClockSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ClockSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ClockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root192();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1192();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ClockSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2192();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ClockSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ClockSolid = hmr(ClockSolid, () => ClockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClockSolid[HMR].source;
    set(ClockSolid[HMR].source, module.default[HMR].original);
  });
}
var ClockSolid_default = ClockSolid;

// node_modules/flowbite-svelte-icons/dist/CloseCircleOutline.svelte
CloseCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseCircleOutline.svelte";
var root_1193 = add_locations(from_svg(`<title> </title>`), CloseCircleOutline[FILENAME], [[43, 4]]);
var root_2193 = add_locations(from_svg(`<desc> </desc>`), CloseCircleOutline[FILENAME], [[46, 4]]);
var root193 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15 9-6 6m0-6 6 6m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CloseCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloseCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root193();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1193();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2193();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseCircleOutline = hmr(CloseCircleOutline, () => CloseCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseCircleOutline[HMR].source;
    set(CloseCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseCircleOutline_default = CloseCircleOutline;

// node_modules/flowbite-svelte-icons/dist/CloseCircleSolid.svelte
CloseCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseCircleSolid.svelte";
var root_1194 = add_locations(from_svg(`<title> </title>`), CloseCircleSolid[FILENAME], [[41, 4]]);
var root_2194 = add_locations(from_svg(`<desc> </desc>`), CloseCircleSolid[FILENAME], [[44, 4]]);
var root194 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm7.707-3.707a1 1 0 0 0-1.414 1.414L10.586 12l-2.293 2.293a1 1 0 1 0 1.414 1.414L12 13.414l2.293 2.293a1 1 0 0 0 1.414-1.414L13.414 12l2.293-2.293a1 1 0 0 0-1.414-1.414L12 10.586 9.707 8.293Z" clip-rule="evenodd"></path></svg>`), CloseCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CloseCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root194();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1194();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2194();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseCircleSolid = hmr(CloseCircleSolid, () => CloseCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseCircleSolid[HMR].source;
    set(CloseCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CloseCircleSolid_default = CloseCircleSolid;

// node_modules/flowbite-svelte-icons/dist/CloseOutline.svelte
CloseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseOutline.svelte";
var root_1195 = add_locations(from_svg(`<title> </title>`), CloseOutline[FILENAME], [[43, 4]]);
var root_2195 = add_locations(from_svg(`<desc> </desc>`), CloseOutline[FILENAME], [[46, 4]]);
var root195 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 18 17.94 6M18 18 6.06 6"></path></svg>`), CloseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root195();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1195();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2195();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseOutline = hmr(CloseOutline, () => CloseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseOutline[HMR].source;
    set(CloseOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseOutline_default = CloseOutline;

// node_modules/flowbite-svelte-icons/dist/CloseSidebarAltOutline.svelte
CloseSidebarAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseSidebarAltOutline.svelte";
var root_1196 = add_locations(from_svg(`<title> </title>`), CloseSidebarAltOutline[FILENAME], [[43, 4]]);
var root_2196 = add_locations(from_svg(`<desc> </desc>`), CloseSidebarAltOutline[FILENAME], [[46, 4]]);
var root196 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.99994 10 7 11.9999l1.99994 2M12 5v14M5 4h14c.5523 0 1 .44772 1 1v14c0 .5523-.4477 1-1 1H5c-.55228 0-1-.4477-1-1V5c0-.55228.44772-1 1-1Z"></path></svg>`), CloseSidebarAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloseSidebarAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseSidebarAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root196();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1196();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseSidebarAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2196();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseSidebarAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseSidebarAltOutline = hmr(CloseSidebarAltOutline, () => CloseSidebarAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseSidebarAltOutline[HMR].source;
    set(CloseSidebarAltOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseSidebarAltOutline_default = CloseSidebarAltOutline;

// node_modules/flowbite-svelte-icons/dist/CloseSidebarAltSolid.svelte
CloseSidebarAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseSidebarAltSolid.svelte";
var root_1197 = add_locations(from_svg(`<title> </title>`), CloseSidebarAltSolid[FILENAME], [[41, 4]]);
var root_2197 = add_locations(from_svg(`<desc> </desc>`), CloseSidebarAltSolid[FILENAME], [[44, 4]]);
var root197 = add_locations(from_svg(`<svg><!><!><path d="M13 21h6c1.1046 0 2-.8954 2-2V5c0-1.10457-.8954-2-2-2h-6v18Z"></path><path fill-rule="evenodd" d="M11 3H5c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h6V3Zm-2.29295 7.7071c.39052-.3905.39052-1.02368 0-1.41421-.39053-.39052-1.02369-.39052-1.41421 0L5.29289 11.2928c-.39052.3906-.39052 1.0237 0 1.4142l1.99995 2c.39052.3905 1.02368.3905 1.41421 0 .39052-.3905.39052-1.0237 0-1.4142l-1.29284-1.2929 1.29284-1.2928Z" clip-rule="evenodd"></path></svg>`), CloseSidebarAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function CloseSidebarAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseSidebarAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root197();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1197();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseSidebarAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2197();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseSidebarAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseSidebarAltSolid = hmr(CloseSidebarAltSolid, () => CloseSidebarAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseSidebarAltSolid[HMR].source;
    set(CloseSidebarAltSolid[HMR].source, module.default[HMR].original);
  });
}
var CloseSidebarAltSolid_default = CloseSidebarAltSolid;

// node_modules/flowbite-svelte-icons/dist/CloseSidebarOutline.svelte
CloseSidebarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseSidebarOutline.svelte";
var root_1198 = add_locations(from_svg(`<title> </title>`), CloseSidebarOutline[FILENAME], [[43, 4]]);
var root_2198 = add_locations(from_svg(`<desc> </desc>`), CloseSidebarOutline[FILENAME], [[46, 4]]);
var root198 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.99994 10 6 11.9999l1.99994 2M11 5v14m-7 0h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Z"></path></svg>`), CloseSidebarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloseSidebarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseSidebarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root198();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1198();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseSidebarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2198();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseSidebarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseSidebarOutline = hmr(CloseSidebarOutline, () => CloseSidebarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseSidebarOutline[HMR].source;
    set(CloseSidebarOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseSidebarOutline_default = CloseSidebarOutline;

// node_modules/flowbite-svelte-icons/dist/CloseSidebarSolid.svelte
CloseSidebarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseSidebarSolid.svelte";
var root_1199 = add_locations(from_svg(`<title> </title>`), CloseSidebarSolid[FILENAME], [[41, 4]]);
var root_2199 = add_locations(from_svg(`<desc> </desc>`), CloseSidebarSolid[FILENAME], [[44, 4]]);
var root199 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10 4H4c-1.10457 0-2 .89543-2 2v12c0 1.1046.89543 2 2 2h6V4ZM7.79283 9.29289c.39053.39053.39053 1.02371 0 1.41421L6.5 11.9999l1.29283 1.2929c.39053.3905.39053 1.0237 0 1.4142-.39052.3905-1.02368.3905-1.41421 0l-1.99994-2c-.39052-.3905-.39052-1.0236 0-1.4142l1.99994-1.99991c.39053-.39052 1.02369-.39052 1.41421 0Z" clip-rule="evenodd"></path><path d="M12 20h8c1.1046 0 2-.8954 2-2V6c0-1.10457-.8954-2-2-2h-8v16Z"></path></svg>`), CloseSidebarSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function CloseSidebarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloseSidebarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root199();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1199();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloseSidebarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2199();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloseSidebarSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloseSidebarSolid = hmr(CloseSidebarSolid, () => CloseSidebarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseSidebarSolid[HMR].source;
    set(CloseSidebarSolid[HMR].source, module.default[HMR].original);
  });
}
var CloseSidebarSolid_default = CloseSidebarSolid;

// node_modules/flowbite-svelte-icons/dist/CloudArrowUpOutline.svelte
CloudArrowUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudArrowUpOutline.svelte";
var root_1200 = add_locations(from_svg(`<title> </title>`), CloudArrowUpOutline[FILENAME], [[43, 4]]);
var root_2200 = add_locations(from_svg(`<desc> </desc>`), CloudArrowUpOutline[FILENAME], [[46, 4]]);
var root200 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 17h3a3 3 0 0 0 0-6h-.025a5.56 5.56 0 0 0 .025-.5A5.5 5.5 0 0 0 7.207 9.021C7.137 9.017 7.071 9 7 9a4 4 0 1 0 0 8h2.167M12 19v-9m0 0-2 2m2-2 2 2"></path></svg>`), CloudArrowUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloudArrowUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloudArrowUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root200();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1200();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloudArrowUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2200();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloudArrowUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloudArrowUpOutline = hmr(CloudArrowUpOutline, () => CloudArrowUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudArrowUpOutline[HMR].source;
    set(CloudArrowUpOutline[HMR].source, module.default[HMR].original);
  });
}
var CloudArrowUpOutline_default = CloudArrowUpOutline;

// node_modules/flowbite-svelte-icons/dist/CloudArrowUpSolid.svelte
CloudArrowUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudArrowUpSolid.svelte";
var root_1201 = add_locations(from_svg(`<title> </title>`), CloudArrowUpSolid[FILENAME], [[41, 4]]);
var root_2201 = add_locations(from_svg(`<desc> </desc>`), CloudArrowUpSolid[FILENAME], [[44, 4]]);
var root201 = add_locations(from_svg(`<svg><!><!><path d="M13.383 4.076a6.5 6.5 0 0 0-6.887 3.95A5 5 0 0 0 7 18h3v-4a2 2 0 0 1-1.414-3.414l2-2a2 2 0 0 1 2.828 0l2 2A2 2 0 0 1 14 14v4h4a4 4 0 0 0 .988-7.876 6.5 6.5 0 0 0-5.605-6.048Z"></path><path d="M12.707 9.293a1 1 0 0 0-1.414 0l-2 2a1 1 0 1 0 1.414 1.414l.293-.293V19a1 1 0 1 0 2 0v-6.586l.293.293a1 1 0 0 0 1.414-1.414l-2-2Z"></path></svg>`), CloudArrowUpSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function CloudArrowUpSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloudArrowUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root201();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1201();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloudArrowUpSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2201();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloudArrowUpSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloudArrowUpSolid = hmr(CloudArrowUpSolid, () => CloudArrowUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudArrowUpSolid[HMR].source;
    set(CloudArrowUpSolid[HMR].source, module.default[HMR].original);
  });
}
var CloudArrowUpSolid_default = CloudArrowUpSolid;

// node_modules/flowbite-svelte-icons/dist/CloudMeatballOutline.svelte
CloudMeatballOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudMeatballOutline.svelte";
var root_1202 = add_locations(from_svg(`<title> </title>`), CloudMeatballOutline[FILENAME], [[43, 4]]);
var root_2202 = add_locations(from_svg(`<desc> </desc>`), CloudMeatballOutline[FILENAME], [[46, 4]]);
var root202 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.3333 14.6528c.7073 0 1.3856-.2101 1.8857-.7101.5-.5001.781-1.2493.781-1.9565 0-.7073-.281-1.3856-.781-1.8857-.5001-.50007-1.1784-.78102-1.8857-.78102h-.0222c.0133-.14755.0222-.296.0222-.44444-.0033-1.17924-.4328-2.31753-1.2092-3.20508-.7765-.88756-1.8476-1.46455-3.0159-1.62465-1.1683-.1601-2.3551.10749-3.34174.75344-.98658.64596-1.70644 1.62675-2.0269 2.76162-.06223-.00355-.12089-.01866-.184-.01866-.943 0-1.91009.36598-2.57689 1.03277C4.31188 9.24128 4 10.1543 4 11.0973c0 .943.3746 1.8473 1.0414 2.5141.45292.4529 1.01546.7711 1.62527.9285M12 14v3m0 0v3m0-3-2.12134-2.1212M12 17l2.1213 2.1214M12 17H9m3 0h3m-3 0-2.12134 2.1213M12 17l2.1213-2.1213M6 18h.01M18 18h.01"></path></svg>`), CloudMeatballOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CloudMeatballOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloudMeatballOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root202();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1202();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloudMeatballOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2202();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloudMeatballOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloudMeatballOutline = hmr(CloudMeatballOutline, () => CloudMeatballOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudMeatballOutline[HMR].source;
    set(CloudMeatballOutline[HMR].source, module.default[HMR].original);
  });
}
var CloudMeatballOutline_default = CloudMeatballOutline;

// node_modules/flowbite-svelte-icons/dist/CloudMeatballSolid.svelte
CloudMeatballSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudMeatballSolid.svelte";
var root_1203 = add_locations(from_svg(`<title> </title>`), CloudMeatballSolid[FILENAME], [[41, 4]]);
var root_2203 = add_locations(from_svg(`<desc> </desc>`), CloudMeatballSolid[FILENAME], [[44, 4]]);
var root203 = add_locations(from_svg(`<svg><!><!><path d="M5.99997 17c-.55229 0-1 .4477-1 1s.44771 1 1 1h.01c.55228 0 1-.4477 1-1s-.44772-1-1-1h-.01ZM18 17c-.5523 0-1 .4477-1 1s.4477 1 1 1h.01c.5523 0 1-.4477 1-1s-.4477-1-1-1H18Z"></path><path fill-rule="evenodd" d="M12 13c.5523 0 1 .4477 1 1v.5858l.4142-.4142c.3905-.3905 1.0237-.3905 1.4142 0 .3905.3905.3905 1.0237 0 1.4142L14.4141 16l.5859.0001c.5523 0 1 .4477 1 1s-.4478 1-1.0001 1L14.4141 18l.4143.4143c.3905.3906.3905 1.0237 0 1.4142-.3906.3906-1.0237.3905-1.4143 0L13 19.4143v.5858c0 .5522-.4477 1-1 1s-1-.4478-1-1v-.5859l-.4143.4142c-.3905.3906-1.02365.3906-1.41417 0-.39053-.3905-.39053-1.0236 0-1.4142L9.58571 18l-.58572.0001c-.55228 0-1.00001-.4477-1.00002-1-.00001-.5523.44769-1 .99998-1L9.58571 16l-.41416-.4141c-.39054-.3905-.39056-1.0237-.00005-1.4142.39052-.3905 1.0237-.3906 1.4142 0l.4143.4142V14c0-.5523.4477-1 1-1Z" clip-rule="evenodd"></path><path d="M9.21869 3.96216c1.18841-.77809 2.61801-1.10041 4.02531-.90756 1.4073.19285 2.6974.88787 3.6327 1.95696.8431.96375 1.3466 2.17293 1.4406 3.44244.6029.16797 1.1584.48908 1.6088.93946C20.6137 10.0811 21 11.0137 21 11.9862c0 .9449-.3677 1.9573-1.0739 2.6636-.6417.6416-1.4561.9281-2.2516.9899-.1439-.2824-.3312-.539-.5532-.761 0-.7677-.2929-1.5355-.8787-2.1213-.5858-.5858-1.3535-.8787-2.1213-.8787-.5429-.5429-1.2929-.8786-2.1213-.8786-.8285 0-1.5785.3358-2.12139.8787-.76778 0-1.53555.2929-2.12133.8788-.58574.5857-.87861 1.3535-.87862 2.1212-.18576.1858-.34727.3958-.47938.6249-.77455-.2033-1.48895-.6091-2.06499-1.1851C3.47996 13.4642 3 12.3055 3 11.0973c0-1.1581.38455-2.34287 1.27157-3.22989.74279-.74279 1.74607-1.18271 2.75928-1.2962.45424-1.06098 1.21293-1.97073 2.18784-2.60905Z"></path></svg>`), CloudMeatballSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [54, 2]]]]);
function CloudMeatballSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CloudMeatballSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root203();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1203();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CloudMeatballSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2203();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CloudMeatballSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CloudMeatballSolid = hmr(CloudMeatballSolid, () => CloudMeatballSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudMeatballSolid[HMR].source;
    set(CloudMeatballSolid[HMR].source, module.default[HMR].original);
  });
}
var CloudMeatballSolid_default = CloudMeatballSolid;

// node_modules/flowbite-svelte-icons/dist/CodeBranchOutline.svelte
CodeBranchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeBranchOutline.svelte";
var root_1204 = add_locations(from_svg(`<title> </title>`), CodeBranchOutline[FILENAME], [[43, 4]]);
var root_2204 = add_locations(from_svg(`<desc> </desc>`), CodeBranchOutline[FILENAME], [[46, 4]]);
var root204 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 0a4 4 0 0 1-4 4h-1a3 3 0 0 0-3 3"></path></svg>`), CodeBranchOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CodeBranchOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeBranchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root204();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1204();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeBranchOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2204();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeBranchOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeBranchOutline = hmr(CodeBranchOutline, () => CodeBranchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeBranchOutline[HMR].source;
    set(CodeBranchOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeBranchOutline_default = CodeBranchOutline;

// node_modules/flowbite-svelte-icons/dist/CodeBranchSolid.svelte
CodeBranchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeBranchSolid.svelte";
var root_1205 = add_locations(from_svg(`<title> </title>`), CodeBranchSolid[FILENAME], [[41, 4]]);
var root_2205 = add_locations(from_svg(`<desc> </desc>`), CodeBranchSolid[FILENAME], [[44, 4]]);
var root205 = add_locations(from_svg(`<svg><!><!><path d="M8 3a3 3 0 0 0-1 5.83v6.34a3.001 3.001 0 1 0 2 0V15a2 2 0 0 1 2-2h1a5.002 5.002 0 0 0 4.927-4.146A3.001 3.001 0 0 0 16 3a3 3 0 0 0-1.105 5.79A3.001 3.001 0 0 1 12 11h-1c-.729 0-1.412.195-2 .535V8.83A3.001 3.001 0 0 0 8 3Z"></path></svg>`), CodeBranchSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeBranchSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeBranchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root205();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1205();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeBranchSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2205();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeBranchSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeBranchSolid = hmr(CodeBranchSolid, () => CodeBranchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeBranchSolid[HMR].source;
    set(CodeBranchSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeBranchSolid_default = CodeBranchSolid;

// node_modules/flowbite-svelte-icons/dist/CodeForkOutline.svelte
CodeForkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeForkOutline.svelte";
var root_1206 = add_locations(from_svg(`<title> </title>`), CodeForkOutline[FILENAME], [[43, 4]]);
var root_2206 = add_locations(from_svg(`<desc> </desc>`), CodeForkOutline[FILENAME], [[46, 4]]);
var root206 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 12v4m0 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4ZM8 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 0v2a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V8m0 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path></svg>`), CodeForkOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CodeForkOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeForkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root206();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1206();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeForkOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2206();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeForkOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeForkOutline = hmr(CodeForkOutline, () => CodeForkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeForkOutline[HMR].source;
    set(CodeForkOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeForkOutline_default = CodeForkOutline;

// node_modules/flowbite-svelte-icons/dist/CodeForkSolid.svelte
CodeForkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeForkSolid.svelte";
var root_1207 = add_locations(from_svg(`<title> </title>`), CodeForkSolid[FILENAME], [[41, 4]]);
var root_2207 = add_locations(from_svg(`<desc> </desc>`), CodeForkSolid[FILENAME], [[44, 4]]);
var root207 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 6a3 3 0 1 1 4 2.83V10a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V8.83a3.001 3.001 0 1 1 2 0V10a3 3 0 0 1-3 3h-1v2.17a3.001 3.001 0 1 1-2 0V13h-1a3 3 0 0 1-3-3V8.83A3.001 3.001 0 0 1 5 6Z" clip-rule="evenodd"></path></svg>`), CodeForkSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeForkSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeForkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root207();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1207();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeForkSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2207();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeForkSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeForkSolid = hmr(CodeForkSolid, () => CodeForkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeForkSolid[HMR].source;
    set(CodeForkSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeForkSolid_default = CodeForkSolid;

// node_modules/flowbite-svelte-icons/dist/CodeMergeOutline.svelte
CodeMergeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeMergeOutline.svelte";
var root_1208 = add_locations(from_svg(`<title> </title>`), CodeMergeOutline[FILENAME], [[43, 4]]);
var root_2208 = add_locations(from_svg(`<desc> </desc>`), CodeMergeOutline[FILENAME], [[46, 4]]);
var root208 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm6-2a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm0 0h-1a5 5 0 0 1-5-5v-.5"></path></svg>`), CodeMergeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CodeMergeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeMergeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root208();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1208();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeMergeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2208();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeMergeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeMergeOutline = hmr(CodeMergeOutline, () => CodeMergeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeMergeOutline[HMR].source;
    set(CodeMergeOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeMergeOutline_default = CodeMergeOutline;

// node_modules/flowbite-svelte-icons/dist/CodeMergeSolid.svelte
CodeMergeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeMergeSolid.svelte";
var root_1209 = add_locations(from_svg(`<title> </title>`), CodeMergeSolid[FILENAME], [[41, 4]]);
var root_2209 = add_locations(from_svg(`<desc> </desc>`), CodeMergeSolid[FILENAME], [[44, 4]]);
var root209 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 6a3 3 0 1 1 4 2.83V9a4 4 0 0 0 4 4h.17a3.001 3.001 0 1 1 0 2H13a5.978 5.978 0 0 1-4-1.528v1.699a3.001 3.001 0 1 1-2 0V8.829A3.001 3.001 0 0 1 5 6Z" clip-rule="evenodd"></path></svg>`), CodeMergeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeMergeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeMergeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root209();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1209();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeMergeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2209();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeMergeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeMergeSolid = hmr(CodeMergeSolid, () => CodeMergeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeMergeSolid[HMR].source;
    set(CodeMergeSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeMergeSolid_default = CodeMergeSolid;

// node_modules/flowbite-svelte-icons/dist/CodeOutline.svelte
CodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeOutline.svelte";
var root_1210 = add_locations(from_svg(`<title> </title>`), CodeOutline[FILENAME], [[43, 4]]);
var root_2210 = add_locations(from_svg(`<desc> </desc>`), CodeOutline[FILENAME], [[46, 4]]);
var root210 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 8-4 4 4 4m8 0 4-4-4-4m-2-3-4 14"></path></svg>`), CodeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root210();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1210();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2210();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodeOutline = hmr(CodeOutline, () => CodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeOutline[HMR].source;
    set(CodeOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeOutline_default = CodeOutline;

// node_modules/flowbite-svelte-icons/dist/CodePullRequestOutline.svelte
CodePullRequestOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodePullRequestOutline.svelte";
var root_1211 = add_locations(from_svg(`<title> </title>`), CodePullRequestOutline[FILENAME], [[43, 4]]);
var root_2211 = add_locations(from_svg(`<desc> </desc>`), CodePullRequestOutline[FILENAME], [[46, 4]]);
var root211 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm12 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm0 0V9a3 3 0 0 0-3-3h-3m1.5-2-2 2 2 2"></path></svg>`), CodePullRequestOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CodePullRequestOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodePullRequestOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root211();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1211();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodePullRequestOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2211();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodePullRequestOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodePullRequestOutline = hmr(CodePullRequestOutline, () => CodePullRequestOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodePullRequestOutline[HMR].source;
    set(CodePullRequestOutline[HMR].source, module.default[HMR].original);
  });
}
var CodePullRequestOutline_default = CodePullRequestOutline;

// node_modules/flowbite-svelte-icons/dist/CodePullRequestSolid.svelte
CodePullRequestSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodePullRequestSolid.svelte";
var root_1212 = add_locations(from_svg(`<title> </title>`), CodePullRequestSolid[FILENAME], [[41, 4]]);
var root_2212 = add_locations(from_svg(`<desc> </desc>`), CodePullRequestSolid[FILENAME], [[44, 4]]);
var root212 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 6a3 3 0 1 1 4 2.83v6.34a3.001 3.001 0 1 1-2 0V8.83A3.001 3.001 0 0 1 3 6Zm11.207-2.707a1 1 0 0 1 0 1.414L13.914 5H15a4 4 0 0 1 4 4v6.17a3.001 3.001 0 1 1-2 0V9a2 2 0 0 0-2-2h-1.086l.293.293a1 1 0 0 1-1.414 1.414l-2-2a1 1 0 0 1 0-1.414l2-2a1 1 0 0 1 1.414 0Z" clip-rule="evenodd"></path></svg>`), CodePullRequestSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CodePullRequestSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CodePullRequestSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root212();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1212();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CodePullRequestSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2212();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CodePullRequestSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CodePullRequestSolid = hmr(CodePullRequestSolid, () => CodePullRequestSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodePullRequestSolid[HMR].source;
    set(CodePullRequestSolid[HMR].source, module.default[HMR].original);
  });
}
var CodePullRequestSolid_default = CodePullRequestSolid;

// node_modules/flowbite-svelte-icons/dist/CogOutline.svelte
CogOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CogOutline.svelte";
var root_1213 = add_locations(from_svg(`<title> </title>`), CogOutline[FILENAME], [[43, 4]]);
var root_2213 = add_locations(from_svg(`<desc> </desc>`), CogOutline[FILENAME], [[46, 4]]);
var root213 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 13v-2a1 1 0 0 0-1-1h-.757l-.707-1.707.535-.536a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0l-.536.535L14 4.757V4a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v.757l-1.707.707-.536-.535a1 1 0 0 0-1.414 0L4.929 6.343a1 1 0 0 0 0 1.414l.536.536L4.757 10H4a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h.757l.707 1.707-.535.536a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l.536-.535 1.707.707V20a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-.757l1.707-.708.536.536a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-.535-.536.707-1.707H20a1 1 0 0 0 1-1Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"></path></svg>`), CogOutline[FILENAME], [[31, 0, [[48, 2], [55, 2]]]]);
function CogOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CogOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root213();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1213();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CogOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2213();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CogOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CogOutline = hmr(CogOutline, () => CogOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CogOutline[HMR].source;
    set(CogOutline[HMR].source, module.default[HMR].original);
  });
}
var CogOutline_default = CogOutline;

// node_modules/flowbite-svelte-icons/dist/CogSolid.svelte
CogSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CogSolid.svelte";
var root_1214 = add_locations(from_svg(`<title> </title>`), CogSolid[FILENAME], [[41, 4]]);
var root_2214 = add_locations(from_svg(`<desc> </desc>`), CogSolid[FILENAME], [[44, 4]]);
var root214 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9.586 2.586A2 2 0 0 1 11 2h2a2 2 0 0 1 2 2v.089l.473.196.063-.063a2.002 2.002 0 0 1 2.828 0l1.414 1.414a2 2 0 0 1 0 2.827l-.063.064.196.473H20a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-.089l-.196.473.063.063a2.002 2.002 0 0 1 0 2.828l-1.414 1.414a2 2 0 0 1-2.828 0l-.063-.063-.473.196V20a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-.089l-.473-.196-.063.063a2.002 2.002 0 0 1-2.828 0l-1.414-1.414a2 2 0 0 1 0-2.827l.063-.064L4.089 15H4a2 2 0 0 1-2-2v-2a2 2 0 0 1 2-2h.09l.195-.473-.063-.063a2 2 0 0 1 0-2.828l1.414-1.414a2 2 0 0 1 2.827 0l.064.063L9 4.089V4a2 2 0 0 1 .586-1.414ZM8 12a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z" clip-rule="evenodd"></path></svg>`), CogSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CogSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CogSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root214();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1214();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CogSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2214();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CogSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CogSolid = hmr(CogSolid, () => CogSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CogSolid[HMR].source;
    set(CogSolid[HMR].source, module.default[HMR].original);
  });
}
var CogSolid_default = CogSolid;

// node_modules/flowbite-svelte-icons/dist/ColumnOutline.svelte
ColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ColumnOutline.svelte";
var root_1215 = add_locations(from_svg(`<title> </title>`), ColumnOutline[FILENAME], [[43, 4]]);
var root_2215 = add_locations(from_svg(`<desc> </desc>`), ColumnOutline[FILENAME], [[46, 4]]);
var root215 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14M9 5v14M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), ColumnOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ColumnOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root215();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1215();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ColumnOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2215();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ColumnOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ColumnOutline = hmr(ColumnOutline, () => ColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ColumnOutline[HMR].source;
    set(ColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ColumnOutline_default = ColumnOutline;

// node_modules/flowbite-svelte-icons/dist/ColumnSolid.svelte
ColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ColumnSolid.svelte";
var root_1216 = add_locations(from_svg(`<title> </title>`), ColumnSolid[FILENAME], [[41, 4]]);
var root_2216 = add_locations(from_svg(`<desc> </desc>`), ColumnSolid[FILENAME], [[44, 4]]);
var root216 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15 4H9v16h6V4Zm2 16h3a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-3v16ZM4 4h3v16H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Z" clip-rule="evenodd"></path></svg>`), ColumnSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ColumnSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root216();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1216();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ColumnSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2216();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ColumnSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ColumnSolid = hmr(ColumnSolid, () => ColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ColumnSolid[HMR].source;
    set(ColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var ColumnSolid_default = ColumnSolid;

// node_modules/flowbite-svelte-icons/dist/CommandOutline.svelte
CommandOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CommandOutline.svelte";
var root_1217 = add_locations(from_svg(`<title> </title>`), CommandOutline[FILENAME], [[43, 4]]);
var root_2217 = add_locations(from_svg(`<desc> </desc>`), CommandOutline[FILENAME], [[46, 4]]);
var root217 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8h8M8 8H6a2 2 0 1 1 2-2v2Zm0 8h8m-8 0H6a2 2 0 1 0 2 2v-2Zm8 0V8m0 8h2a2 2 0 1 1-2 2v-2Zm0-8h2a2 2 0 1 0-2-2v2Z"></path></svg>`), CommandOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CommandOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CommandOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root217();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1217();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CommandOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2217();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CommandOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CommandOutline = hmr(CommandOutline, () => CommandOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CommandOutline[HMR].source;
    set(CommandOutline[HMR].source, module.default[HMR].original);
  });
}
var CommandOutline_default = CommandOutline;

// node_modules/flowbite-svelte-icons/dist/CompressOutline.svelte
CompressOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CompressOutline.svelte";
var root_1218 = add_locations(from_svg(`<title> </title>`), CompressOutline[FILENAME], [[43, 4]]);
var root_2218 = add_locations(from_svg(`<desc> </desc>`), CompressOutline[FILENAME], [[46, 4]]);
var root218 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 8h4V4m12 4h-4V4M4 16h4v4m12-4h-4v4"></path></svg>`), CompressOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CompressOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CompressOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root218();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1218();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CompressOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2218();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CompressOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CompressOutline = hmr(CompressOutline, () => CompressOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CompressOutline[HMR].source;
    set(CompressOutline[HMR].source, module.default[HMR].original);
  });
}
var CompressOutline_default = CompressOutline;

// node_modules/flowbite-svelte-icons/dist/ComputerSpeakerOutline.svelte
ComputerSpeakerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ComputerSpeakerOutline.svelte";
var root_1219 = add_locations(from_svg(`<title> </title>`), ComputerSpeakerOutline[FILENAME], [[43, 4]]);
var root_2219 = add_locations(from_svg(`<desc> </desc>`), ComputerSpeakerOutline[FILENAME], [[46, 4]]);
var root219 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 16H5a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v1M9 12H4m8 8V9h8v11h-8Zm0 0H9m8-4a1 1 0 1 0-2 0 1 1 0 0 0 2 0Z"></path></svg>`), ComputerSpeakerOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ComputerSpeakerOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ComputerSpeakerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root219();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1219();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ComputerSpeakerOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2219();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ComputerSpeakerOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ComputerSpeakerOutline = hmr(ComputerSpeakerOutline, () => ComputerSpeakerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComputerSpeakerOutline[HMR].source;
    set(ComputerSpeakerOutline[HMR].source, module.default[HMR].original);
  });
}
var ComputerSpeakerOutline_default = ComputerSpeakerOutline;

// node_modules/flowbite-svelte-icons/dist/ComputerSpeakerSolid.svelte
ComputerSpeakerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ComputerSpeakerSolid.svelte";
var root_1220 = add_locations(from_svg(`<title> </title>`), ComputerSpeakerSolid[FILENAME], [[41, 4]]);
var root_2220 = add_locations(from_svg(`<desc> </desc>`), ComputerSpeakerSolid[FILENAME], [[44, 4]]);
var root220 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 8a1 1 0 0 0-1 1v10H9a1 1 0 1 0 0 2h11a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-8Zm4 10a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v6h6V9a3 3 0 0 1 3-3h8c.35 0 .687.06 1 .17V5a2 2 0 0 0-2-2H5Zm4 10H3v2a2 2 0 0 0 2 2h4v-4Z" clip-rule="evenodd"></path></svg>`), ComputerSpeakerSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function ComputerSpeakerSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ComputerSpeakerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root220();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1220();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ComputerSpeakerSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2220();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ComputerSpeakerSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ComputerSpeakerSolid = hmr(ComputerSpeakerSolid, () => ComputerSpeakerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComputerSpeakerSolid[HMR].source;
    set(ComputerSpeakerSolid[HMR].source, module.default[HMR].original);
  });
}
var ComputerSpeakerSolid_default = ComputerSpeakerSolid;

// node_modules/flowbite-svelte-icons/dist/CookieOutline.svelte
CookieOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CookieOutline.svelte";
var root_1221 = add_locations(from_svg(`<title> </title>`), CookieOutline[FILENAME], [[43, 4]]);
var root_2221 = add_locations(from_svg(`<desc> </desc>`), CookieOutline[FILENAME], [[46, 4]]);
var root221 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.65692 9.41494h.01M7.27103 13h.01m7.67737 1.9156h.01M10.9999 17h.01m3.178-10.90671c-.8316.38094-1.8475.22903-2.5322-.45571-.3652-.36522-.5789-.82462-.6409-1.30001-.0574-.44-.0189-.98879.1833-1.39423-1.99351.20001-3.93304 1.06362-5.46025 2.59083-3.51472 3.51472-3.51472 9.21323 0 12.72793 3.51471 3.5147 9.21315 3.5147 12.72795 0 1.5601-1.5602 2.4278-3.5507 2.6028-5.5894-.2108.008-.6725.0223-.8328.0157-.635.0644-1.2926-.1466-1.779-.633-.3566-.3566-.5651-.8051-.6257-1.2692-.0561-.4293.0145-.87193.2117-1.26755-.1159.20735-.2619.40237-.4381.57865-1.0283 1.0282-2.6953 1.0282-3.7235 0-1.0282-1.02824-1.0282-2.69531 0-3.72352.0977-.09777.2013-.18625.3095-.26543"></path></svg>`), CookieOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CookieOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CookieOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root221();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1221();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CookieOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2221();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CookieOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CookieOutline = hmr(CookieOutline, () => CookieOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CookieOutline[HMR].source;
    set(CookieOutline[HMR].source, module.default[HMR].original);
  });
}
var CookieOutline_default = CookieOutline;

// node_modules/flowbite-svelte-icons/dist/CookieSolid.svelte
CookieSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CookieSolid.svelte";
var root_1222 = add_locations(from_svg(`<title> </title>`), CookieSolid[FILENAME], [[41, 4]]);
var root_2222 = add_locations(from_svg(`<desc> </desc>`), CookieSolid[FILENAME], [[44, 4]]);
var root222 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.0212 2.37541c.2069.29981.2344.6884.0718 1.01435-.0835.16728-.1286.49646-.0866.81839.0345.26443.1525.51845.3564.72235.3798.37974.9446.46622 1.4086.25366.5022-.23 1.0957-.0094 1.3256.49272.0358.07797.0606.15815.0752.23883.0722.36885-.0676.76315-.391.99974-.067.04901-.1315.10409-.1929.16547-.6377.63769-.6377 1.67158 0 2.30927.6377.63771 1.6716.63771 2.3093 0 .1104-.11046.2008-.23148.2721-.35918.2649-.47416.8598-.65023 1.3401-.3966.4802.25363.6702.84422.428 1.33031-.1068.21428-.1459.45618-.1151.69208.033.2531.146.4962.3412.6915.265.265.622.3806.9709.3452.0473-.0048.095-.0062.1425-.0043.111.0047.5252-.0071.7534-.0158.2865-.0108.5639.1018.7617.3093.1978.2075.2971.4899.2726.7756-.1945 2.2647-1.1592 4.478-2.8921 6.2109-3.9053 3.9053-10.23692 3.9053-14.14216 0-3.90524-3.9052-3.90524-10.23686 0-14.1421C6.727 3.13084 8.88362 2.17056 11.0983 1.94837c.3624-.03636.716.12723.9229.42704ZM8.65695 8.41498c-.55229 0-1 .44771-1 1 0 .55228.44771 1.00002 1 1.00002h.01c.55228 0 1-.44774 1-1.00002 0-.55229-.44772-1-1-1h-.01ZM7.27106 12c-.55229 0-1 .4478-1 1 0 .5523.44771 1 1 1h.01c.55228 0 1-.4477 1-1 0-.5522-.44772-1-1-1h-.01Zm7.68744 1.9157c-.5523 0-1 .4477-1 1s.4477 1 1 1h.01c.5523 0 1-.4477 1-1s-.4477-1-1-1h-.01ZM11 16c-.5523 0-1.00004.4478-1.00004 1 0 .5523.44774 1 1.00004 1h.01c.5523 0 1-.4477 1-1 0-.5522-.4477-1-1-1H11Z" clip-rule="evenodd"></path></svg>`), CookieSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CookieSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CookieSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root222();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1222();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CookieSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2222();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CookieSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CookieSolid = hmr(CookieSolid, () => CookieSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CookieSolid[HMR].source;
    set(CookieSolid[HMR].source, module.default[HMR].original);
  });
}
var CookieSolid_default = CookieSolid;

// node_modules/flowbite-svelte-icons/dist/CreditCardOutline.svelte
CreditCardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardOutline.svelte";
var root_1223 = add_locations(from_svg(`<title> </title>`), CreditCardOutline[FILENAME], [[43, 4]]);
var root_2223 = add_locations(from_svg(`<desc> </desc>`), CreditCardOutline[FILENAME], [[46, 4]]);
var root223 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M6 14h2m3 0h5M3 7v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1Z"></path></svg>`), CreditCardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CreditCardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root223();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1223();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2223();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardOutline = hmr(CreditCardOutline, () => CreditCardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardOutline[HMR].source;
    set(CreditCardOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardOutline_default = CreditCardOutline;

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltOutline.svelte
CreditCardPlusAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltOutline.svelte";
var root_1224 = add_locations(from_svg(`<title> </title>`), CreditCardPlusAltOutline[FILENAME], [[43, 4]]);
var root_2224 = add_locations(from_svg(`<desc> </desc>`), CreditCardPlusAltOutline[FILENAME], [[46, 4]]);
var root224 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 14h2m3 0h4m2 2h2m0 0h2m-2 0v2m0-2v-2m-5 4H4c-.55228 0-1-.4477-1-1V7c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v4M3 10h18"></path></svg>`), CreditCardPlusAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CreditCardPlusAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardPlusAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root224();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1224();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardPlusAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2224();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardPlusAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardPlusAltOutline = hmr(CreditCardPlusAltOutline, () => CreditCardPlusAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusAltOutline[HMR].source;
    set(CreditCardPlusAltOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusAltOutline_default = CreditCardPlusAltOutline;

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltSolid.svelte
CreditCardPlusAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltSolid.svelte";
var root_1225 = add_locations(from_svg(`<title> </title>`), CreditCardPlusAltSolid[FILENAME], [[41, 4]]);
var root_2225 = add_locations(from_svg(`<desc> </desc>`), CreditCardPlusAltSolid[FILENAME], [[44, 4]]);
var root225 = add_locations(from_svg(`<svg><!><!><path d="M2 7c0-1.10457.89543-2 2-2h16c1.1046 0 2 .89543 2 2v4c0 .5523-.4477 1-1 1s-1-.4477-1-1v-1H4v7h10c.5523 0 1 .4477 1 1s-.4477 1-1 1H4c-1.10457 0-2-.8954-2-2V7Z"></path><path d="M5 14c0-.5523.44772-1 1-1h2c.55228 0 1 .4477 1 1s-.44772 1-1 1H6c-.55228 0-1-.4477-1-1Zm5 0c0-.5523.4477-1 1-1h4c.5523 0 1 .4477 1 1s-.4477 1-1 1h-4c-.5523 0-1-.4477-1-1Zm9-1c.5523 0 1 .4477 1 1v1h1c.5523 0 1 .4477 1 1s-.4477 1-1 1h-1v1c0 .5523-.4477 1-1 1s-1-.4477-1-1v-1h-1c-.5523 0-1-.4477-1-1s.4477-1 1-1h1v-1c0-.5523.4477-1 1-1Z"></path></svg>`), CreditCardPlusAltSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function CreditCardPlusAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardPlusAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root225();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1225();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardPlusAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2225();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardPlusAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardPlusAltSolid = hmr(CreditCardPlusAltSolid, () => CreditCardPlusAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusAltSolid[HMR].source;
    set(CreditCardPlusAltSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusAltSolid_default = CreditCardPlusAltSolid;

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusOutline.svelte
CreditCardPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusOutline.svelte";
var root_1226 = add_locations(from_svg(`<title> </title>`), CreditCardPlusOutline[FILENAME], [[43, 4]]);
var root_2226 = add_locations(from_svg(`<desc> </desc>`), CreditCardPlusOutline[FILENAME], [[46, 4]]);
var root226 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M16.5 15v1.5m0 0V18m0-1.5H15m1.5 0H18M3 9V6a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v3M3 9v6a1 1 0 0 0 1 1h5M3 9h16m0 0v1M6 12h3m12 4.5a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z"></path></svg>`), CreditCardPlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CreditCardPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root226();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1226();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardPlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2226();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardPlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardPlusOutline = hmr(CreditCardPlusOutline, () => CreditCardPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusOutline[HMR].source;
    set(CreditCardPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusOutline_default = CreditCardPlusOutline;

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusSolid.svelte
CreditCardPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusSolid.svelte";
var root_1227 = add_locations(from_svg(`<title> </title>`), CreditCardPlusSolid[FILENAME], [[41, 4]]);
var root_2227 = add_locations(from_svg(`<desc> </desc>`), CreditCardPlusSolid[FILENAME], [[44, 4]]);
var root227 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11 16.5a5.5 5.5 0 1 1 11 0 5.5 5.5 0 0 1-11 0Zm4.5 2.5v-1.5H14v-2h1.5V14h2v1.5H19v2h-1.5V19h-2Z" clip-rule="evenodd"></path><path d="M3.987 4A2 2 0 0 0 2 6v9a2 2 0 0 0 2 2h5v-2H4v-5h16V6a2 2 0 0 0-2-2H3.987Z"></path><path fill-rule="evenodd" d="M5 12a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CreditCardPlusSolid[FILENAME], [[30, 0, [[46, 2], [50, 5], [51, 2]]]]);
function CreditCardPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root227();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1227();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2227();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardPlusSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardPlusSolid = hmr(CreditCardPlusSolid, () => CreditCardPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusSolid[HMR].source;
    set(CreditCardPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusSolid_default = CreditCardPlusSolid;

// node_modules/flowbite-svelte-icons/dist/CreditCardSolid.svelte
CreditCardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardSolid.svelte";
var root_1228 = add_locations(from_svg(`<title> </title>`), CreditCardSolid[FILENAME], [[41, 4]]);
var root_2228 = add_locations(from_svg(`<desc> </desc>`), CreditCardSolid[FILENAME], [[44, 4]]);
var root228 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H4Zm0 6h16v6H4v-6Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M5 14a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm5 0a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CreditCardSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function CreditCardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CreditCardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root228();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1228();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CreditCardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2228();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CreditCardSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CreditCardSolid = hmr(CreditCardSolid, () => CreditCardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardSolid[HMR].source;
    set(CreditCardSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardSolid_default = CreditCardSolid;

// node_modules/flowbite-svelte-icons/dist/CssSolid.svelte
CssSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CssSolid.svelte";
var root_1229 = add_locations(from_svg(`<title> </title>`), CssSolid[FILENAME], [[41, 4]]);
var root_2229 = add_locations(from_svg(`<desc> </desc>`), CssSolid[FILENAME], [[44, 4]]);
var root229 = add_locations(from_svg(`<svg><!><!><path d="m3 2 1.578 17.834L12 22l7.468-2.165L21 2H3Zm13.3 14.722-4.293 1.204H12l-4.297-1.204-.297-3.167h2.108l.15 1.526 2.335.639 2.34-.64.245-3.05h-7.27l-.187-2.006h7.64l.174-2.006H6.924l-.176-2.006h10.506l-.954 10.71Z"></path></svg>`), CssSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CssSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CssSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root229();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1229();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CssSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2229();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CssSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CssSolid = hmr(CssSolid, () => CssSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CssSolid[HMR].source;
    set(CssSolid[HMR].source, module.default[HMR].original);
  });
}
var CssSolid_default = CssSolid;

// node_modules/flowbite-svelte-icons/dist/CubeSolid.svelte
CubeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CubeSolid.svelte";
var root_1230 = add_locations(from_svg(`<title> </title>`), CubeSolid[FILENAME], [[41, 4]]);
var root_2230 = add_locations(from_svg(`<desc> </desc>`), CubeSolid[FILENAME], [[44, 4]]);
var root230 = add_locations(from_svg(`<svg><!><!><path d="M9.98189 4.50602c1.24881-.67469 2.78741-.67469 4.03621 0l3.9638 2.14148c.3634.19632.6862.44109.9612.72273l-6.9288 3.60207L5.20654 7.225c.2403-.22108.51215-.41573.81157-.5775l3.96378-2.14148ZM4.16678 8.84364C4.05757 9.18783 4 9.5493 4 9.91844v4.28296c0 1.3494.7693 2.5963 2.01811 3.2709l3.96378 2.1415c.32051.1732.66011.3019 1.00901.3862v-7.4L4.16678 8.84364ZM13.009 20c.3489-.0843.6886-.213 1.0091-.3862l3.9638-2.1415C19.2307 16.7977 20 15.5508 20 14.2014V9.91844c0-.30001-.038-.59496-.1109-.87967L13.009 12.6155V20Z"></path></svg>`), CubeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CubeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CubeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root230();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1230();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CubeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2230();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CubeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CubeSolid = hmr(CubeSolid, () => CubeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubeSolid[HMR].source;
    set(CubeSolid[HMR].source, module.default[HMR].original);
  });
}
var CubeSolid_default = CubeSolid;

// node_modules/flowbite-svelte-icons/dist/CubesStackedOutline.svelte
CubesStackedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CubesStackedOutline.svelte";
var root_1231 = add_locations(from_svg(`<title> </title>`), CubesStackedOutline[FILENAME], [[43, 4]]);
var root_2231 = add_locations(from_svg(`<desc> </desc>`), CubesStackedOutline[FILENAME], [[46, 4]]);
var root231 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.99999 10.8571 12 13.1428m-4.00001-2.2857L4 13.1428m3.99999-2.2857.00004-4.57139M12 13.1428v4.5715m0-4.5715-4.00001 2.2857M12 13.1428l4-2.2857m-4 2.2857V8.57143m0 4.57137 4 2.2858m-4 2.2857L7.99999 20M12 17.7143 16 20m-8.00001 0L4 17.7143v-4.5715M7.99999 20v-4.5715M4 13.1428l3.99999 2.2857M16 6.28571 12 4 8.00003 6.28571m7.99997 0v4.57139m0-4.57139-4 2.28572m4 2.28567 4 2.2858M8.00003 6.28571 12 8.57143m8 4.57147v4.5714L16 20m4-6.8571-4 2.2857M16 20v-4.5714"></path></svg>`), CubesStackedOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function CubesStackedOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CubesStackedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root231();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1231();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CubesStackedOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2231();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CubesStackedOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CubesStackedOutline = hmr(CubesStackedOutline, () => CubesStackedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubesStackedOutline[HMR].source;
    set(CubesStackedOutline[HMR].source, module.default[HMR].original);
  });
}
var CubesStackedOutline_default = CubesStackedOutline;

// node_modules/flowbite-svelte-icons/dist/CubesStackedSolid.svelte
CubesStackedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CubesStackedSolid.svelte";
var root_1232 = add_locations(from_svg(`<title> </title>`), CubesStackedSolid[FILENAME], [[41, 4]]);
var root_2232 = add_locations(from_svg(`<desc> </desc>`), CubesStackedSolid[FILENAME], [[44, 4]]);
var root232 = add_locations(from_svg(`<svg><!><!><path d="M11.5039 3.13176c.3074-.17568.6848-.17568.9923 0l3.5554 2.0317L12 7.42604 7.94841 5.16346l3.55549-2.0317Zm-4.50388 3.7928L7 10.2768l-3.15822 1.8047 4.14118 2.205L11 12.5625V9.15832L7.00002 6.92456ZM3 13.8991v3.8152c0 .3588.19229.6902.50386.8682l3.49615 1.9978V16.029L3 13.8991Zm6.00001 6.6812L12 18.866l3 1.7143v-4.5714l-3-1.7143-2.99999 1.7142v4.5715Zm7.99999 0 3.4961-1.9978c.3116-.178.5039-.5094.5039-.8682v-3.8152l-4 2.1299v4.5513Zm3.1582-8.4988L17 10.2768V6.92457l-4 2.23375v3.40418l3.0171 1.724 4.1411-2.205Z"></path></svg>`), CubesStackedSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function CubesStackedSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, CubesStackedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root232();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1232();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      CubesStackedSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2232();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      CubesStackedSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  CubesStackedSolid = hmr(CubesStackedSolid, () => CubesStackedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubesStackedSolid[HMR].source;
    set(CubesStackedSolid[HMR].source, module.default[HMR].original);
  });
}
var CubesStackedSolid_default = CubesStackedSolid;

// node_modules/flowbite-svelte-icons/dist/DatabaseOutline.svelte
DatabaseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DatabaseOutline.svelte";
var root_1233 = add_locations(from_svg(`<title> </title>`), DatabaseOutline[FILENAME], [[43, 4]]);
var root_2233 = add_locations(from_svg(`<desc> </desc>`), DatabaseOutline[FILENAME], [[46, 4]]);
var root233 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 6c0 1.657-3.134 3-7 3S5 7.657 5 6m14 0c0-1.657-3.134-3-7-3S5 4.343 5 6m14 0v6M5 6v6m0 0c0 1.657 3.134 3 7 3s7-1.343 7-3M5 12v6c0 1.657 3.134 3 7 3s7-1.343 7-3v-6"></path></svg>`), DatabaseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DatabaseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DatabaseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root233();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1233();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DatabaseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2233();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DatabaseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DatabaseOutline = hmr(DatabaseOutline, () => DatabaseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatabaseOutline[HMR].source;
    set(DatabaseOutline[HMR].source, module.default[HMR].original);
  });
}
var DatabaseOutline_default = DatabaseOutline;

// node_modules/flowbite-svelte-icons/dist/DatabaseSolid.svelte
DatabaseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DatabaseSolid.svelte";
var root_1234 = add_locations(from_svg(`<title> </title>`), DatabaseSolid[FILENAME], [[41, 4]]);
var root_2234 = add_locations(from_svg(`<desc> </desc>`), DatabaseSolid[FILENAME], [[44, 4]]);
var root234 = add_locations(from_svg(`<svg><!><!><path d="M12 7.205c4.418 0 8-1.165 8-2.602C20 3.165 16.418 2 12 2S4 3.165 4 4.603c0 1.437 3.582 2.602 8 2.602ZM12 22c4.963 0 8-1.686 8-2.603v-4.404c-.052.032-.112.06-.165.09a7.75 7.75 0 0 1-.745.387c-.193.088-.394.173-.6.253-.063.024-.124.05-.189.073a18.934 18.934 0 0 1-6.3.998c-2.135.027-4.26-.31-6.3-.998-.065-.024-.126-.05-.189-.073a10.143 10.143 0 0 1-.852-.373 7.75 7.75 0 0 1-.493-.267c-.053-.03-.113-.058-.165-.09v4.404C4 20.315 7.037 22 12 22Zm7.09-13.928a9.91 9.91 0 0 1-.6.253c-.063.025-.124.05-.189.074a18.935 18.935 0 0 1-6.3.998c-2.135.027-4.26-.31-6.3-.998-.065-.024-.126-.05-.189-.074a10.163 10.163 0 0 1-.852-.372 7.816 7.816 0 0 1-.493-.268c-.055-.03-.115-.058-.167-.09V12c0 .917 3.037 2.603 8 2.603s8-1.686 8-2.603V7.596c-.052.031-.112.059-.165.09a7.816 7.816 0 0 1-.745.386Z"></path></svg>`), DatabaseSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function DatabaseSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DatabaseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root234();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1234();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DatabaseSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2234();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DatabaseSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DatabaseSolid = hmr(DatabaseSolid, () => DatabaseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatabaseSolid[HMR].source;
    set(DatabaseSolid[HMR].source, module.default[HMR].original);
  });
}
var DatabaseSolid_default = DatabaseSolid;

// node_modules/flowbite-svelte-icons/dist/DeleteColumnOutline.svelte
DeleteColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteColumnOutline.svelte";
var root_1235 = add_locations(from_svg(`<title> </title>`), DeleteColumnOutline[FILENAME], [[43, 4]]);
var root_2235 = add_locations(from_svg(`<desc> </desc>`), DeleteColumnOutline[FILENAME], [[46, 4]]);
var root235 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 5v14m-6-8h6m-6 4h6m4.506-1.494L15.012 12m0 0 1.506-1.506M15.012 12l1.506 1.506M15.012 12l-1.506-1.506M20 19H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1Z"></path></svg>`), DeleteColumnOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DeleteColumnOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DeleteColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root235();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1235();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DeleteColumnOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2235();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DeleteColumnOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DeleteColumnOutline = hmr(DeleteColumnOutline, () => DeleteColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteColumnOutline[HMR].source;
    set(DeleteColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteColumnOutline_default = DeleteColumnOutline;

// node_modules/flowbite-svelte-icons/dist/DeleteRowOutline.svelte
DeleteRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteRowOutline.svelte";
var root_1236 = add_locations(from_svg(`<title> </title>`), DeleteRowOutline[FILENAME], [[43, 4]]);
var root_2236 = add_locations(from_svg(`<desc> </desc>`), DeleteRowOutline[FILENAME], [[46, 4]]);
var root236 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-5.5061-7.4939L12 10m0 0 1.5061-1.50614M12 10l1.5061 1.5061M12 10l-1.5061-1.50614"></path></svg>`), DeleteRowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DeleteRowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DeleteRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root236();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1236();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DeleteRowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2236();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DeleteRowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DeleteRowOutline = hmr(DeleteRowOutline, () => DeleteRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteRowOutline[HMR].source;
    set(DeleteRowOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteRowOutline_default = DeleteRowOutline;

// node_modules/flowbite-svelte-icons/dist/DeleteTableOutline.svelte
DeleteTableOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteTableOutline.svelte";
var root_1237 = add_locations(from_svg(`<title> </title>`), DeleteTableOutline[FILENAME], [[43, 4]]);
var root_2237 = add_locations(from_svg(`<desc> </desc>`), DeleteTableOutline[FILENAME], [[46, 4]]);
var root237 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10.5M3 15v-4m0 4h11M3 11V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5M3 11h18m0 0v1M8 11v8m4-8v8m4-8v2m1.8956 5.9528 1.5047-1.5047m0 0 1.5048-1.5048m-1.5048 1.5048 1.4605 1.4604m-1.4605-1.4604-1.4604-1.4605"></path></svg>`), DeleteTableOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DeleteTableOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DeleteTableOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root237();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1237();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DeleteTableOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2237();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DeleteTableOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DeleteTableOutline = hmr(DeleteTableOutline, () => DeleteTableOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteTableOutline[HMR].source;
    set(DeleteTableOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteTableOutline_default = DeleteTableOutline;

// node_modules/flowbite-svelte-icons/dist/DesktopPcOutline.svelte
DesktopPcOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DesktopPcOutline.svelte";
var root_1238 = add_locations(from_svg(`<title> </title>`), DesktopPcOutline[FILENAME], [[43, 4]]);
var root_2238 = add_locations(from_svg(`<desc> </desc>`), DesktopPcOutline[FILENAME], [[46, 4]]);
var root238 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15v5m-3 0h6M4 11h16M5 15h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1Z"></path></svg>`), DesktopPcOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DesktopPcOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DesktopPcOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root238();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1238();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DesktopPcOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2238();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DesktopPcOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DesktopPcOutline = hmr(DesktopPcOutline, () => DesktopPcOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DesktopPcOutline[HMR].source;
    set(DesktopPcOutline[HMR].source, module.default[HMR].original);
  });
}
var DesktopPcOutline_default = DesktopPcOutline;

// node_modules/flowbite-svelte-icons/dist/DesktopPcSolid.svelte
DesktopPcSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DesktopPcSolid.svelte";
var root_1239 = add_locations(from_svg(`<title> </title>`), DesktopPcSolid[FILENAME], [[41, 4]]);
var root_2239 = add_locations(from_svg(`<desc> </desc>`), DesktopPcSolid[FILENAME], [[44, 4]]);
var root239 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v5h18V5a2 2 0 0 0-2-2H5ZM3 14v-2h18v2a2 2 0 0 1-2 2h-6v3h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2v-3H5a2 2 0 0 1-2-2Z" clip-rule="evenodd"></path></svg>`), DesktopPcSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function DesktopPcSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DesktopPcSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root239();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1239();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DesktopPcSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2239();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DesktopPcSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DesktopPcSolid = hmr(DesktopPcSolid, () => DesktopPcSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DesktopPcSolid[HMR].source;
    set(DesktopPcSolid[HMR].source, module.default[HMR].original);
  });
}
var DesktopPcSolid_default = DesktopPcSolid;

// node_modules/flowbite-svelte-icons/dist/DiscordSolid.svelte
DiscordSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DiscordSolid.svelte";
var root_1240 = add_locations(from_svg(`<title> </title>`), DiscordSolid[FILENAME], [[41, 4]]);
var root_2240 = add_locations(from_svg(`<desc> </desc>`), DiscordSolid[FILENAME], [[44, 4]]);
var root240 = add_locations(from_svg(`<svg><!><!><path d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z"></path></svg>`), DiscordSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function DiscordSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DiscordSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root240();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1240();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DiscordSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2240();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DiscordSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DiscordSolid = hmr(DiscordSolid, () => DiscordSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DiscordSolid[HMR].source;
    set(DiscordSolid[HMR].source, module.default[HMR].original);
  });
}
var DiscordSolid_default = DiscordSolid;

// node_modules/flowbite-svelte-icons/dist/DnaOutline.svelte
DnaOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DnaOutline.svelte";
var root_1241 = add_locations(from_svg(`<title> </title>`), DnaOutline[FILENAME], [[43, 4]]);
var root_2241 = add_locations(from_svg(`<desc> </desc>`), DnaOutline[FILENAME], [[46, 4]]);
var root241 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.041 13.862A4.999 4.999 0 0 1 17 17.831V21M7 3v3.169a5 5 0 0 0 1.891 3.916M17 3v3.169a5 5 0 0 1-2.428 4.288l-5.144 3.086A5 5 0 0 0 7 17.831V21M7 5h10M7.399 8h9.252M8 16h8.652M7 19h10"></path></svg>`), DnaOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DnaOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DnaOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root241();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1241();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DnaOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2241();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DnaOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DnaOutline = hmr(DnaOutline, () => DnaOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DnaOutline[HMR].source;
    set(DnaOutline[HMR].source, module.default[HMR].original);
  });
}
var DnaOutline_default = DnaOutline;

// node_modules/flowbite-svelte-icons/dist/DollarOutline.svelte
DollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DollarOutline.svelte";
var root_1242 = add_locations(from_svg(`<title> </title>`), DollarOutline[FILENAME], [[43, 4]]);
var root_2242 = add_locations(from_svg(`<desc> </desc>`), DollarOutline[FILENAME], [[46, 4]]);
var root242 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 17.345a4.76 4.76 0 0 0 2.558 1.618c2.274.589 4.512-.446 4.999-2.31.487-1.866-1.273-3.9-3.546-4.49-2.273-.59-4.034-2.623-3.547-4.488.486-1.865 2.724-2.899 4.998-2.31.982.236 1.87.793 2.538 1.592m-3.879 12.171V21m0-18v2.2"></path></svg>`), DollarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DollarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root242();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1242();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DollarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2242();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DollarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DollarOutline = hmr(DollarOutline, () => DollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DollarOutline[HMR].source;
    set(DollarOutline[HMR].source, module.default[HMR].original);
  });
}
var DollarOutline_default = DollarOutline;

// node_modules/flowbite-svelte-icons/dist/DotsHorizontalOutline.svelte
DotsHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DotsHorizontalOutline.svelte";
var root_1243 = add_locations(from_svg(`<title> </title>`), DotsHorizontalOutline[FILENAME], [[43, 4]]);
var root_2243 = add_locations(from_svg(`<desc> </desc>`), DotsHorizontalOutline[FILENAME], [[46, 4]]);
var root243 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M6 12h.01m6 0h.01m5.99 0h.01"></path></svg>`), DotsHorizontalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DotsHorizontalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DotsHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root243();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1243();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DotsHorizontalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2243();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DotsHorizontalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DotsHorizontalOutline = hmr(DotsHorizontalOutline, () => DotsHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DotsHorizontalOutline[HMR].source;
    set(DotsHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var DotsHorizontalOutline_default = DotsHorizontalOutline;

// node_modules/flowbite-svelte-icons/dist/DotsVerticalOutline.svelte
DotsVerticalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DotsVerticalOutline.svelte";
var root_1244 = add_locations(from_svg(`<title> </title>`), DotsVerticalOutline[FILENAME], [[43, 4]]);
var root_2244 = add_locations(from_svg(`<desc> </desc>`), DotsVerticalOutline[FILENAME], [[46, 4]]);
var root244 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M12 6h.01M12 12h.01M12 18h.01"></path></svg>`), DotsVerticalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DotsVerticalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DotsVerticalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root244();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1244();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DotsVerticalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2244();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DotsVerticalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DotsVerticalOutline = hmr(DotsVerticalOutline, () => DotsVerticalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DotsVerticalOutline[HMR].source;
    set(DotsVerticalOutline[HMR].source, module.default[HMR].original);
  });
}
var DotsVerticalOutline_default = DotsVerticalOutline;

// node_modules/flowbite-svelte-icons/dist/DownloadOutline.svelte
DownloadOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DownloadOutline.svelte";
var root_1245 = add_locations(from_svg(`<title> </title>`), DownloadOutline[FILENAME], [[43, 4]]);
var root_2245 = add_locations(from_svg(`<desc> </desc>`), DownloadOutline[FILENAME], [[46, 4]]);
var root245 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13V4M7 14H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-2m-1-5-4 5-4-5m9 8h.01"></path></svg>`), DownloadOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DownloadOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DownloadOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root245();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1245();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DownloadOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2245();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DownloadOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DownloadOutline = hmr(DownloadOutline, () => DownloadOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DownloadOutline[HMR].source;
    set(DownloadOutline[HMR].source, module.default[HMR].original);
  });
}
var DownloadOutline_default = DownloadOutline;

// node_modules/flowbite-svelte-icons/dist/DownloadSolid.svelte
DownloadSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DownloadSolid.svelte";
var root_1246 = add_locations(from_svg(`<title> </title>`), DownloadSolid[FILENAME], [[41, 4]]);
var root_2246 = add_locations(from_svg(`<desc> </desc>`), DownloadSolid[FILENAME], [[44, 4]]);
var root246 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13 11.15V4a1 1 0 1 0-2 0v7.15L8.78 8.374a1 1 0 1 0-1.56 1.25l4 5a1 1 0 0 0 1.56 0l4-5a1 1 0 1 0-1.56-1.25L13 11.15Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M9.657 15.874 7.358 13H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-2.358l-2.3 2.874a3 3 0 0 1-4.685 0ZM17 16a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), DownloadSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function DownloadSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DownloadSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root246();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1246();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DownloadSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2246();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DownloadSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DownloadSolid = hmr(DownloadSolid, () => DownloadSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DownloadSolid[HMR].source;
    set(DownloadSolid[HMR].source, module.default[HMR].original);
  });
}
var DownloadSolid_default = DownloadSolid;

// node_modules/flowbite-svelte-icons/dist/DrawSquareOutline.svelte
DrawSquareOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrawSquareOutline.svelte";
var root_1247 = add_locations(from_svg(`<title> </title>`), DrawSquareOutline[FILENAME], [[43, 4]]);
var root_2247 = add_locations(from_svg(`<desc> </desc>`), DrawSquareOutline[FILENAME], [[46, 4]]);
var root247 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 6.5h2M11 18h2m-7-5v-2m12 2v-2M5 8h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm0 12h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm12 0h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm0-12h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Z"></path></svg>`), DrawSquareOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DrawSquareOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DrawSquareOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root247();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1247();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DrawSquareOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2247();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DrawSquareOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DrawSquareOutline = hmr(DrawSquareOutline, () => DrawSquareOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrawSquareOutline[HMR].source;
    set(DrawSquareOutline[HMR].source, module.default[HMR].original);
  });
}
var DrawSquareOutline_default = DrawSquareOutline;

// node_modules/flowbite-svelte-icons/dist/DrawSquareSolid.svelte
DrawSquareSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrawSquareSolid.svelte";
var root_1248 = add_locations(from_svg(`<title> </title>`), DrawSquareSolid[FILENAME], [[41, 4]]);
var root_2248 = add_locations(from_svg(`<desc> </desc>`), DrawSquareSolid[FILENAME], [[44, 4]]);
var root248 = add_locations(from_svg(`<svg><!><!><path d="M5 3a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5Zm0 12a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H5Zm12 0a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2Zm0-12a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-2Z"></path><path fill-rule="evenodd" d="M10 6.5a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2h-2a1 1 0 0 1-1-1ZM10 18a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2h-2a1 1 0 0 1-1-1Zm-4-4a1 1 0 0 1-1-1v-2a1 1 0 1 1 2 0v2a1 1 0 0 1-1 1Zm12 0a1 1 0 0 1-1-1v-2a1 1 0 1 1 2 0v2a1 1 0 0 1-1 1Z" clip-rule="evenodd"></path></svg>`), DrawSquareSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function DrawSquareSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DrawSquareSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root248();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1248();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DrawSquareSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2248();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DrawSquareSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DrawSquareSolid = hmr(DrawSquareSolid, () => DrawSquareSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrawSquareSolid[HMR].source;
    set(DrawSquareSolid[HMR].source, module.default[HMR].original);
  });
}
var DrawSquareSolid_default = DrawSquareSolid;

// node_modules/flowbite-svelte-icons/dist/DribbbleSolid.svelte
DribbbleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DribbbleSolid.svelte";
var root_1249 = add_locations(from_svg(`<title> </title>`), DribbbleSolid[FILENAME], [[41, 4]]);
var root_2249 = add_locations(from_svg(`<desc> </desc>`), DribbbleSolid[FILENAME], [[44, 4]]);
var root249 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2a10 10 0 1 0 10 10A10.009 10.009 0 0 0 12 2Zm6.613 4.614a8.523 8.523 0 0 1 1.93 5.32 20.093 20.093 0 0 0-5.949-.274c-.059-.149-.122-.292-.184-.441a23.879 23.879 0 0 0-.566-1.239 11.41 11.41 0 0 0 4.769-3.366ZM10 3.707a8.82 8.82 0 0 1 2-.238 8.5 8.5 0 0 1 5.664 2.152 9.608 9.608 0 0 1-4.476 3.087A45.755 45.755 0 0 0 10 3.707Zm-6.358 6.555a8.57 8.57 0 0 1 4.73-5.981 53.99 53.99 0 0 1 3.168 4.941 32.078 32.078 0 0 1-7.9 1.04h.002Zm2.01 7.46a8.51 8.51 0 0 1-2.2-5.707v-.262a31.641 31.641 0 0 0 8.777-1.219c.243.477.477.964.692 1.449-.114.032-.227.067-.336.1a13.569 13.569 0 0 0-6.942 5.636l.009.003ZM12 20.556a8.508 8.508 0 0 1-5.243-1.8 11.717 11.717 0 0 1 6.7-5.332.509.509 0 0 1 .055-.02 35.65 35.65 0 0 1 1.819 6.476 8.476 8.476 0 0 1-3.331.676Zm4.772-1.462A37.232 37.232 0 0 0 15.113 13a12.513 12.513 0 0 1 5.321.364 8.56 8.56 0 0 1-3.66 5.73h-.002Z" clip-rule="evenodd"></path></svg>`), DribbbleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function DribbbleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DribbbleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root249();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1249();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DribbbleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2249();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DribbbleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DribbbleSolid = hmr(DribbbleSolid, () => DribbbleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DribbbleSolid[HMR].source;
    set(DribbbleSolid[HMR].source, module.default[HMR].original);
  });
}
var DribbbleSolid_default = DribbbleSolid;

// node_modules/flowbite-svelte-icons/dist/DropboxSolid.svelte
DropboxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropboxSolid.svelte";
var root_1250 = add_locations(from_svg(`<title> </title>`), DropboxSolid[FILENAME], [[41, 4]]);
var root_2250 = add_locations(from_svg(`<desc> </desc>`), DropboxSolid[FILENAME], [[44, 4]]);
var root250 = add_locations(from_svg(`<svg><!><!><path d="M12.013 6.175 7.006 9.369l5.007 3.194-5.007 3.193L2 12.545l5.006-3.193L2 6.175l5.006-3.194 5.007 3.194ZM6.981 17.806l5.006-3.193 5.006 3.193L11.987 21l-5.006-3.194Z"></path><path d="m12.013 12.545 5.006-3.194-5.006-3.176 4.98-3.194L22 6.175l-5.007 3.194L22 12.562l-5.007 3.194-4.98-3.211Z"></path></svg>`), DropboxSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function DropboxSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DropboxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root250();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1250();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DropboxSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2250();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DropboxSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DropboxSolid = hmr(DropboxSolid, () => DropboxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropboxSolid[HMR].source;
    set(DropboxSolid[HMR].source, module.default[HMR].original);
  });
}
var DropboxSolid_default = DropboxSolid;

// node_modules/flowbite-svelte-icons/dist/DropletBottleAltOutline.svelte
DropletBottleAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropletBottleAltOutline.svelte";
var root_1251 = add_locations(from_svg(`<title> </title>`), DropletBottleAltOutline[FILENAME], [[43, 4]]);
var root_2251 = add_locations(from_svg(`<desc> </desc>`), DropletBottleAltOutline[FILENAME], [[46, 4]]);
var root251 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 6v2.5C10 9 7 9.75 7 12v7c0 .9375 0 2 2.14286 2h5.71424C17 21 17 19.9375 17 19v-7c0-2.25-3-3-3-3.5V6m-4 0H9V3h6v3h-1m-4 0h4m0 10c0 1.1046-.8954 2-2 2s-2-.8954-2-2c0-1.5 1.7874-4 2-4 .2126 0 2 2.5 2 4Z"></path></svg>`), DropletBottleAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DropletBottleAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DropletBottleAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root251();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1251();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DropletBottleAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2251();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DropletBottleAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DropletBottleAltOutline = hmr(DropletBottleAltOutline, () => DropletBottleAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropletBottleAltOutline[HMR].source;
    set(DropletBottleAltOutline[HMR].source, module.default[HMR].original);
  });
}
var DropletBottleAltOutline_default = DropletBottleAltOutline;

// node_modules/flowbite-svelte-icons/dist/DropletBottleAltSolid.svelte
DropletBottleAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropletBottleAltSolid.svelte";
var root_1252 = add_locations(from_svg(`<title> </title>`), DropletBottleAltSolid[FILENAME], [[41, 4]]);
var root_2252 = add_locations(from_svg(`<desc> </desc>`), DropletBottleAltSolid[FILENAME], [[44, 4]]);
var root252 = add_locations(from_svg(`<svg><!><!><path d="M12 11c-.2299 0-.4004.0774-.4693.1116-.0839.0417-.1491.0873-.1903.1184-.083.0626-.1535.1309-.2048.1837-.1071.1103-.2209.2476-.3317.3923-.2255.2944-.4919.6891-.7477 1.1281-.2554.4383-.51194.9409-.70723 1.4498-.19007.4953-.34899 1.0647-.34899 1.6161 0 1.6569 1.34312 3 3.00002 3 1.6568 0 3-1.3431 3-3 0-.5514-.1589-1.1208-.349-1.6161-.1953-.5089-.4518-1.0115-.7073-1.4498-.2557-.439-.5222-.8337-.7476-1.1281-.1109-.1447-.2246-.282-.3317-.3923-.0513-.0528-.1218-.1211-.2049-.1837-.0411-.0311-.1063-.0767-.1903-.1184C12.4003 11.0774 12.2299 11 12 11Z"></path><path fill-rule="evenodd" d="M8.99998 2c-.55228 0-1 .44772-1 1v3c0 .55228.44772 1 1 1v1.09419c-.05797.03621-.12962.07946-.21086.12849-.24044.14511-.56485.34091-.86716.55505C7.10458 9.35671 5.99998 10.3674 5.99998 12v7l-.00021.0705c-.00185.4157-.00535 1.2054.44872 1.8544C6.99323 21.7034 7.94156 22 9.14284 22h5.71426c1.2013 0 2.1496-.2966 2.6944-1.0751.454-.649.4505-1.4387.4487-1.8544L18 19v-7c0-1.6326-1.1046-2.64329-1.922-3.22227-.3023-.21414-.6267-.40994-.8672-.55505-.0811-.04899-.1529-.0923-.2108-.12849V7c.5523 0 1-.44772 1-1V3c0-.55228-.4477-1-1-1H8.99998ZM11 8.5V7h2v1.5c0 .53707.3707.86588.4654.94981.1501.13316.3302.25013.4733.33959.1031.06443.2035.12498.3032.18511.2226.13429.4419.26659.6801.43529C15.6046 10.8933 16 11.3826 16 12v7c0 .2478-.0018.4169-.0232.5648-.02.1381-.0499.1934-.0644.214-.007.0101-.0384.0552-.171.1055-.1513.0574-.423.1157-.8843.1157H9.14284c-.46132 0-.73297-.0583-.8843-.1157-.13261-.0503-.16434-.0959-.17136-.106-.01448-.0207-.04404-.0754-.06402-.2135-.0214-.1479-.02318-.317-.02318-.5648v-7c0-.6174.3954-1.1067 1.07802-1.5902.23818-.1687.45741-.301.68008-.43529.09969-.06013.20008-.12068.30312-.18511.1432-.08946.3237-.20679.4738-.33996.0947-.08392.465-.41237.465-.94944Z" clip-rule="evenodd"></path></svg>`), DropletBottleAltSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function DropletBottleAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DropletBottleAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root252();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1252();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DropletBottleAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2252();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DropletBottleAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DropletBottleAltSolid = hmr(DropletBottleAltSolid, () => DropletBottleAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropletBottleAltSolid[HMR].source;
    set(DropletBottleAltSolid[HMR].source, module.default[HMR].original);
  });
}
var DropletBottleAltSolid_default = DropletBottleAltSolid;

// node_modules/flowbite-svelte-icons/dist/DropletBottleOutline.svelte
DropletBottleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropletBottleOutline.svelte";
var root_1253 = add_locations(from_svg(`<title> </title>`), DropletBottleOutline[FILENAME], [[43, 4]]);
var root_2253 = add_locations(from_svg(`<desc> </desc>`), DropletBottleOutline[FILENAME], [[46, 4]]);
var root253 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 6h6m-5-3v6c-2 1.5-3 3.5-3 5.5V19c0 1.1046.89543 2 2 2h6c1.1046 0 2-.8954 2-2v-4.5c0-2-1-4-3-5.5V3h-4Zm4 13c0 1.1046-.8954 2-2 2s-2-.8954-2-2 1.8849-4 2-4c.1151 0 2 2.8954 2 4Z"></path></svg>`), DropletBottleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DropletBottleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DropletBottleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root253();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1253();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DropletBottleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2253();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DropletBottleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DropletBottleOutline = hmr(DropletBottleOutline, () => DropletBottleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropletBottleOutline[HMR].source;
    set(DropletBottleOutline[HMR].source, module.default[HMR].original);
  });
}
var DropletBottleOutline_default = DropletBottleOutline;

// node_modules/flowbite-svelte-icons/dist/DropletBottleSolid.svelte
DropletBottleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropletBottleSolid.svelte";
var root_1254 = add_locations(from_svg(`<title> </title>`), DropletBottleSolid[FILENAME], [[41, 4]]);
var root_2254 = add_locations(from_svg(`<desc> </desc>`), DropletBottleSolid[FILENAME], [[44, 4]]);
var root254 = add_locations(from_svg(`<svg><!><!><path d="M12 11c-.2397 0-.4128.0858-.4729.1174-.0773.0408-.1341.0834-.1648.1078-.0624.0495-.1092.098-.1334.1237-.0529.0565-.1019.1178-.1405.168-.0816.106-.1784.2437-.2809.3972-.2074.3103-.467.7284-.7219 1.1808-.25372.4504-.51297.9528-.71184 1.4282C9.19074 14.9607 9 15.5086 9 16c0 1.6569 1.3431 3 3 3s3-1.3431 3-3c0-.4914-.1907-1.0393-.3738-1.4769-.1988-.4754-.4581-.9778-.7118-1.4282-.2549-.4524-.5145-.8705-.7219-1.1808-.1025-.1535-.1993-.2912-.2809-.3972-.0386-.0502-.0876-.1115-.1405-.168-.0242-.0257-.071-.0742-.1334-.1237-.0307-.0244-.0875-.067-.1648-.1078C12.4128 11.0858 12.2397 11 12 11Z"></path><path fill-rule="evenodd" d="M10 2c-.55228 0-1 .44772-1 1v2c-.55228 0-1 .44772-1 1s.44772 1 1 1v1.51594C7.03885 10.1474 6 12.2926 6 14.5V19c0 1.6568 1.34314 3 3 3h6c1.6569 0 3-1.3431 3-3v-4.5c0-2.2074-1.0389-4.3526-3-5.98406V7c.5523 0 1-.44772 1-1s-.4477-1-1-1V3c0-.55228-.4477-1-1-1h-4Zm1 7V7h2v2c0 .31476.1482.61115.4.8 1.7804 1.3353 2.6 3.0529 2.6 4.7V19c0 .5523-.4477 1-1 1H9c-.55228 0-1-.4477-1-1v-4.5c0-1.6471.81961-3.3647 2.6-4.7.2518-.18885.4-.48524.4-.8Z" clip-rule="evenodd"></path></svg>`), DropletBottleSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function DropletBottleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DropletBottleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root254();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1254();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DropletBottleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2254();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DropletBottleSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DropletBottleSolid = hmr(DropletBottleSolid, () => DropletBottleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropletBottleSolid[HMR].source;
    set(DropletBottleSolid[HMR].source, module.default[HMR].original);
  });
}
var DropletBottleSolid_default = DropletBottleSolid;

// node_modules/flowbite-svelte-icons/dist/DrumstickBiteOutline.svelte
DrumstickBiteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrumstickBiteOutline.svelte";
var root_1255 = add_locations(from_svg(`<title> </title>`), DrumstickBiteOutline[FILENAME], [[43, 4]]);
var root_2255 = add_locations(from_svg(`<desc> </desc>`), DrumstickBiteOutline[FILENAME], [[46, 4]]);
var root255 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.4427 9.88469 9.93591 7.50961c.81449-.81448.80559-2.06903-.02046-2.89511-.82608-.82607-2.08062-.83494-2.89511-.02046-.4791.47911-.71525 1.20118-.56606 1.82948-.6283-.14919-1.35037.08695-1.82948.56606-.81448.81448-.80561 2.06903.02047 2.89511.82607.82611 2.08062.83491 2.8951.02046l2.50233 2.29305m.8063-1.38c1.83-1.8299 5.1241-1.22213 7.1925.8462 2.0684 2.0684 2.3191 4.6228.2978 6.6441-1.0322 1.0321-2.1287 1.6094-3.2302 1.6518.5878-1.3405.2254-2.5874-.8127-3.2811-.918-.6135-2.1806-.7802-3.5479.179-1.10401-2.0578-1.30393-4.6355.1005-6.04Z"></path></svg>`), DrumstickBiteOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function DrumstickBiteOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DrumstickBiteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root255();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1255();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DrumstickBiteOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2255();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DrumstickBiteOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DrumstickBiteOutline = hmr(DrumstickBiteOutline, () => DrumstickBiteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrumstickBiteOutline[HMR].source;
    set(DrumstickBiteOutline[HMR].source, module.default[HMR].original);
  });
}
var DrumstickBiteOutline_default = DrumstickBiteOutline;

// node_modules/flowbite-svelte-icons/dist/DrumstickBiteSolid.svelte
DrumstickBiteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrumstickBiteSolid.svelte";
var root_1256 = add_locations(from_svg(`<title> </title>`), DrumstickBiteSolid[FILENAME], [[41, 4]]);
var root_2256 = add_locations(from_svg(`<desc> </desc>`), DrumstickBiteSolid[FILENAME], [[44, 4]]);
var root256 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10.6223 3.90741c-1.20712-1.20714-3.09489-1.23486-4.30929-.02046-.41495.41495-.71699.96417-.84122 1.55432-.59015.12423-1.13937.42627-1.55432.84122-1.2144 1.2144-1.18669 3.10218.02046 4.30931.96862.9686 2.37548 1.1779 3.52103.5953l1.47896 1.3553c-.05911.3509-.08406.7078-.07998 1.0623.01453 1.26.39197 2.5758 1.00914 3.7262.13522.252.37182.4341.65002.5002.2782.0661.5714.0099.8055-.1543.5376-.3772.9988-.4969 1.3707-.4979.3764-.0009.7303.1199 1.0473.3317.5919.3956.8671 1.1024.4524 2.0481-.1383.3154-.1045.6799.0894.9646.1939.2847.5207.4495.8649.4362 1.437-.0553 2.7584-.8034 3.8989-1.9439 1.1842-1.1842 1.7637-2.5978 1.6758-4.071-.0866-1.4527-.8131-2.8268-1.9736-3.9873-1.1796-1.17955-2.7171-1.95508-4.2554-2.16837-.5785-.08021-1.1679-.08125-1.7413.01127l-1.5065-1.42739c.548-1.13519.3301-2.5124-.6229-3.4654Zm.0919 5.71744L9.2479 8.23554c-.19592-.18563-.30849-.44256-.31213-.71243-.00363-.26987.10196-.52975.29281-.72059.41457-.41457.42454-1.03588-.02046-1.48089-.44501-.44501-1.06633-.43503-1.4809-.02046-.26525.26524-.35944.64193-.30022.89134.08017.33765-.02045.69273-.26584.93813-.2454.2454-.60048.34602-.93813.26584-.24941-.05922-.6261.03498-.89135.30022-.41457.41457-.42455 1.03589.02046 1.4809.44501.44501 1.06633.43503 1.4809.02046.37853-.37854.98803-.39183 1.38271-.03016l1.5307 1.4027c.11824-.1603.24972-.314.39525-.4595.1813-.1813.3728-.34306.5725-.48625Z" clip-rule="evenodd"></path></svg>`), DrumstickBiteSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function DrumstickBiteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, DrumstickBiteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root256();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1256();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      DrumstickBiteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2256();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      DrumstickBiteSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  DrumstickBiteSolid = hmr(DrumstickBiteSolid, () => DrumstickBiteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrumstickBiteSolid[HMR].source;
    set(DrumstickBiteSolid[HMR].source, module.default[HMR].original);
  });
}
var DrumstickBiteSolid_default = DrumstickBiteSolid;

// node_modules/flowbite-svelte-icons/dist/EditOutline.svelte
EditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EditOutline.svelte";
var root_1257 = add_locations(from_svg(`<title> </title>`), EditOutline[FILENAME], [[43, 4]]);
var root_2257 = add_locations(from_svg(`<desc> </desc>`), EditOutline[FILENAME], [[46, 4]]);
var root257 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m14.304 4.844 2.852 2.852M7 7H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-4.5m2.409-9.91a2.017 2.017 0 0 1 0 2.853l-6.844 6.844L8 14l.713-3.565 6.844-6.844a2.015 2.015 0 0 1 2.852 0Z"></path></svg>`), EditOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EditOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root257();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1257();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EditOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2257();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EditOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EditOutline = hmr(EditOutline, () => EditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EditOutline[HMR].source;
    set(EditOutline[HMR].source, module.default[HMR].original);
  });
}
var EditOutline_default = EditOutline;

// node_modules/flowbite-svelte-icons/dist/EditSolid.svelte
EditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EditSolid.svelte";
var root_1258 = add_locations(from_svg(`<title> </title>`), EditSolid[FILENAME], [[41, 4]]);
var root_2258 = add_locations(from_svg(`<desc> </desc>`), EditSolid[FILENAME], [[44, 4]]);
var root258 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.32 6.176H5c-1.105 0-2 .949-2 2.118v10.588C3 20.052 3.895 21 5 21h11c1.105 0 2-.948 2-2.118v-7.75l-3.914 4.144A2.46 2.46 0 0 1 12.81 16l-2.681.568c-1.75.37-3.292-1.263-2.942-3.115l.536-2.839c.097-.512.335-.983.684-1.352l2.914-3.086Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M19.846 4.318a2.148 2.148 0 0 0-.437-.692 2.014 2.014 0 0 0-.654-.463 1.92 1.92 0 0 0-1.544 0 2.014 2.014 0 0 0-.654.463l-.546.578 2.852 3.02.546-.579a2.14 2.14 0 0 0 .437-.692 2.244 2.244 0 0 0 0-1.635ZM17.45 8.721 14.597 5.7 9.82 10.76a.54.54 0 0 0-.137.27l-.536 2.84c-.07.37.239.696.588.622l2.682-.567a.492.492 0 0 0 .255-.145l4.778-5.06Z" clip-rule="evenodd"></path></svg>`), EditSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function EditSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root258();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1258();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EditSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2258();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EditSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EditSolid = hmr(EditSolid, () => EditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EditSolid[HMR].source;
    set(EditSolid[HMR].source, module.default[HMR].original);
  });
}
var EditSolid_default = EditSolid;

// node_modules/flowbite-svelte-icons/dist/EggOutline.svelte
EggOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EggOutline.svelte";
var root_1259 = add_locations(from_svg(`<title> </title>`), EggOutline[FILENAME], [[43, 4]]);
var root_2259 = add_locations(from_svg(`<desc> </desc>`), EggOutline[FILENAME], [[46, 4]]);
var root259 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.0001 13c0-.8883.4022-2.3826 1-3.27163M18.05 14c0 3.3137-2.6862 6-6 6-3.31366 0-5.99995-2.6863-5.99995-6S8.73634 4 12.05 4c3.3138 0 6 6.6863 6 10Z"></path></svg>`), EggOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EggOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EggOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root259();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1259();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EggOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2259();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EggOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EggOutline = hmr(EggOutline, () => EggOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EggOutline[HMR].source;
    set(EggOutline[HMR].source, module.default[HMR].original);
  });
}
var EggOutline_default = EggOutline;

// node_modules/flowbite-svelte-icons/dist/EggSolid.svelte
EggSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EggSolid.svelte";
var root_1260 = add_locations(from_svg(`<title> </title>`), EggSolid[FILENAME], [[41, 4]]);
var root_2260 = add_locations(from_svg(`<desc> </desc>`), EggSolid[FILENAME], [[44, 4]]);
var root260 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9.0276 4.36983C9.84851 3.59377 10.8715 3 12.05 3c1.1786 0 2.2016.59377 3.0225 1.36983.8255.78038 1.5331 1.82292 2.1072 2.92578C18.3188 9.48385 19.05 12.1425 19.05 14c0 3.866-3.134 7-7 7-3.86594 0-6.99995-3.134-6.99995-7 0-1.8575.73123-4.51615 1.87035-6.70439.57411-1.10286 1.28173-2.1454 2.1072-2.92578Zm2.8023 5.91657c.3082-.45832.1865-1.07968-.2718-1.38786-.4583-.30818-1.0797-.18648-1.3879.27182-.37473.55732-.66096 1.25684-.85365 1.91184-.19234.6537-.31649 1.3484-.31649 1.9178 0 .5523.44772 1 1.00004 1 .5522 0 1-.4477 1-1 0-.3189.0769-.8156.2351-1.3533.1579-.5365.3717-1.0286.5947-1.3603Z" clip-rule="evenodd"></path></svg>`), EggSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function EggSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EggSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root260();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1260();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EggSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2260();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EggSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EggSolid = hmr(EggSolid, () => EggSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EggSolid[HMR].source;
    set(EggSolid[HMR].source, module.default[HMR].original);
  });
}
var EggSolid_default = EggSolid;

// node_modules/flowbite-svelte-icons/dist/EnvelopeOpenOutline.svelte
EnvelopeOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOpenOutline.svelte";
var root_1261 = add_locations(from_svg(`<title> </title>`), EnvelopeOpenOutline[FILENAME], [[43, 4]]);
var root_2261 = add_locations(from_svg(`<desc> </desc>`), EnvelopeOpenOutline[FILENAME], [[46, 4]]);
var root261 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 8v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8m18 0-8.029-4.46a2 2 0 0 0-1.942 0L3 8m18 0-9 6.5L3 8"></path></svg>`), EnvelopeOpenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EnvelopeOpenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EnvelopeOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root261();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1261();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EnvelopeOpenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2261();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EnvelopeOpenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EnvelopeOpenOutline = hmr(EnvelopeOpenOutline, () => EnvelopeOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOpenOutline[HMR].source;
    set(EnvelopeOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOpenOutline_default = EnvelopeOpenOutline;

// node_modules/flowbite-svelte-icons/dist/EnvelopeOpenSolid.svelte
EnvelopeOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOpenSolid.svelte";
var root_1262 = add_locations(from_svg(`<title> </title>`), EnvelopeOpenSolid[FILENAME], [[41, 4]]);
var root_2262 = add_locations(from_svg(`<desc> </desc>`), EnvelopeOpenSolid[FILENAME], [[44, 4]]);
var root262 = add_locations(from_svg(`<svg><!><!><path d="m3.62 6.389 8.396 6.724 8.638-6.572-7.69-4.29a1.975 1.975 0 0 0-1.928 0L3.62 6.39Z"></path><path d="m22 8.053-8.784 6.683a1.978 1.978 0 0 1-2.44-.031L2.02 7.693a1.091 1.091 0 0 0-.019.199v11.065C2 20.637 3.343 22 5 22h14c1.657 0 3-1.362 3-3.043V8.053Z"></path></svg>`), EnvelopeOpenSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function EnvelopeOpenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EnvelopeOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root262();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1262();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EnvelopeOpenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2262();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EnvelopeOpenSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EnvelopeOpenSolid = hmr(EnvelopeOpenSolid, () => EnvelopeOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOpenSolid[HMR].source;
    set(EnvelopeOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOpenSolid_default = EnvelopeOpenSolid;

// node_modules/flowbite-svelte-icons/dist/EnvelopeOutline.svelte
EnvelopeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOutline.svelte";
var root_1263 = add_locations(from_svg(`<title> </title>`), EnvelopeOutline[FILENAME], [[43, 4]]);
var root_2263 = add_locations(from_svg(`<desc> </desc>`), EnvelopeOutline[FILENAME], [[46, 4]]);
var root263 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m3.5 5.5 7.893 6.036a1 1 0 0 0 1.214 0L20.5 5.5M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), EnvelopeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EnvelopeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EnvelopeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root263();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1263();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EnvelopeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2263();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EnvelopeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EnvelopeOutline = hmr(EnvelopeOutline, () => EnvelopeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOutline[HMR].source;
    set(EnvelopeOutline[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOutline_default = EnvelopeOutline;

// node_modules/flowbite-svelte-icons/dist/EnvelopeSolid.svelte
EnvelopeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeSolid.svelte";
var root_1264 = add_locations(from_svg(`<title> </title>`), EnvelopeSolid[FILENAME], [[41, 4]]);
var root_2264 = add_locations(from_svg(`<desc> </desc>`), EnvelopeSolid[FILENAME], [[44, 4]]);
var root264 = add_locations(from_svg(`<svg><!><!><path d="M2.038 5.61A2.01 2.01 0 0 0 2 6v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6c0-.12-.01-.238-.03-.352l-.866.65-7.89 6.032a2 2 0 0 1-2.429 0L2.884 6.288l-.846-.677Z"></path><path d="M20.677 4.117A1.996 1.996 0 0 0 20 4H4c-.225 0-.44.037-.642.105l.758.607L12 10.742 19.9 4.7l.777-.583Z"></path></svg>`), EnvelopeSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function EnvelopeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EnvelopeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root264();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1264();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EnvelopeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2264();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EnvelopeSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EnvelopeSolid = hmr(EnvelopeSolid, () => EnvelopeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeSolid[HMR].source;
    set(EnvelopeSolid[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeSolid_default = EnvelopeSolid;

// node_modules/flowbite-svelte-icons/dist/EuroOutline.svelte
EuroOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EuroOutline.svelte";
var root_1265 = add_locations(from_svg(`<title> </title>`), EuroOutline[FILENAME], [[43, 4]]);
var root_2265 = add_locations(from_svg(`<desc> </desc>`), EuroOutline[FILENAME], [[46, 4]]);
var root265 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 10h9.231M6 14h9.231M18 5.086A5.95 5.95 0 0 0 14.615 4c-3.738 0-6.769 3.582-6.769 8s3.031 8 6.769 8A5.94 5.94 0 0 0 18 18.916"></path></svg>`), EuroOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EuroOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EuroOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root265();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1265();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EuroOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2265();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EuroOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EuroOutline = hmr(EuroOutline, () => EuroOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EuroOutline[HMR].source;
    set(EuroOutline[HMR].source, module.default[HMR].original);
  });
}
var EuroOutline_default = EuroOutline;

// node_modules/flowbite-svelte-icons/dist/ExclamationCircleOutline.svelte
ExclamationCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExclamationCircleOutline.svelte";
var root_1266 = add_locations(from_svg(`<title> </title>`), ExclamationCircleOutline[FILENAME], [[43, 4]]);
var root_2266 = add_locations(from_svg(`<desc> </desc>`), ExclamationCircleOutline[FILENAME], [[46, 4]]);
var root266 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13V8m0 8h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), ExclamationCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ExclamationCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ExclamationCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root266();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1266();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ExclamationCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2266();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ExclamationCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ExclamationCircleOutline = hmr(ExclamationCircleOutline, () => ExclamationCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExclamationCircleOutline[HMR].source;
    set(ExclamationCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var ExclamationCircleOutline_default = ExclamationCircleOutline;

// node_modules/flowbite-svelte-icons/dist/ExclamationCircleSolid.svelte
ExclamationCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExclamationCircleSolid.svelte";
var root_1267 = add_locations(from_svg(`<title> </title>`), ExclamationCircleSolid[FILENAME], [[41, 4]]);
var root_2267 = add_locations(from_svg(`<desc> </desc>`), ExclamationCircleSolid[FILENAME], [[44, 4]]);
var root267 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4a1 1 0 1 0-2 0v5a1 1 0 1 0 2 0V8Zm-1 7a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), ExclamationCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ExclamationCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ExclamationCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root267();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1267();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ExclamationCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2267();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ExclamationCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ExclamationCircleSolid = hmr(ExclamationCircleSolid, () => ExclamationCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExclamationCircleSolid[HMR].source;
    set(ExclamationCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var ExclamationCircleSolid_default = ExclamationCircleSolid;

// node_modules/flowbite-svelte-icons/dist/ExpandOutline.svelte
ExpandOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExpandOutline.svelte";
var root_1268 = add_locations(from_svg(`<title> </title>`), ExpandOutline[FILENAME], [[43, 4]]);
var root_2268 = add_locations(from_svg(`<desc> </desc>`), ExpandOutline[FILENAME], [[46, 4]]);
var root268 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 4H4m0 0v4m0-4 5 5m7-5h4m0 0v4m0-4-5 5M8 20H4m0 0v-4m0 4 5-5m7 5h4m0 0v-4m0 4-5-5"></path></svg>`), ExpandOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ExpandOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ExpandOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root268();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1268();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ExpandOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2268();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ExpandOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ExpandOutline = hmr(ExpandOutline, () => ExpandOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExpandOutline[HMR].source;
    set(ExpandOutline[HMR].source, module.default[HMR].original);
  });
}
var ExpandOutline_default = ExpandOutline;

// node_modules/flowbite-svelte-icons/dist/EyeOutline.svelte
EyeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeOutline.svelte";
var root_1269 = add_locations(from_svg(`<title> </title>`), EyeOutline[FILENAME], [[43, 4]]);
var root_2269 = add_locations(from_svg(`<desc> </desc>`), EyeOutline[FILENAME], [[46, 4]]);
var root269 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M21 12c0 1.2-4.03 6-9 6s-9-4.8-9-6c0-1.2 4.03-6 9-6s9 4.8 9 6Z"></path><path stroke="currentColor" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), EyeOutline[FILENAME], [[31, 0, [[48, 2], [53, 2]]]]);
function EyeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EyeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root269();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1269();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EyeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2269();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EyeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EyeOutline = hmr(EyeOutline, () => EyeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeOutline[HMR].source;
    set(EyeOutline[HMR].source, module.default[HMR].original);
  });
}
var EyeOutline_default = EyeOutline;

// node_modules/flowbite-svelte-icons/dist/EyeSlashOutline.svelte
EyeSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSlashOutline.svelte";
var root_1270 = add_locations(from_svg(`<title> </title>`), EyeSlashOutline[FILENAME], [[43, 4]]);
var root_2270 = add_locations(from_svg(`<desc> </desc>`), EyeSlashOutline[FILENAME], [[46, 4]]);
var root270 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3.933 13.909A4.357 4.357 0 0 1 3 12c0-1 4-6 9-6m7.6 3.8A5.068 5.068 0 0 1 21 12c0 1-3 6-9 6-.314 0-.62-.014-.918-.04M5 19 19 5m-4 7a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), EyeSlashOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function EyeSlashOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EyeSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root270();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1270();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EyeSlashOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2270();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EyeSlashOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EyeSlashOutline = hmr(EyeSlashOutline, () => EyeSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSlashOutline[HMR].source;
    set(EyeSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var EyeSlashOutline_default = EyeSlashOutline;

// node_modules/flowbite-svelte-icons/dist/EyeSlashSolid.svelte
EyeSlashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSlashSolid.svelte";
var root_1271 = add_locations(from_svg(`<title> </title>`), EyeSlashSolid[FILENAME], [[41, 4]]);
var root_2271 = add_locations(from_svg(`<desc> </desc>`), EyeSlashSolid[FILENAME], [[44, 4]]);
var root271 = add_locations(from_svg(`<svg><!><!><path d="m4 15.6 3.055-3.056A4.913 4.913 0 0 1 7 12.012a5.006 5.006 0 0 1 5-5c.178.009.356.027.532.054l1.744-1.744A8.973 8.973 0 0 0 12 5.012c-5.388 0-10 5.336-10 7A6.49 6.49 0 0 0 4 15.6Z"></path><path d="m14.7 10.726 4.995-5.007A.998.998 0 0 0 18.99 4a1 1 0 0 0-.71.305l-4.995 5.007a2.98 2.98 0 0 0-.588-.21l-.035-.01a2.981 2.981 0 0 0-3.584 3.583c0 .012.008.022.01.033.05.204.12.402.211.59l-4.995 4.983a1 1 0 1 0 1.414 1.414l4.995-4.983c.189.091.386.162.59.211.011 0 .021.007.033.01a2.982 2.982 0 0 0 3.584-3.584c0-.012-.008-.023-.011-.035a3.05 3.05 0 0 0-.21-.588Z"></path><path d="m19.821 8.605-2.857 2.857a4.952 4.952 0 0 1-5.514 5.514l-1.785 1.785c.767.166 1.55.25 2.335.251 6.453 0 10-5.258 10-7 0-1.166-1.637-2.874-2.179-3.407Z"></path></svg>`), EyeSlashSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [52, 2]]]]);
function EyeSlashSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EyeSlashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root271();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1271();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EyeSlashSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2271();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EyeSlashSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EyeSlashSolid = hmr(EyeSlashSolid, () => EyeSlashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSlashSolid[HMR].source;
    set(EyeSlashSolid[HMR].source, module.default[HMR].original);
  });
}
var EyeSlashSolid_default = EyeSlashSolid;

// node_modules/flowbite-svelte-icons/dist/EyeSolid.svelte
EyeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSolid.svelte";
var root_1272 = add_locations(from_svg(`<title> </title>`), EyeSolid[FILENAME], [[41, 4]]);
var root_2272 = add_locations(from_svg(`<desc> </desc>`), EyeSolid[FILENAME], [[44, 4]]);
var root272 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4.998 7.78C6.729 6.345 9.198 5 12 5c2.802 0 5.27 1.345 7.002 2.78a12.713 12.713 0 0 1 2.096 2.183c.253.344.465.682.618.997.14.286.284.658.284 1.04s-.145.754-.284 1.04a6.6 6.6 0 0 1-.618.997 12.712 12.712 0 0 1-2.096 2.183C17.271 17.655 14.802 19 12 19c-2.802 0-5.27-1.345-7.002-2.78a12.712 12.712 0 0 1-2.096-2.183 6.6 6.6 0 0 1-.618-.997C2.144 12.754 2 12.382 2 12s.145-.754.284-1.04c.153-.315.365-.653.618-.997A12.714 12.714 0 0 1 4.998 7.78ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" clip-rule="evenodd"></path></svg>`), EyeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function EyeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, EyeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root272();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1272();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      EyeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2272();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      EyeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  EyeSolid = hmr(EyeSolid, () => EyeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSolid[HMR].source;
    set(EyeSolid[HMR].source, module.default[HMR].original);
  });
}
var EyeSolid_default = EyeSolid;

// node_modules/flowbite-svelte-icons/dist/FacebookSolid.svelte
FacebookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FacebookSolid.svelte";
var root_1273 = add_locations(from_svg(`<title> </title>`), FacebookSolid[FILENAME], [[41, 4]]);
var root_2273 = add_locations(from_svg(`<desc> </desc>`), FacebookSolid[FILENAME], [[44, 4]]);
var root273 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13.135 6H15V3h-1.865a4.147 4.147 0 0 0-4.142 4.142V9H7v3h2v9.938h3V12h2.021l.592-3H12V6.591A.6.6 0 0 1 12.592 6h.543Z" clip-rule="evenodd"></path></svg>`), FacebookSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FacebookSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FacebookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root273();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1273();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FacebookSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2273();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FacebookSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FacebookSolid = hmr(FacebookSolid, () => FacebookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FacebookSolid[HMR].source;
    set(FacebookSolid[HMR].source, module.default[HMR].original);
  });
}
var FacebookSolid_default = FacebookSolid;

// node_modules/flowbite-svelte-icons/dist/FaceExplodeOutline.svelte
FaceExplodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceExplodeOutline.svelte";
var root_1274 = add_locations(from_svg(`<title> </title>`), FaceExplodeOutline[FILENAME], [[43, 4]]);
var root_2274 = add_locations(from_svg(`<desc> </desc>`), FaceExplodeOutline[FILENAME], [[46, 4]]);
var root274 = add_locations(from_svg(`<svg><!><!><path d="M12 17a2 2 0 0 1 2 2h-4a2 2 0 0 1 2-2Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.815 9H16.5a2 2 0 1 0-1.03-3.707A1.87 1.87 0 0 0 15.5 5 1.992 1.992 0 0 0 12 3.69 1.992 1.992 0 0 0 8.5 5c.002.098.012.196.03.293A2 2 0 1 0 7.5 9h3.388m2.927-.985v3.604M10.228 9v2.574M15 16h.01M9 16h.01m11.962-4.426a1.805 1.805 0 0 1-1.74 1.326 1.893 1.893 0 0 1-1.811-1.326 1.9 1.9 0 0 1-3.621 0 1.8 1.8 0 0 1-1.749 1.326 1.98 1.98 0 0 1-1.87-1.326A1.763 1.763 0 0 1 8.46 12.9a2.035 2.035 0 0 1-1.905-1.326A1.9 1.9 0 0 1 4.74 12.9 1.805 1.805 0 0 1 3 11.574V12a9 9 0 0 0 18 0l-.028-.426Z"></path></svg>`), FaceExplodeOutline[FILENAME], [[31, 0, [[48, 2], [49, 2]]]]);
function FaceExplodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceExplodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root274();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1274();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceExplodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2274();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceExplodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceExplodeOutline = hmr(FaceExplodeOutline, () => FaceExplodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceExplodeOutline[HMR].source;
    set(FaceExplodeOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceExplodeOutline_default = FaceExplodeOutline;

// node_modules/flowbite-svelte-icons/dist/FaceExplodeSolid.svelte
FaceExplodeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceExplodeSolid.svelte";
var root_1275 = add_locations(from_svg(`<title> </title>`), FaceExplodeSolid[FILENAME], [[41, 4]]);
var root_2275 = add_locations(from_svg(`<desc> </desc>`), FaceExplodeSolid[FILENAME], [[44, 4]]);
var root275 = add_locations(from_svg(`<svg><!><!><path d="M21.972 11.517a.527.527 0 0 0-1.034-.105 1.377 1.377 0 0 1-1.324 1.01 1.467 1.467 0 0 1-1.4-1.009.526.526 0 0 0-1.015 0 1.467 1.467 0 0 1-2.737.143l-.049-.204.021-.146V9.369h2.304a2.632 2.632 0 0 0 2.631-2.632 2.678 2.678 0 0 0-2.654-2.632l-.526.022-.13-.369A2.632 2.632 0 0 0 13.579 2c-.461 0-.915.124-1.313.358L12 2.513l-.266-.155A2.603 2.603 0 0 0 10.422 2a2.632 2.632 0 0 0-2.483 1.759l-.13.37-.518-.024a2.681 2.681 0 0 0-2.66 2.632A2.632 2.632 0 0 0 7.264 9.37H9.61v1.887l-.007.09-.028.08a1.328 1.328 0 0 1-1.301.996 1.632 1.632 0 0 1-1.502-1.024.526.526 0 0 0-1.01.013 1.474 1.474 0 0 1-1.404 1.01 1.381 1.381 0 0 1-1.325-1.01.547.547 0 0 0-.569-.382h-.008a.526.526 0 0 0-.456.526v.446a10.012 10.012 0 0 0 10 10 9.904 9.904 0 0 0 7.067-2.94A10.019 10.019 0 0 0 22 11.966l-.028-.449ZM8.316 15.685a1.053 1.053 0 1 1 2.105 0 1.053 1.053 0 0 1-2.105 0Zm1.58 3.684a2.105 2.105 0 0 1 4.21 0h-4.21Zm4.736-2.631a1.052 1.052 0 1 1 0-2.105 1.052 1.052 0 0 1 0 2.105Z"></path></svg>`), FaceExplodeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceExplodeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceExplodeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root275();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1275();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceExplodeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2275();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceExplodeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceExplodeSolid = hmr(FaceExplodeSolid, () => FaceExplodeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceExplodeSolid[HMR].source;
    set(FaceExplodeSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceExplodeSolid_default = FaceExplodeSolid;

// node_modules/flowbite-svelte-icons/dist/FaceGrinOutline.svelte
FaceGrinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinOutline.svelte";
var root_1276 = add_locations(from_svg(`<title> </title>`), FaceGrinOutline[FILENAME], [[43, 4]]);
var root_2276 = add_locations(from_svg(`<desc> </desc>`), FaceGrinOutline[FILENAME], [[46, 4]]);
var root276 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.99 9H15M8.99 9H9m12 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0ZM7 13c0 1 .507 2.397 1.494 3.216a5.5 5.5 0 0 0 7.022 0C16.503 15.397 17 14 17 13c0 0-1.99 1-4.995 1S7 13 7 13Z"></path></svg>`), FaceGrinOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FaceGrinOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceGrinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root276();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1276();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceGrinOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2276();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceGrinOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceGrinOutline = hmr(FaceGrinOutline, () => FaceGrinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinOutline[HMR].source;
    set(FaceGrinOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinOutline_default = FaceGrinOutline;

// node_modules/flowbite-svelte-icons/dist/FaceGrinSolid.svelte
FaceGrinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinSolid.svelte";
var root_1277 = add_locations(from_svg(`<title> </title>`), FaceGrinSolid[FILENAME], [[41, 4]]);
var root_2277 = add_locations(from_svg(`<desc> </desc>`), FaceGrinSolid[FILENAME], [[44, 4]]);
var root277 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm5.495.93A.5.5 0 0 0 6.5 13c0 1.19.644 2.438 1.618 3.375C9.099 17.319 10.469 18 12 18c1.531 0 2.9-.681 3.882-1.625.974-.937 1.618-2.184 1.618-3.375a.5.5 0 0 0-.995-.07.764.764 0 0 1-.156.096c-.214.106-.554.208-1.006.295-.896.173-2.111.262-3.343.262-1.232 0-2.447-.09-3.343-.262-.452-.087-.792-.19-1.005-.295a.762.762 0 0 1-.157-.096ZM8.99 8a1 1 0 0 0 0 2H9a1 1 0 1 0 0-2h-.01Zm6 0a1 1 0 1 0 0 2H15a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), FaceGrinSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceGrinSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceGrinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root277();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1277();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceGrinSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2277();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceGrinSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceGrinSolid = hmr(FaceGrinSolid, () => FaceGrinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinSolid[HMR].source;
    set(FaceGrinSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinSolid_default = FaceGrinSolid;

// node_modules/flowbite-svelte-icons/dist/FaceGrinStarsOutline.svelte
FaceGrinStarsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinStarsOutline.svelte";
var root_1278 = add_locations(from_svg(`<title> </title>`), FaceGrinStarsOutline[FILENAME], [[43, 4]]);
var root_2278 = add_locations(from_svg(`<desc> </desc>`), FaceGrinStarsOutline[FILENAME], [[46, 4]]);
var root278 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 13c0 2.038-2.239 4.5-5 4.5S7 15.038 7 13c0 1.444 10 1.444 10 0Z"></path><path d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"></path></svg>`), FaceGrinStarsOutline[FILENAME], [[31, 0, [[48, 2], [55, 2], [62, 2], [65, 2]]]]);
function FaceGrinStarsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceGrinStarsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root278();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1278();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceGrinStarsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2278();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceGrinStarsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  next(2);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceGrinStarsOutline = hmr(FaceGrinStarsOutline, () => FaceGrinStarsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinStarsOutline[HMR].source;
    set(FaceGrinStarsOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinStarsOutline_default = FaceGrinStarsOutline;

// node_modules/flowbite-svelte-icons/dist/FaceGrinStarsSolid.svelte
FaceGrinStarsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinStarsSolid.svelte";
var root_1279 = add_locations(from_svg(`<title> </title>`), FaceGrinStarsSolid[FILENAME], [[41, 4]]);
var root_2279 = add_locations(from_svg(`<desc> </desc>`), FaceGrinStarsSolid[FILENAME], [[44, 4]]);
var root279 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM7 12.5a.5.5 0 0 1 .495.43.762.762 0 0 0 .157.096c.213.106.553.208 1.005.295.896.173 2.111.262 3.343.262 1.232 0 2.447-.09 3.343-.262.452-.087.792-.19 1.006-.295a.764.764 0 0 0 .156-.096.5.5 0 0 1 .995.07c0 1.19-.644 2.438-1.618 3.375C14.9 17.319 13.531 18 12 18c-1.531 0-2.9-.681-3.882-1.625C7.144 15.438 6.5 14.19 6.5 13a.5.5 0 0 1 .5-.5Zm9.519.417.003-.004-.003.004Zm-9.038 0a.017.017 0 0 1-.003-.004l.003.004Zm.901-4.853L9 6.81l.619 1.253 1.381.2-1 .976.236 1.376-1.237-.65-1.235.65L8 9.239l-1-.975 1.382-.2Zm6 0L15 6.81l.619 1.253 1.381.2-1 .976.236 1.376-1.237-.65-1.235.65L14 9.239l-1-.975 1.382-.2Z" clip-rule="evenodd"></path></svg>`), FaceGrinStarsSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceGrinStarsSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceGrinStarsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root279();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1279();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceGrinStarsSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2279();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceGrinStarsSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceGrinStarsSolid = hmr(FaceGrinStarsSolid, () => FaceGrinStarsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinStarsSolid[HMR].source;
    set(FaceGrinStarsSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinStarsSolid_default = FaceGrinStarsSolid;

// node_modules/flowbite-svelte-icons/dist/FaceLaughOutline.svelte
FaceLaughOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceLaughOutline.svelte";
var root_1280 = add_locations(from_svg(`<title> </title>`), FaceLaughOutline[FILENAME], [[43, 4]]);
var root_2280 = add_locations(from_svg(`<desc> </desc>`), FaceLaughOutline[FILENAME], [[46, 4]]);
var root280 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 9h.01M8.99 9H9m12 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0ZM6.6 13a5.5 5.5 0 0 0 10.81 0H6.6Z"></path></svg>`), FaceLaughOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FaceLaughOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceLaughOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root280();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1280();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceLaughOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2280();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceLaughOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceLaughOutline = hmr(FaceLaughOutline, () => FaceLaughOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceLaughOutline[HMR].source;
    set(FaceLaughOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceLaughOutline_default = FaceLaughOutline;

// node_modules/flowbite-svelte-icons/dist/FaceLaughSolid.svelte
FaceLaughSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceLaughSolid.svelte";
var root_1281 = add_locations(from_svg(`<title> </title>`), FaceLaughSolid[FILENAME], [[41, 4]]);
var root_2281 = add_locations(from_svg(`<desc> </desc>`), FaceLaughSolid[FILENAME], [[44, 4]]);
var root281 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM7.99 9a1 1 0 0 1 1-1H9a1 1 0 0 1 0 2h-.01a1 1 0 0 1-1-1ZM14 9a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H15a1 1 0 0 1-1-1Zm-5.506 7.216A5.5 5.5 0 0 1 6.6 13h10.81a5.5 5.5 0 0 1-8.916 3.216Z" clip-rule="evenodd"></path></svg>`), FaceLaughSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceLaughSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FaceLaughSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root281();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1281();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FaceLaughSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2281();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FaceLaughSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FaceLaughSolid = hmr(FaceLaughSolid, () => FaceLaughSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceLaughSolid[HMR].source;
    set(FaceLaughSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceLaughSolid_default = FaceLaughSolid;

// node_modules/flowbite-svelte-icons/dist/FileChartBarOutline.svelte
FileChartBarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileChartBarOutline.svelte";
var root_1282 = add_locations(from_svg(`<title> </title>`), FileChartBarOutline[FILENAME], [[43, 4]]);
var root_2282 = add_locations(from_svg(`<desc> </desc>`), FileChartBarOutline[FILENAME], [[46, 4]]);
var root282 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 10v-2m3 2v-6m3 6v-3m4-11v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileChartBarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileChartBarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileChartBarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root282();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1282();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileChartBarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2282();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileChartBarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileChartBarOutline = hmr(FileChartBarOutline, () => FileChartBarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileChartBarOutline[HMR].source;
    set(FileChartBarOutline[HMR].source, module.default[HMR].original);
  });
}
var FileChartBarOutline_default = FileChartBarOutline;

// node_modules/flowbite-svelte-icons/dist/FileChartBarSolid.svelte
FileChartBarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileChartBarSolid.svelte";
var root_1283 = add_locations(from_svg(`<title> </title>`), FileChartBarSolid[FILENAME], [[41, 4]]);
var root_2283 = add_locations(from_svg(`<desc> </desc>`), FileChartBarSolid[FILENAME], [[44, 4]]);
var root283 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-1 9a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0v-2Zm2-5a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Zm4 4a1 1 0 1 0-2 0v3a1 1 0 1 0 2 0v-3Z" clip-rule="evenodd"></path></svg>`), FileChartBarSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileChartBarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileChartBarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root283();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1283();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileChartBarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2283();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileChartBarSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileChartBarSolid = hmr(FileChartBarSolid, () => FileChartBarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileChartBarSolid[HMR].source;
    set(FileChartBarSolid[HMR].source, module.default[HMR].original);
  });
}
var FileChartBarSolid_default = FileChartBarSolid;

// node_modules/flowbite-svelte-icons/dist/FileCheckOutline.svelte
FileCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCheckOutline.svelte";
var root_1284 = add_locations(from_svg(`<title> </title>`), FileCheckOutline[FILENAME], [[43, 4]]);
var root_2284 = add_locations(from_svg(`<desc> </desc>`), FileCheckOutline[FILENAME], [[46, 4]]);
var root284 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 6 2 2 4-4m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root284();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1284();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2284();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCheckOutline = hmr(FileCheckOutline, () => FileCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCheckOutline[HMR].source;
    set(FileCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCheckOutline_default = FileCheckOutline;

// node_modules/flowbite-svelte-icons/dist/FileCheckSolid.svelte
FileCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCheckSolid.svelte";
var root_1285 = add_locations(from_svg(`<title> </title>`), FileCheckSolid[FILENAME], [[41, 4]]);
var root_2285 = add_locations(from_svg(`<desc> </desc>`), FileCheckSolid[FILENAME], [[44, 4]]);
var root285 = add_locations(from_svg(`<svg><!><!><path d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Z"></path><path fill-rule="evenodd" d="M11 7V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm4.707 5.707a1 1 0 0 0-1.414-1.414L11 14.586l-1.293-1.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), FileCheckSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function FileCheckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root285();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1285();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCheckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2285();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCheckSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCheckSolid = hmr(FileCheckSolid, () => FileCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCheckSolid[HMR].source;
    set(FileCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCheckSolid_default = FileCheckSolid;

// node_modules/flowbite-svelte-icons/dist/FileCirclePlusOutline.svelte
FileCirclePlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCirclePlusOutline.svelte";
var root_1286 = add_locations(from_svg(`<title> </title>`), FileCirclePlusOutline[FILENAME], [[43, 4]]);
var root_2286 = add_locations(from_svg(`<desc> </desc>`), FileCirclePlusOutline[FILENAME], [[46, 4]]);
var root286 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 9V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h4M9 3v4a1 1 0 0 1-1 1H4m11 6v4m-2-2h4m3 0a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"></path></svg>`), FileCirclePlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCirclePlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCirclePlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root286();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1286();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCirclePlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2286();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCirclePlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCirclePlusOutline = hmr(FileCirclePlusOutline, () => FileCirclePlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCirclePlusOutline[HMR].source;
    set(FileCirclePlusOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCirclePlusOutline_default = FileCirclePlusOutline;

// node_modules/flowbite-svelte-icons/dist/FileCirclePlusSolid.svelte
FileCirclePlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCirclePlusSolid.svelte";
var root_1287 = add_locations(from_svg(`<title> </title>`), FileCirclePlusSolid[FILENAME], [[41, 4]]);
var root_2287 = add_locations(from_svg(`<desc> </desc>`), FileCirclePlusSolid[FILENAME], [[44, 4]]);
var root287 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v6.41A7.5 7.5 0 1 0 10.5 22H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M9 16a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm6-3a1 1 0 0 1 1 1v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 1 1 0-2h1v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), FileCirclePlusSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FileCirclePlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCirclePlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root287();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1287();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCirclePlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2287();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCirclePlusSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCirclePlusSolid = hmr(FileCirclePlusSolid, () => FileCirclePlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCirclePlusSolid[HMR].source;
    set(FileCirclePlusSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCirclePlusSolid_default = FileCirclePlusSolid;

// node_modules/flowbite-svelte-icons/dist/FileCloneOutline.svelte
FileCloneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCloneOutline.svelte";
var root_1288 = add_locations(from_svg(`<title> </title>`), FileCloneOutline[FILENAME], [[43, 4]]);
var root_2288 = add_locations(from_svg(`<desc> </desc>`), FileCloneOutline[FILENAME], [[46, 4]]);
var root288 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M15 4v3a1 1 0 0 1-1 1h-3m2 10v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-7.13a1 1 0 0 1 .24-.65L6.7 8.35A1 1 0 0 1 7.46 8H9m-1 4H4m16-7v10a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1V7.87a1 1 0 0 1 .24-.65l2.46-2.87a1 1 0 0 1 .76-.35H19a1 1 0 0 1 1 1Z"></path></svg>`), FileCloneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCloneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCloneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root288();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1288();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCloneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2288();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCloneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCloneOutline = hmr(FileCloneOutline, () => FileCloneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCloneOutline[HMR].source;
    set(FileCloneOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCloneOutline_default = FileCloneOutline;

// node_modules/flowbite-svelte-icons/dist/FileCloneSolid.svelte
FileCloneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCloneSolid.svelte";
var root_1289 = add_locations(from_svg(`<title> </title>`), FileCloneSolid[FILENAME], [[41, 4]]);
var root_2289 = add_locations(from_svg(`<desc> </desc>`), FileCloneSolid[FILENAME], [[44, 4]]);
var root289 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 12.732A1.99 1.99 0 0 1 7 13H3v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2h-2a4 4 0 0 1-4-4v-2.268ZM7 11V7.054a2 2 0 0 0-1.059.644l-2.46 2.87A2 2 0 0 0 3.2 11H7Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 3.054V7h-3.8c.074-.154.168-.3.282-.432l2.46-2.87A2 2 0 0 1 14 3.054ZM16 3v4a2 2 0 0 1-2 2h-4v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCloneSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FileCloneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCloneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root289();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1289();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCloneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2289();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCloneSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCloneSolid = hmr(FileCloneSolid, () => FileCloneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCloneSolid[HMR].source;
    set(FileCloneSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCloneSolid_default = FileCloneSolid;

// node_modules/flowbite-svelte-icons/dist/FileCodeOutline.svelte
FileCodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCodeOutline.svelte";
var root_1290 = add_locations(from_svg(`<title> </title>`), FileCodeOutline[FILENAME], [[43, 4]]);
var root_2290 = add_locations(from_svg(`<desc> </desc>`), FileCodeOutline[FILENAME], [[46, 4]]);
var root290 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m5 4-2 2 2 2m4-4 2 2-2 2m5-12v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCodeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root290();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1290();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2290();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCodeOutline = hmr(FileCodeOutline, () => FileCodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCodeOutline[HMR].source;
    set(FileCodeOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCodeOutline_default = FileCodeOutline;

// node_modules/flowbite-svelte-icons/dist/FileCodeSolid.svelte
FileCodeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCodeSolid.svelte";
var root_1291 = add_locations(from_svg(`<title> </title>`), FileCodeSolid[FILENAME], [[41, 4]]);
var root_2291 = add_locations(from_svg(`<desc> </desc>`), FileCodeSolid[FILENAME], [[44, 4]]);
var root291 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm-.293 9.293a1 1 0 0 1 0 1.414L9.414 14l1.293 1.293a1 1 0 0 1-1.414 1.414l-2-2a1 1 0 0 1 0-1.414l2-2a1 1 0 0 1 1.414 0Zm2.586 1.414a1 1 0 0 1 1.414-1.414l2 2a1 1 0 0 1 0 1.414l-2 2a1 1 0 0 1-1.414-1.414L14.586 14l-1.293-1.293Z" clip-rule="evenodd"></path></svg>`), FileCodeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCodeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCodeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root291();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1291();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCodeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2291();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCodeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCodeSolid = hmr(FileCodeSolid, () => FileCodeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCodeSolid[HMR].source;
    set(FileCodeSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCodeSolid_default = FileCodeSolid;

// node_modules/flowbite-svelte-icons/dist/FileCopyAltOutline.svelte
FileCopyAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyAltOutline.svelte";
var root_1292 = add_locations(from_svg(`<title> </title>`), FileCopyAltOutline[FILENAME], [[43, 4]]);
var root_2292 = add_locations(from_svg(`<desc> </desc>`), FileCopyAltOutline[FILENAME], [[46, 4]]);
var root292 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M14 4v3a1 1 0 0 1-1 1h-3m4 10v1a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h2m11-3v10a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1V7.87a1 1 0 0 1 .24-.65l2.46-2.87a1 1 0 0 1 .76-.35H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCopyAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCopyAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCopyAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root292();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1292();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCopyAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2292();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCopyAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCopyAltOutline = hmr(FileCopyAltOutline, () => FileCopyAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyAltOutline[HMR].source;
    set(FileCopyAltOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCopyAltOutline_default = FileCopyAltOutline;

// node_modules/flowbite-svelte-icons/dist/FileCopyAltSolid.svelte
FileCopyAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyAltSolid.svelte";
var root_1293 = add_locations(from_svg(`<title> </title>`), FileCopyAltSolid[FILENAME], [[41, 4]]);
var root_2293 = add_locations(from_svg(`<desc> </desc>`), FileCopyAltSolid[FILENAME], [[44, 4]]);
var root293 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7 9v6a4 4 0 0 0 4 4h4a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1v2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M13 3.054V7H9.2a2 2 0 0 1 .281-.432l2.46-2.87A2 2 0 0 1 13 3.054ZM15 3v4a2 2 0 0 1-2 2H9v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCopyAltSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FileCopyAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCopyAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root293();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1293();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCopyAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2293();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCopyAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCopyAltSolid = hmr(FileCopyAltSolid, () => FileCopyAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyAltSolid[HMR].source;
    set(FileCopyAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCopyAltSolid_default = FileCopyAltSolid;

// node_modules/flowbite-svelte-icons/dist/FileCopyOutline.svelte
FileCopyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyOutline.svelte";
var root_1294 = add_locations(from_svg(`<title> </title>`), FileCopyOutline[FILENAME], [[43, 4]]);
var root_2294 = add_locations(from_svg(`<desc> </desc>`), FileCopyOutline[FILENAME], [[46, 4]]);
var root294 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M9 8v3a1 1 0 0 1-1 1H5m11 4h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-7a1 1 0 0 0-1 1v1m4 3v10a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7.13a1 1 0 0 1 .24-.65L7.7 8.35A1 1 0 0 1 8.46 8H13a1 1 0 0 1 1 1Z"></path></svg>`), FileCopyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCopyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCopyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root294();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1294();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCopyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2294();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCopyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCopyOutline = hmr(FileCopyOutline, () => FileCopyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyOutline[HMR].source;
    set(FileCopyOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCopyOutline_default = FileCopyOutline;

// node_modules/flowbite-svelte-icons/dist/FileCopySolid.svelte
FileCopySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopySolid.svelte";
var root_1295 = add_locations(from_svg(`<title> </title>`), FileCopySolid[FILENAME], [[41, 4]]);
var root_2295 = add_locations(from_svg(`<desc> </desc>`), FileCopySolid[FILENAME], [[44, 4]]);
var root295 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M18 3a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1V9a4 4 0 0 0-4-4h-3a1.99 1.99 0 0 0-1 .267V5a2 2 0 0 1 2-2h7Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M8 7.054V11H4.2a2 2 0 0 1 .281-.432l2.46-2.87A2 2 0 0 1 8 7.054ZM10 7v4a2 2 0 0 1-2 2H4v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCopySolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FileCopySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCopySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root295();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1295();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCopySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2295();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCopySolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCopySolid = hmr(FileCopySolid, () => FileCopySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopySolid[HMR].source;
    set(FileCopySolid[HMR].source, module.default[HMR].original);
  });
}
var FileCopySolid_default = FileCopySolid;

// node_modules/flowbite-svelte-icons/dist/FileCsvOutline.svelte
FileCsvOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCsvOutline.svelte";
var root_1296 = add_locations(from_svg(`<title> </title>`), FileCsvOutline[FILENAME], [[43, 4]]);
var root_2296 = add_locations(from_svg(`<desc> </desc>`), FileCsvOutline[FILENAME], [[46, 4]]);
var root296 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m2.665 9H6.647A1.647 1.647 0 0 1 5 15.353v-1.706A1.647 1.647 0 0 1 6.647 12h1.018M16 12l1.443 4.773L19 12m-6.057-.152-.943-.02a1.34 1.34 0 0 0-1.359 1.22 1.32 1.32 0 0 0 1.172 1.421l.536.059a1.273 1.273 0 0 1 1.226 1.718c-.2.571-.636.754-1.337.754h-1.13"></path></svg>`), FileCsvOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileCsvOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCsvOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root296();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1296();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCsvOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2296();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCsvOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCsvOutline = hmr(FileCsvOutline, () => FileCsvOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCsvOutline[HMR].source;
    set(FileCsvOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCsvOutline_default = FileCsvOutline;

// node_modules/flowbite-svelte-icons/dist/FileCsvSolid.svelte
FileCsvSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCsvSolid.svelte";
var root_1297 = add_locations(from_svg(`<title> </title>`), FileCsvSolid[FILENAME], [[41, 4]]);
var root_2297 = add_locations(from_svg(`<desc> </desc>`), FileCsvSolid[FILENAME], [[44, 4]]);
var root297 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm1.018 8.828a2.34 2.34 0 0 0-2.373 2.13v.008a2.32 2.32 0 0 0 2.06 2.497l.535.059a.993.993 0 0 0 .136.006.272.272 0 0 1 .263.367l-.008.02a.377.377 0 0 1-.018.044.49.49 0 0 1-.078.02 1.689 1.689 0 0 1-.297.021h-1.13a1 1 0 1 0 0 2h1.13c.417 0 .892-.05 1.324-.279.47-.248.78-.648.953-1.134a2.272 2.272 0 0 0-2.115-3.06l-.478-.052a.32.32 0 0 1-.285-.341.34.34 0 0 1 .344-.306l.94.02a1 1 0 1 0 .043-2l-.943-.02h-.003Zm7.933 1.482a1 1 0 1 0-1.902-.62l-.57 1.747-.522-1.726a1 1 0 0 0-1.914.578l1.443 4.773a1 1 0 0 0 1.908.021l1.557-4.773Zm-13.762.88a.647.647 0 0 1 .458-.19h1.018a1 1 0 1 0 0-2H6.647A2.647 2.647 0 0 0 4 13.647v1.706A2.647 2.647 0 0 0 6.647 18h1.018a1 1 0 1 0 0-2H6.647A.647.647 0 0 1 6 15.353v-1.706c0-.172.068-.336.19-.457Z" clip-rule="evenodd"></path></svg>`), FileCsvSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCsvSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileCsvSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root297();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1297();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileCsvSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2297();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileCsvSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileCsvSolid = hmr(FileCsvSolid, () => FileCsvSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCsvSolid[HMR].source;
    set(FileCsvSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCsvSolid_default = FileCsvSolid;

// node_modules/flowbite-svelte-icons/dist/FileDocOutline.svelte
FileDocOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileDocOutline.svelte";
var root_1298 = add_locations(from_svg(`<title> </title>`), FileDocOutline[FILENAME], [[43, 4]]);
var root_2298 = add_locations(from_svg(`<desc> </desc>`), FileDocOutline[FILENAME], [[46, 4]]);
var root298 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m14 9.006h-.335a1.647 1.647 0 0 1-1.647-1.647v-1.706a1.647 1.647 0 0 1 1.647-1.647L19 12M5 12v5h1.375A1.626 1.626 0 0 0 8 15.375v-1.75A1.626 1.626 0 0 0 6.375 12H5Zm9 1.5v2a1.5 1.5 0 0 1-1.5 1.5v0a1.5 1.5 0 0 1-1.5-1.5v-2a1.5 1.5 0 0 1 1.5-1.5v0a1.5 1.5 0 0 1 1.5 1.5Z"></path></svg>`), FileDocOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileDocOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileDocOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root298();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1298();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileDocOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2298();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileDocOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileDocOutline = hmr(FileDocOutline, () => FileDocOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileDocOutline[HMR].source;
    set(FileDocOutline[HMR].source, module.default[HMR].original);
  });
}
var FileDocOutline_default = FileDocOutline;

// node_modules/flowbite-svelte-icons/dist/FileDocSolid.svelte
FileDocSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileDocSolid.svelte";
var root_1299 = add_locations(from_svg(`<title> </title>`), FileDocSolid[FILENAME], [[41, 4]]);
var root_2299 = add_locations(from_svg(`<desc> </desc>`), FileDocSolid[FILENAME], [[44, 4]]);
var root299 = add_locations(from_svg(`<svg><!><!><path d="M6 16v-3h.375a.626.626 0 0 1 .625.626v1.749a.626.626 0 0 1-.626.625H6Zm6-2.5a.5.5 0 1 1 1 0v2a.5.5 0 0 1-1 0v-2Z"></path><path fill-rule="evenodd" d="M11 7V2h7a2 2 0 0 1 2 2v5h1a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-1a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2H3a1 1 0 0 1-1-1v-9a1 1 0 0 1 1-1h6a2 2 0 0 0 2-2Zm7.683 6.006 1.335-.024-.037-2-1.327.024a2.647 2.647 0 0 0-2.636 2.647v1.706a2.647 2.647 0 0 0 2.647 2.647H20v-2h-1.335a.647.647 0 0 1-.647-.647v-1.706a.647.647 0 0 1 .647-.647h.018ZM5 11a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h1.376A2.626 2.626 0 0 0 9 15.375v-1.75A2.626 2.626 0 0 0 6.375 11H5Zm7.5 0a2.5 2.5 0 0 0-2.5 2.5v2a2.5 2.5 0 0 0 5 0v-2a2.5 2.5 0 0 0-2.5-2.5Z" clip-rule="evenodd"></path><path d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Z"></path></svg>`), FileDocSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [53, 5]]]]);
function FileDocSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileDocSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root299();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1299();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileDocSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2299();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileDocSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileDocSolid = hmr(FileDocSolid, () => FileDocSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileDocSolid[HMR].source;
    set(FileDocSolid[HMR].source, module.default[HMR].original);
  });
}
var FileDocSolid_default = FileDocSolid;

// node_modules/flowbite-svelte-icons/dist/FileExportOutline.svelte
FileExportOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileExportOutline.svelte";
var root_1300 = add_locations(from_svg(`<title> </title>`), FileExportOutline[FILENAME], [[43, 4]]);
var root_2300 = add_locations(from_svg(`<desc> </desc>`), FileExportOutline[FILENAME], [[46, 4]]);
var root300 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 10V4a1 1 0 0 0-1-1H9.914a1 1 0 0 0-.707.293L5.293 7.207A1 1 0 0 0 5 7.914V20a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2M10 3v4a1 1 0 0 1-1 1H5m5 6h9m0 0-2-2m2 2-2 2"></path></svg>`), FileExportOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileExportOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileExportOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root300();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1300();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileExportOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2300();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileExportOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileExportOutline = hmr(FileExportOutline, () => FileExportOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileExportOutline[HMR].source;
    set(FileExportOutline[HMR].source, module.default[HMR].original);
  });
}
var FileExportOutline_default = FileExportOutline;

// node_modules/flowbite-svelte-icons/dist/FileExportSolid.svelte
FileExportSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileExportSolid.svelte";
var root_1301 = add_locations(from_svg(`<title> </title>`), FileExportSolid[FILENAME], [[41, 4]]);
var root_2301 = add_locations(from_svg(`<desc> </desc>`), FileExportSolid[FILENAME], [[44, 4]]);
var root301 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v9.293l-2-2a1 1 0 0 0-1.414 1.414l.293.293h-6.586a1 1 0 1 0 0 2h6.586l-.293.293A1 1 0 0 0 18 16.707l2-2V20a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path></svg>`), FileExportSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileExportSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileExportSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root301();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1301();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileExportSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2301();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileExportSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileExportSolid = hmr(FileExportSolid, () => FileExportSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileExportSolid[HMR].source;
    set(FileExportSolid[HMR].source, module.default[HMR].original);
  });
}
var FileExportSolid_default = FileExportSolid;

// node_modules/flowbite-svelte-icons/dist/FileImageOutline.svelte
FileImageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImageOutline.svelte";
var root_1302 = add_locations(from_svg(`<title> </title>`), FileImageOutline[FILENAME], [[43, 4]]);
var root_2302 = add_locations(from_svg(`<desc> </desc>`), FileImageOutline[FILENAME], [[46, 4]]);
var root302 = add_locations(from_svg(`<svg><!><!><path d="M16 18H8l2.5-6 2 4 1.5-2 2 4Zm-1-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM8 18h8l-2-4-1.5 2-2-4L8 18Zm7-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"></path></svg>`), FileImageOutline[FILENAME], [[31, 0, [[48, 2], [49, 2]]]]);
function FileImageOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileImageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root302();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1302();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileImageOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2302();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileImageOutline,
      45,
      2
    );
  }
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileImageOutline = hmr(FileImageOutline, () => FileImageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImageOutline[HMR].source;
    set(FileImageOutline[HMR].source, module.default[HMR].original);
  });
}
var FileImageOutline_default = FileImageOutline;

// node_modules/flowbite-svelte-icons/dist/FileImageSolid.svelte
FileImageSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImageSolid.svelte";
var root_1303 = add_locations(from_svg(`<title> </title>`), FileImageSolid[FILENAME], [[41, 4]]);
var root_2303 = add_locations(from_svg(`<desc> </desc>`), FileImageSolid[FILENAME], [[44, 4]]);
var root303 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm.394 9.553a1 1 0 0 0-1.817.062l-2.5 6A1 1 0 0 0 8 19h8a1 1 0 0 0 .894-1.447l-2-4A1 1 0 0 0 13.2 13.4l-.53.706-1.276-2.553ZM13 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z" clip-rule="evenodd"></path></svg>`), FileImageSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileImageSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileImageSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root303();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1303();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileImageSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2303();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileImageSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileImageSolid = hmr(FileImageSolid, () => FileImageSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImageSolid[HMR].source;
    set(FileImageSolid[HMR].source, module.default[HMR].original);
  });
}
var FileImageSolid_default = FileImageSolid;

// node_modules/flowbite-svelte-icons/dist/FileImportOutline.svelte
FileImportOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImportOutline.svelte";
var root_1304 = add_locations(from_svg(`<title> </title>`), FileImportOutline[FILENAME], [[43, 4]]);
var root_2304 = add_locations(from_svg(`<desc> </desc>`), FileImportOutline[FILENAME], [[46, 4]]);
var root304 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-4m5-13v4a1 1 0 0 1-1 1H5m0 6h9m0 0-2-2m2 2-2 2"></path></svg>`), FileImportOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileImportOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileImportOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root304();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1304();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileImportOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2304();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileImportOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileImportOutline = hmr(FileImportOutline, () => FileImportOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImportOutline[HMR].source;
    set(FileImportOutline[HMR].source, module.default[HMR].original);
  });
}
var FileImportOutline_default = FileImportOutline;

// node_modules/flowbite-svelte-icons/dist/FileImportSolid.svelte
FileImportSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImportSolid.svelte";
var root_1305 = add_locations(from_svg(`<title> </title>`), FileImportSolid[FILENAME], [[41, 4]]);
var root_2305 = add_locations(from_svg(`<desc> </desc>`), FileImportSolid[FILENAME], [[44, 4]]);
var root305 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-5h7.586l-.293.293a1 1 0 0 0 1.414 1.414l2-2a1 1 0 0 0 0-1.414l-2-2a1 1 0 0 0-1.414 1.414l.293.293H4V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path></svg>`), FileImportSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileImportSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileImportSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root305();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1305();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileImportSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2305();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileImportSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileImportSolid = hmr(FileImportSolid, () => FileImportSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImportSolid[HMR].source;
    set(FileImportSolid[HMR].source, module.default[HMR].original);
  });
}
var FileImportSolid_default = FileImportSolid;

// node_modules/flowbite-svelte-icons/dist/FileInvoiceOutline.svelte
FileInvoiceOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileInvoiceOutline.svelte";
var root_1306 = add_locations(from_svg(`<title> </title>`), FileInvoiceOutline[FILENAME], [[43, 4]]);
var root_2306 = add_locations(from_svg(`<desc> </desc>`), FileInvoiceOutline[FILENAME], [[46, 4]]);
var root306 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8-2h3m-3 3h3m-4 3v6m4-3H8M19 4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM8 12v6h8v-6H8Z"></path></svg>`), FileInvoiceOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileInvoiceOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileInvoiceOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root306();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1306();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileInvoiceOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2306();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileInvoiceOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileInvoiceOutline = hmr(FileInvoiceOutline, () => FileInvoiceOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileInvoiceOutline[HMR].source;
    set(FileInvoiceOutline[HMR].source, module.default[HMR].original);
  });
}
var FileInvoiceOutline_default = FileInvoiceOutline;

// node_modules/flowbite-svelte-icons/dist/FileInvoiceSolid.svelte
FileInvoiceSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileInvoiceSolid.svelte";
var root_1307 = add_locations(from_svg(`<title> </title>`), FileInvoiceSolid[FILENAME], [[41, 4]]);
var root_2307 = add_locations(from_svg(`<desc> </desc>`), FileInvoiceSolid[FILENAME], [[44, 4]]);
var root307 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm2-2a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm0 3a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm-6 4a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-6Zm8 1v1h-2v-1h2Zm0 3h-2v1h2v-1Zm-4-3v1H9v-1h2Zm0 3H9v1h2v-1Z" clip-rule="evenodd"></path></svg>`), FileInvoiceSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileInvoiceSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileInvoiceSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root307();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1307();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileInvoiceSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2307();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileInvoiceSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileInvoiceSolid = hmr(FileInvoiceSolid, () => FileInvoiceSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileInvoiceSolid[HMR].source;
    set(FileInvoiceSolid[HMR].source, module.default[HMR].original);
  });
}
var FileInvoiceSolid_default = FileInvoiceSolid;

// node_modules/flowbite-svelte-icons/dist/FileLinesOutline.svelte
FileLinesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileLinesOutline.svelte";
var root_1308 = add_locations(from_svg(`<title> </title>`), FileLinesOutline[FILENAME], [[43, 4]]);
var root_2308 = add_locations(from_svg(`<desc> </desc>`), FileLinesOutline[FILENAME], [[46, 4]]);
var root308 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 8h6m-6-4h6m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileLinesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileLinesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileLinesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root308();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1308();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileLinesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2308();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileLinesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileLinesOutline = hmr(FileLinesOutline, () => FileLinesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileLinesOutline[HMR].source;
    set(FileLinesOutline[HMR].source, module.default[HMR].original);
  });
}
var FileLinesOutline_default = FileLinesOutline;

// node_modules/flowbite-svelte-icons/dist/FileLinesSolid.svelte
FileLinesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileLinesSolid.svelte";
var root_1309 = add_locations(from_svg(`<title> </title>`), FileLinesSolid[FILENAME], [[41, 4]]);
var root_2309 = add_locations(from_svg(`<desc> </desc>`), FileLinesSolid[FILENAME], [[44, 4]]);
var root309 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7ZM8 16a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm1-5a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), FileLinesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileLinesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileLinesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root309();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1309();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileLinesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2309();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileLinesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileLinesSolid = hmr(FileLinesSolid, () => FileLinesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileLinesSolid[HMR].source;
    set(FileLinesSolid[HMR].source, module.default[HMR].original);
  });
}
var FileLinesSolid_default = FileLinesSolid;

// node_modules/flowbite-svelte-icons/dist/FileMusicOutline.svelte
FileMusicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileMusicOutline.svelte";
var root_1310 = add_locations(from_svg(`<title> </title>`), FileMusicOutline[FILENAME], [[43, 4]]);
var root_2310 = add_locations(from_svg(`<desc> </desc>`), FileMusicOutline[FILENAME], [[46, 4]]);
var root310 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8 7.5V8s3 1 3 4m3-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-6 12c0 1.105-1.12 2-2.5 2S8 17.105 8 16s1.12-2 2.5-2 2.5.895 2.5 2Z"></path></svg>`), FileMusicOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileMusicOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileMusicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root310();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1310();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileMusicOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2310();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileMusicOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileMusicOutline = hmr(FileMusicOutline, () => FileMusicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileMusicOutline[HMR].source;
    set(FileMusicOutline[HMR].source, module.default[HMR].original);
  });
}
var FileMusicOutline_default = FileMusicOutline;

// node_modules/flowbite-svelte-icons/dist/FileMusicSolid.svelte
FileMusicSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileMusicSolid.svelte";
var root_1311 = add_locations(from_svg(`<title> </title>`), FileMusicSolid[FILENAME], [[41, 4]]);
var root_2311 = add_locations(from_svg(`<desc> </desc>`), FileMusicSolid[FILENAME], [[44, 4]]);
var root311 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm2.318.052h-.002A1 1 0 0 0 12 8v5.293A4.033 4.033 0 0 0 10.5 13C8.787 13 7 14.146 7 16s1.787 3 3.5 3 3.5-1.146 3.5-3c0-.107-.006-.211-.017-.313A1.04 1.04 0 0 0 14 15.5V9.766c.538.493 1 1.204 1 2.234a1 1 0 1 0 2 0c0-1.881-.956-3.14-1.86-3.893a6.4 6.4 0 0 0-1.636-.985 4.009 4.009 0 0 0-.165-.063l-.014-.005-.005-.001-.002-.001ZM9 16c0-.356.452-1 1.5-1s1.5.644 1.5 1-.452 1-1.5 1S9 16.356 9 16Z" clip-rule="evenodd"></path></svg>`), FileMusicSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileMusicSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileMusicSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root311();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1311();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileMusicSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2311();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileMusicSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileMusicSolid = hmr(FileMusicSolid, () => FileMusicSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileMusicSolid[HMR].source;
    set(FileMusicSolid[HMR].source, module.default[HMR].original);
  });
}
var FileMusicSolid_default = FileMusicSolid;

// node_modules/flowbite-svelte-icons/dist/FileOutline.svelte
FileOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileOutline.svelte";
var root_1312 = add_locations(from_svg(`<title> </title>`), FileOutline[FILENAME], [[43, 4]]);
var root_2312 = add_locations(from_svg(`<desc> </desc>`), FileOutline[FILENAME], [[46, 4]]);
var root312 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root312();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1312();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2312();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileOutline = hmr(FileOutline, () => FileOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileOutline[HMR].source;
    set(FileOutline[HMR].source, module.default[HMR].original);
  });
}
var FileOutline_default = FileOutline;

// node_modules/flowbite-svelte-icons/dist/FilePasteOutline.svelte
FilePasteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePasteOutline.svelte";
var root_1313 = add_locations(from_svg(`<title> </title>`), FilePasteOutline[FILENAME], [[43, 4]]);
var root_2313 = add_locations(from_svg(`<desc> </desc>`), FilePasteOutline[FILENAME], [[46, 4]]);
var root313 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 20H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h2.429M7 8h3M8 8V4h4v2m4 0V5h-4m3 4v3a1 1 0 0 1-1 1h-3m9-3v9a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-6.397a1 1 0 0 1 .27-.683l2.434-2.603a1 1 0 0 1 .73-.317H19a1 1 0 0 1 1 1Z"></path></svg>`), FilePasteOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilePasteOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePasteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root313();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1313();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePasteOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2313();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePasteOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePasteOutline = hmr(FilePasteOutline, () => FilePasteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePasteOutline[HMR].source;
    set(FilePasteOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePasteOutline_default = FilePasteOutline;

// node_modules/flowbite-svelte-icons/dist/FilePasteSolid.svelte
FilePasteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePasteSolid.svelte";
var root_1314 = add_locations(from_svg(`<title> </title>`), FilePasteSolid[FILENAME], [[41, 4]]);
var root_2314 = add_locations(from_svg(`<desc> </desc>`), FilePasteSolid[FILENAME], [[44, 4]]);
var root314 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6.5 3.85c0-.47.392-.85.875-.85h5.25c.483 0 .875.38.875.85h1.75c.966 0 1.75.761 1.75 1.7V6h-1c-.728 0-1.732-.06-2.434.095a4.01 4.01 0 0 0-.88.307.91.91 0 0 0-.061-.002h-.875V4.7h-3.5v1.7h-.875a.863.863 0 0 0-.875.85c0 .47.392.85.875.85h3.36L9.077 9.871a4 4 0 0 0-.892 1.526C7.97 12.083 8 13.268 8 14v5c0 .729.195 1.412.535 2H4.75C3.784 21 3 20.239 3 19.3V5.55c0-.939.784-1.7 1.75-1.7H6.5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 8.048V12h-3.907a2 2 0 0 1 .446-.763l2.434-2.603A2 2 0 0 1 14 8.048ZM16 8v4a2 2 0 0 1-2 2h-4v5a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FilePasteSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FilePasteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePasteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root314();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1314();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePasteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2314();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePasteSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePasteSolid = hmr(FilePasteSolid, () => FilePasteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePasteSolid[HMR].source;
    set(FilePasteSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePasteSolid_default = FilePasteSolid;

// node_modules/flowbite-svelte-icons/dist/FilePdfOutline.svelte
FilePdfOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePdfOutline.svelte";
var root_1315 = add_locations(from_svg(`<title> </title>`), FilePdfOutline[FILENAME], [[43, 4]]);
var root_2315 = add_locations(from_svg(`<desc> </desc>`), FilePdfOutline[FILENAME], [[46, 4]]);
var root315 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 17v-5h1.5a1.5 1.5 0 1 1 0 3H5m12 2v-5h2m-2 3h2M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m6 4v5h1.375A1.627 1.627 0 0 0 14 15.375v-1.75A1.627 1.627 0 0 0 12.375 12H11Z"></path></svg>`), FilePdfOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilePdfOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePdfOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root315();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1315();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePdfOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2315();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePdfOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePdfOutline = hmr(FilePdfOutline, () => FilePdfOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePdfOutline[HMR].source;
    set(FilePdfOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePdfOutline_default = FilePdfOutline;

// node_modules/flowbite-svelte-icons/dist/FilePdfSolid.svelte
FilePdfSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePdfSolid.svelte";
var root_1316 = add_locations(from_svg(`<title> </title>`), FilePdfSolid[FILENAME], [[41, 4]]);
var root_2316 = add_locations(from_svg(`<desc> </desc>`), FilePdfSolid[FILENAME], [[44, 4]]);
var root316 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm-6 9a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H5Zm1.5 3H6v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h1.376A2.626 2.626 0 0 0 15 15.375v-1.75A2.626 2.626 0 0 0 12.375 11H11Zm1 5v-3h.375a.626.626 0 0 1 .625.626v1.748a.625.625 0 0 1-.626.626H12Zm5-5a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h1a1 1 0 1 0 0-2h-1v-1h1a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), FilePdfSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePdfSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePdfSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root316();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1316();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePdfSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2316();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePdfSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePdfSolid = hmr(FilePdfSolid, () => FilePdfSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePdfSolid[HMR].source;
    set(FilePdfSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePdfSolid_default = FilePdfSolid;

// node_modules/flowbite-svelte-icons/dist/FilePenOutline.svelte
FilePenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePenOutline.svelte";
var root_1317 = add_locations(from_svg(`<title> </title>`), FilePenOutline[FILENAME], [[43, 4]]);
var root_2317 = add_locations(from_svg(`<desc> </desc>`), FilePenOutline[FILENAME], [[46, 4]]);
var root317 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 5V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-5M9 3v4a1 1 0 0 1-1 1H4m11.383.772 2.745 2.746m1.215-3.906a2.089 2.089 0 0 1 0 2.953l-6.65 6.646L9 17.95l.739-3.692 6.646-6.646a2.087 2.087 0 0 1 2.958 0Z"></path></svg>`), FilePenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilePenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root317();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1317();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2317();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePenOutline = hmr(FilePenOutline, () => FilePenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePenOutline[HMR].source;
    set(FilePenOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePenOutline_default = FilePenOutline;

// node_modules/flowbite-svelte-icons/dist/FilePenSolid.svelte
FilePenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePenSolid.svelte";
var root_1318 = add_locations(from_svg(`<title> </title>`), FilePenSolid[FILENAME], [[41, 4]]);
var root_2318 = add_locations(from_svg(`<desc> </desc>`), FilePenSolid[FILENAME], [[44, 4]]);
var root318 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 7V2.221a2 2 0 0 0-.5.365L3.586 6.5a2 2 0 0 0-.365.5H8Zm2 0V2h7a2 2 0 0 1 2 2v.126a5.087 5.087 0 0 0-4.74 1.368v.001l-6.642 6.642a3 3 0 0 0-.82 1.532l-.74 3.692a3 3 0 0 0 3.53 3.53l3.694-.738a3 3 0 0 0 1.532-.82L19 15.149V20a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M17.447 8.08a1.087 1.087 0 0 1 1.187.238l.002.001a1.088 1.088 0 0 1 0 1.539l-.377.377-1.54-1.542.373-.374.002-.001c.1-.102.22-.182.353-.237Zm-2.143 2.027-4.644 4.644-.385 1.924 1.925-.385 4.644-4.642-1.54-1.54Zm2.56-4.11a3.087 3.087 0 0 0-2.187.909l-6.645 6.645a1 1 0 0 0-.274.51l-.739 3.693a1 1 0 0 0 1.177 1.176l3.693-.738a1 1 0 0 0 .51-.274l6.65-6.646a3.088 3.088 0 0 0-2.185-5.275Z" clip-rule="evenodd"></path></svg>`), FilePenSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FilePenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root318();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1318();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2318();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePenSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePenSolid = hmr(FilePenSolid, () => FilePenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePenSolid[HMR].source;
    set(FilePenSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePenSolid_default = FilePenSolid;

// node_modules/flowbite-svelte-icons/dist/FilePptOutline.svelte
FilePptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePptOutline.svelte";
var root_1319 = add_locations(from_svg(`<title> </title>`), FilePptOutline[FILENAME], [[43, 4]]);
var root_2319 = add_locations(from_svg(`<desc> </desc>`), FilePptOutline[FILENAME], [[46, 4]]);
var root319 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 17v-5h1.5a1.5 1.5 0 1 1 0 3H5m6 2v-5h1.5a1.5 1.5 0 1 1 0 3H11m7-3v5m-1-5h2M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5"></path></svg>`), FilePptOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilePptOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root319();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1319();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePptOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2319();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePptOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePptOutline = hmr(FilePptOutline, () => FilePptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePptOutline[HMR].source;
    set(FilePptOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePptOutline_default = FilePptOutline;

// node_modules/flowbite-svelte-icons/dist/FilePptSolid.svelte
FilePptSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePptSolid.svelte";
var root_1320 = add_locations(from_svg(`<title> </title>`), FilePptSolid[FILENAME], [[41, 4]]);
var root_2320 = add_locations(from_svg(`<desc> </desc>`), FilePptSolid[FILENAME], [[44, 4]]);
var root320 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm-6 9a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H5Zm1.5 3H6v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H11Zm1.5 3H12v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 1 0 0 2v4a1 1 0 1 0 2 0v-4a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), FilePptSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePptSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilePptSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root320();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1320();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilePptSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2320();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilePptSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilePptSolid = hmr(FilePptSolid, () => FilePptSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePptSolid[HMR].source;
    set(FilePptSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePptSolid_default = FilePptSolid;

// node_modules/flowbite-svelte-icons/dist/FileSearchOutline.svelte
FileSearchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSearchOutline.svelte";
var root_1321 = add_locations(from_svg(`<title> </title>`), FileSearchOutline[FILENAME], [[43, 4]]);
var root_2321 = add_locations(from_svg(`<desc> </desc>`), FileSearchOutline[FILENAME], [[46, 4]]);
var root321 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8 7.5 2.5 2.5M19 4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-5 9.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), FileSearchOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileSearchOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileSearchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root321();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1321();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileSearchOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2321();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileSearchOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileSearchOutline = hmr(FileSearchOutline, () => FileSearchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSearchOutline[HMR].source;
    set(FileSearchOutline[HMR].source, module.default[HMR].original);
  });
}
var FileSearchOutline_default = FileSearchOutline;

// node_modules/flowbite-svelte-icons/dist/FileSearchSolid.svelte
FileSearchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSearchSolid.svelte";
var root_1322 = add_locations(from_svg(`<title> </title>`), FileSearchSolid[FILENAME], [[41, 4]]);
var root_2322 = add_locations(from_svg(`<desc> </desc>`), FileSearchSolid[FILENAME], [[44, 4]]);
var root322 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm.5 5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm0 5c.47 0 .917-.092 1.326-.26l1.967 1.967a1 1 0 0 0 1.414-1.414l-1.817-1.818A3.5 3.5 0 1 0 11.5 17Z" clip-rule="evenodd"></path></svg>`), FileSearchSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileSearchSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileSearchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root322();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1322();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileSearchSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2322();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileSearchSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileSearchSolid = hmr(FileSearchSolid, () => FileSearchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSearchSolid[HMR].source;
    set(FileSearchSolid[HMR].source, module.default[HMR].original);
  });
}
var FileSearchSolid_default = FileSearchSolid;

// node_modules/flowbite-svelte-icons/dist/FileShieldOutline.svelte
FileShieldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileShieldOutline.svelte";
var root_1323 = add_locations(from_svg(`<title> </title>`), FileShieldOutline[FILENAME], [[43, 4]]);
var root_2323 = add_locations(from_svg(`<desc> </desc>`), FileShieldOutline[FILENAME], [[46, 4]]);
var root323 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 9V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h6M9 3v4a1 1 0 0 1-1 1H4m11 13a11.426 11.426 0 0 1-3.637-3.99A11.139 11.139 0 0 1 10 11.833L15 10l5 1.833a11.137 11.137 0 0 1-1.363 5.176A11.425 11.425 0 0 1 15.001 21Z"></path></svg>`), FileShieldOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileShieldOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileShieldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root323();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1323();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileShieldOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2323();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileShieldOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileShieldOutline = hmr(FileShieldOutline, () => FileShieldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileShieldOutline[HMR].source;
    set(FileShieldOutline[HMR].source, module.default[HMR].original);
  });
}
var FileShieldOutline_default = FileShieldOutline;

// node_modules/flowbite-svelte-icons/dist/FileShieldSolid.svelte
FileShieldSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileShieldSolid.svelte";
var root_1324 = add_locations(from_svg(`<title> </title>`), FileShieldSolid[FILENAME], [[41, 4]]);
var root_2324 = add_locations(from_svg(`<desc> </desc>`), FileShieldSolid[FILENAME], [[44, 4]]);
var root324 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v5.703l-4.311-1.58a2 2 0 0 0-1.377 0l-5 1.832A2 2 0 0 0 8 11.861c.03 2.134.582 4.228 1.607 6.106.848 1.555 2 2.924 3.382 4.033H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M15.345 9.061a1 1 0 0 0-.689 0l-5 1.833a1 1 0 0 0-.656.953c.028 1.97.538 3.905 1.485 5.641a12.425 12.425 0 0 0 3.956 4.34 1 1 0 0 0 1.12 0 12.426 12.426 0 0 0 3.954-4.34A12.14 12.14 0 0 0 21 11.848a1 1 0 0 0-.656-.954l-5-1.833ZM15 19.765a10.401 10.401 0 0 0 2.76-3.235 10.15 10.15 0 0 0 1.206-4.011L15 11.065v8.7Z" clip-rule="evenodd"></path></svg>`), FileShieldSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FileShieldSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileShieldSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root324();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1324();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileShieldSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2324();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileShieldSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileShieldSolid = hmr(FileShieldSolid, () => FileShieldSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileShieldSolid[HMR].source;
    set(FileShieldSolid[HMR].source, module.default[HMR].original);
  });
}
var FileShieldSolid_default = FileShieldSolid;

// node_modules/flowbite-svelte-icons/dist/FileSolid.svelte
FileSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSolid.svelte";
var root_1325 = add_locations(from_svg(`<title> </title>`), FileSolid[FILENAME], [[41, 4]]);
var root_2325 = add_locations(from_svg(`<desc> </desc>`), FileSolid[FILENAME], [[44, 4]]);
var root325 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Z" clip-rule="evenodd"></path></svg>`), FileSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root325();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1325();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2325();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileSolid = hmr(FileSolid, () => FileSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSolid[HMR].source;
    set(FileSolid[HMR].source, module.default[HMR].original);
  });
}
var FileSolid_default = FileSolid;

// node_modules/flowbite-svelte-icons/dist/FileVideoOutline.svelte
FileVideoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileVideoOutline.svelte";
var root_1326 = add_locations(from_svg(`<title> </title>`), FileVideoOutline[FILENAME], [[43, 4]]);
var root_2326 = add_locations(from_svg(`<desc> </desc>`), FileVideoOutline[FILENAME], [[46, 4]]);
var root326 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM9 12h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1Zm5.697 2.395v-.733l1.269-1.219v2.984l-1.268-1.032Z"></path></svg>`), FileVideoOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileVideoOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileVideoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root326();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1326();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileVideoOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2326();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileVideoOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileVideoOutline = hmr(FileVideoOutline, () => FileVideoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileVideoOutline[HMR].source;
    set(FileVideoOutline[HMR].source, module.default[HMR].original);
  });
}
var FileVideoOutline_default = FileVideoOutline;

// node_modules/flowbite-svelte-icons/dist/FileVideoSolid.svelte
FileVideoSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileVideoSolid.svelte";
var root_1327 = add_locations(from_svg(`<title> </title>`), FileVideoSolid[FILENAME], [[41, 4]]);
var root_2327 = add_locations(from_svg(`<desc> </desc>`), FileVideoSolid[FILENAME], [[44, 4]]);
var root327 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-2 4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H9Zm0 2h2v2H9v-2Zm7.965-.557a1 1 0 0 0-1.692-.72l-1.268 1.218a1 1 0 0 0-.308.721v.733a1 1 0 0 0 .37.776l1.267 1.032a1 1 0 0 0 1.631-.776v-2.984Z" clip-rule="evenodd"></path></svg>`), FileVideoSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileVideoSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileVideoSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root327();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1327();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileVideoSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2327();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileVideoSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileVideoSolid = hmr(FileVideoSolid, () => FileVideoSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileVideoSolid[HMR].source;
    set(FileVideoSolid[HMR].source, module.default[HMR].original);
  });
}
var FileVideoSolid_default = FileVideoSolid;

// node_modules/flowbite-svelte-icons/dist/FileWordOutline.svelte
FileWordOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileWordOutline.svelte";
var root_1328 = add_locations(from_svg(`<title> </title>`), FileWordOutline[FILENAME], [[43, 4]]);
var root_2328 = add_locations(from_svg(`<desc> </desc>`), FileWordOutline[FILENAME], [[46, 4]]);
var root328 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 4 1 5 2-3.333L14 17l1-5m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileWordOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileWordOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileWordOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root328();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1328();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileWordOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2328();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileWordOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileWordOutline = hmr(FileWordOutline, () => FileWordOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileWordOutline[HMR].source;
    set(FileWordOutline[HMR].source, module.default[HMR].original);
  });
}
var FileWordOutline_default = FileWordOutline;

// node_modules/flowbite-svelte-icons/dist/FileWordSolid.svelte
FileWordSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileWordSolid.svelte";
var root_1329 = add_locations(from_svg(`<title> </title>`), FileWordSolid[FILENAME], [[41, 4]]);
var root_2329 = add_locations(from_svg(`<desc> </desc>`), FileWordSolid[FILENAME], [[44, 4]]);
var root329 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-1.02 4.804a1 1 0 1 0-1.96.392l1 5a1 1 0 0 0 1.838.319L12 15.61l1.143 1.905a1 1 0 0 0 1.838-.319l1-5a1 1 0 0 0-1.962-.392l-.492 2.463-.67-1.115a1 1 0 0 0-1.714 0l-.67 1.116-.492-2.464Z" clip-rule="evenodd"></path></svg>`), FileWordSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileWordSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileWordSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root329();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1329();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileWordSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2329();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileWordSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileWordSolid = hmr(FileWordSolid, () => FileWordSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileWordSolid[HMR].source;
    set(FileWordSolid[HMR].source, module.default[HMR].original);
  });
}
var FileWordSolid_default = FileWordSolid;

// node_modules/flowbite-svelte-icons/dist/FileZipOutline.svelte
FileZipOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileZipOutline.svelte";
var root_1330 = add_locations(from_svg(`<title> </title>`), FileZipOutline[FILENAME], [[43, 4]]);
var root_2330 = add_locations(from_svg(`<desc> </desc>`), FileZipOutline[FILENAME], [[46, 4]]);
var root330 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-4 1h.01v.01H15V5Zm-2 2h.01v.01H13V7Zm2 2h.01v.01H15V9Zm-2 2h.01v.01H13V11Zm2 2h.01v.01H15V13Zm-2 2h.01v.01H13V15Zm2 2h.01v.01H15V17Zm-2 2h.01v.01H13V19Z"></path></svg>`), FileZipOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FileZipOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileZipOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root330();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1330();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileZipOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2330();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileZipOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileZipOutline = hmr(FileZipOutline, () => FileZipOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileZipOutline[HMR].source;
    set(FileZipOutline[HMR].source, module.default[HMR].original);
  });
}
var FileZipOutline_default = FileZipOutline;

// node_modules/flowbite-svelte-icons/dist/FileZipSolid.svelte
FileZipSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileZipSolid.svelte";
var root_1331 = add_locations(from_svg(`<title> </title>`), FileZipSolid[FILENAME], [[41, 4]]);
var root_2331 = add_locations(from_svg(`<desc> </desc>`), FileZipSolid[FILENAME], [[44, 4]]);
var root331 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm3 2h2.01v2.01h-2V8h2v2.01h-2V12h2v2.01h-2V16h2v2.01h-2v2H12V18h2v-1.99h-2V14h2v-1.99h-2V10h2V8.01h-2V6h2V4Z" clip-rule="evenodd"></path></svg>`), FileZipSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FileZipSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FileZipSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root331();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1331();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FileZipSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2331();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FileZipSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FileZipSolid = hmr(FileZipSolid, () => FileZipSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileZipSolid[HMR].source;
    set(FileZipSolid[HMR].source, module.default[HMR].original);
  });
}
var FileZipSolid_default = FileZipSolid;

// node_modules/flowbite-svelte-icons/dist/FilterDollarOutline.svelte
FilterDollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterDollarOutline.svelte";
var root_1332 = add_locations(from_svg(`<title> </title>`), FilterDollarOutline[FILENAME], [[43, 4]]);
var root_2332 = add_locations(from_svg(`<desc> </desc>`), FilterDollarOutline[FILENAME], [[46, 4]]);
var root332 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m11.0001 18-.8536-.8536c-.0937-.0937-.1464-.2209-.1464-.3535v-4.4172c0-.2422-.08794-.4762-.24744-.6585L4.45127 5.6585C3.88551 5.01192 4.34469 4 5.20385 4H18.7547c.8658 0 1.3225 1.02544.7433 1.66896L16.5001 9m-2.5 9.3754c.3347.3615.7824.6134 1.2788.7195.4771.1584 1.0002.1405 1.464-.05.4638-.1906.8338-.5396 1.0356-.977.2462-.8286-.6363-1.7337-1.7735-1.9948-1.1372-.2611-2.016-1.1604-1.7735-1.9948.2016-.4375.5716-.7868 1.0354-.9774.4639-.1905.9871-.2082 1.4643-.0496.491.1045.9348.3517 1.2689.7067m-1.9397 5.41V20m0-8v.9771"></path></svg>`), FilterDollarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilterDollarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilterDollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root332();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1332();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilterDollarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2332();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilterDollarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilterDollarOutline = hmr(FilterDollarOutline, () => FilterDollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterDollarOutline[HMR].source;
    set(FilterDollarOutline[HMR].source, module.default[HMR].original);
  });
}
var FilterDollarOutline_default = FilterDollarOutline;

// node_modules/flowbite-svelte-icons/dist/FilterDollarSolid.svelte
FilterDollarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterDollarSolid.svelte";
var root_1333 = add_locations(from_svg(`<title> </title>`), FilterDollarSolid[FILENAME], [[41, 4]]);
var root_2333 = add_locations(from_svg(`<desc> </desc>`), FilterDollarSolid[FILENAME], [[44, 4]]);
var root333 = add_locations(from_svg(`<svg><!><!><path d="M3.69869 6.31701C2.56717 5.02384 3.48553 3 5.20384 3H18.7547c1.7316 0 2.6449 2.05088 1.4866 3.33793L17.47 9.34198s-.4632-.20588-.6184-.24042c-.1551-.03453-.488-.10604-.9206-.10604-.9034 0-2.138.66073-2.5716 1.73108-1.3256.8485-1.6921 1.8133-1.7929 2.0078-.1009.1944-.2618.5312-.3399 1.2148-.0781.6836 0 1.6055.5235 2.4688-.0721.0626-.2383.289-.3321.4375-.0937.1484-.5898.875-.3515 2.1445-.1993 0-.6387-.158-.92-.4393l-.70708-.7071c-.28131-.2814-.43934-.6629-.43934-1.0607v-4.4172L3.69869 6.31701Z"></path><path fill-rule="evenodd" d="M16.0604 11c.5523 0 1 .4477 1 1v.1013c.6366.1591 1.2184.4937 1.668.9715.3784.4022.3592 1.0351-.0431 1.4135-.4022.3785-1.0351.3592-1.4135-.043-.1902-.2021-.4506-.3504-.7488-.4139-.0363-.0077-.0722-.0174-.1074-.0292-.0543-.018-.1098-.0317-.1658-.041-.0614.0117-.1247.0179-.1894.0179-.063 0-.1245-.0058-.1843-.017-.0784.0136-.1554.0355-.2292.0658-.1976.0812-.3513.2132-.4504.3673.0006.002.0013.0042.002.0064.0138.0431.0516.1195.1396.2154.1806.1971.4983.3934.8907.4835.746.1712 1.4369.5572 1.9192 1.0838.476.5197.8461 1.3054.5891 2.1704-.0136.0459-.0305.0907-.0506.1342-.3123.6768-.8768 1.2008-1.5636 1.483-.0208.0085-.0416.0168-.0625.0248V20c0 .5523-.4477 1-1 1-.5271 0-.9589-.4077-.9973-.9249-.0154-.0046-.0308-.0093-.0462-.0141-.6707-.1541-1.2837-.502-1.7506-1.0062-.3752-.4053-.3509-1.038.0544-1.4132.4052-.3752 1.0379-.3508 1.4131.0544.1903.2055.4527.3566.754.4209.0359.0077.0713.0173.1061.0289.0754.025.1531.0416.2315.0499.0753-.0181.154-.0277.235-.0277.0421 0 .0836.0026.1244.0076.0608-.0134.1204-.032.1781-.0557.1979-.0813.3518-.2135.451-.368l-.001-.0032c-.0136-.0424-.0513-.1189-.1398-.2156-.1817-.1984-.5007-.3955-.8919-.4854-.7448-.171-1.4351-.5549-1.9176-1.0814-.4776-.5211-.8432-1.304-.5924-2.167.0138-.0477.0312-.0943.052-.1394.312-.6773.8766-1.2017 1.5637-1.4839.0573-.0236.1151-.0453.1735-.0653V12c0-.5523.4477-1 1-1Z" clip-rule="evenodd"></path></svg>`), FilterDollarSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function FilterDollarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilterDollarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root333();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1333();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilterDollarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2333();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilterDollarSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilterDollarSolid = hmr(FilterDollarSolid, () => FilterDollarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterDollarSolid[HMR].source;
    set(FilterDollarSolid[HMR].source, module.default[HMR].original);
  });
}
var FilterDollarSolid_default = FilterDollarSolid;

// node_modules/flowbite-svelte-icons/dist/FilterOutline.svelte
FilterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterOutline.svelte";
var root_1334 = add_locations(from_svg(`<title> </title>`), FilterOutline[FILENAME], [[43, 4]]);
var root_2334 = add_locations(from_svg(`<desc> </desc>`), FilterOutline[FILENAME], [[46, 4]]);
var root334 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M18.796 4H5.204a1 1 0 0 0-.753 1.659l5.302 6.058a1 1 0 0 1 .247.659v4.874a.5.5 0 0 0 .2.4l3 2.25a.5.5 0 0 0 .8-.4v-7.124a1 1 0 0 1 .247-.659l5.302-6.059c.566-.646.106-1.658-.753-1.658Z"></path></svg>`), FilterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FilterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root334();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1334();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2334();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilterOutline = hmr(FilterOutline, () => FilterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterOutline[HMR].source;
    set(FilterOutline[HMR].source, module.default[HMR].original);
  });
}
var FilterOutline_default = FilterOutline;

// node_modules/flowbite-svelte-icons/dist/FilterSolid.svelte
FilterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterSolid.svelte";
var root_1335 = add_locations(from_svg(`<title> </title>`), FilterSolid[FILENAME], [[41, 4]]);
var root_2335 = add_locations(from_svg(`<desc> </desc>`), FilterSolid[FILENAME], [[44, 4]]);
var root335 = add_locations(from_svg(`<svg><!><!><path d="M5.05 3C3.291 3 2.352 5.024 3.51 6.317l5.422 6.059v4.874c0 .472.227.917.613 1.2l3.069 2.25c1.01.742 2.454.036 2.454-1.2v-7.124l5.422-6.059C21.647 5.024 20.708 3 18.95 3H5.05Z"></path></svg>`), FilterSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FilterSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FilterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root335();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1335();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FilterSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2335();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FilterSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FilterSolid = hmr(FilterSolid, () => FilterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterSolid[HMR].source;
    set(FilterSolid[HMR].source, module.default[HMR].original);
  });
}
var FilterSolid_default = FilterSolid;

// node_modules/flowbite-svelte-icons/dist/FingerprintOutline.svelte
FingerprintOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FingerprintOutline.svelte";
var root_1336 = add_locations(from_svg(`<title> </title>`), FingerprintOutline[FILENAME], [[43, 4]]);
var root_2336 = add_locations(from_svg(`<desc> </desc>`), FingerprintOutline[FILENAME], [[46, 4]]);
var root336 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 12a28.076 28.076 0 0 1-1.091 9M7.231 4.37a8.994 8.994 0 0 1 12.88 3.73M2.958 15S3 14.577 3 12a8.949 8.949 0 0 1 1.735-5.307m12.84 3.088A5.98 5.98 0 0 1 18 12a30 30 0 0 1-.464 6.232M6 12a6 6 0 0 1 9.352-4.974M4 21a5.964 5.964 0 0 1 1.01-3.328 5.15 5.15 0 0 0 .786-1.926m8.66 2.486a13.96 13.96 0 0 1-.962 2.683M7.5 19.336C9 17.092 9 14.845 9 12a3 3 0 1 1 6 0c0 .749 0 1.521-.031 2.311M12 12c0 3 0 6-2 9"></path></svg>`), FingerprintOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FingerprintOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FingerprintOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root336();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1336();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FingerprintOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2336();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FingerprintOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FingerprintOutline = hmr(FingerprintOutline, () => FingerprintOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FingerprintOutline[HMR].source;
    set(FingerprintOutline[HMR].source, module.default[HMR].original);
  });
}
var FingerprintOutline_default = FingerprintOutline;

// node_modules/flowbite-svelte-icons/dist/FireOutline.svelte
FireOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FireOutline.svelte";
var root_1337 = add_locations(from_svg(`<title> </title>`), FireOutline[FILENAME], [[43, 4]]);
var root_2337 = add_locations(from_svg(`<desc> </desc>`), FireOutline[FILENAME], [[46, 4]]);
var root337 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.122 17.645a7.185 7.185 0 0 1-2.656 2.495 7.06 7.06 0 0 1-3.52.853 6.617 6.617 0 0 1-3.306-.718 6.73 6.73 0 0 1-2.54-2.266c-2.672-4.57.287-8.846.887-9.668A4.448 4.448 0 0 0 8.07 6.31 4.49 4.49 0 0 0 7.997 4c1.284.965 6.43 3.258 5.525 10.631 1.496-1.136 2.7-3.046 2.846-6.216 1.43 1.061 3.985 5.462 1.754 9.23Z"></path></svg>`), FireOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FireOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FireOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root337();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1337();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FireOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2337();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FireOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FireOutline = hmr(FireOutline, () => FireOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FireOutline[HMR].source;
    set(FireOutline[HMR].source, module.default[HMR].original);
  });
}
var FireOutline_default = FireOutline;

// node_modules/flowbite-svelte-icons/dist/FireSolid.svelte
FireSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FireSolid.svelte";
var root_1338 = add_locations(from_svg(`<title> </title>`), FireSolid[FILENAME], [[41, 4]]);
var root_2338 = add_locations(from_svg(`<desc> </desc>`), FireSolid[FILENAME], [[44, 4]]);
var root338 = add_locations(from_svg(`<svg><!><!><path d="M8.597 3.2A1 1 0 0 0 7.04 4.289a3.49 3.49 0 0 1 .057 1.795 3.448 3.448 0 0 1-.84 1.575.999.999 0 0 0-.077.094c-.596.817-3.96 5.6-.941 10.762l.03.049a7.73 7.73 0 0 0 2.917 2.602 7.617 7.617 0 0 0 3.772.829 8.06 8.06 0 0 0 3.986-.975 8.185 8.185 0 0 0 3.04-2.864c1.301-2.2 1.184-4.556.588-6.441-.583-1.848-1.68-3.414-2.607-4.102a1 1 0 0 0-1.594.757c-.067 1.431-.363 2.551-.794 3.431-.222-2.407-1.127-4.196-2.224-5.524-1.147-1.39-2.564-2.3-3.323-2.788a8.487 8.487 0 0 1-.432-.287Z"></path></svg>`), FireSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FireSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FireSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root338();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1338();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FireSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2338();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FireSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FireSolid = hmr(FireSolid, () => FireSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FireSolid[HMR].source;
    set(FireSolid[HMR].source, module.default[HMR].original);
  });
}
var FireSolid_default = FireSolid;

// node_modules/flowbite-svelte-icons/dist/FishAltOutline.svelte
FishAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FishAltOutline.svelte";
var root_1339 = add_locations(from_svg(`<title> </title>`), FishAltOutline[FILENAME], [[43, 4]]);
var root_2339 = add_locations(from_svg(`<desc> </desc>`), FishAltOutline[FILENAME], [[46, 4]]);
var root339 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 12c0 1.6 3.35786 4 7.5 4 4.1421 0 6.9231-3.2 7.5-4-.5769-.8-3.3579-4-7.5-4C9.35786 8 6 10.4 6 12Zm0 0L3 9m3 3-3 3m12.9866-3.3723h.01m-1.9995-3.61229c-1.7265 3.30199-1.7113 5.02539-.0015 7.96929m-4.6104-.7956L7.7 17.4c-.49443.6592-.02401 1.6.80004 1.6H10c1 0 2.7576-3.0256 2.7576-3.0256M9 5l3.056 3.09696"></path></svg>`), FishAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FishAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FishAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root339();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1339();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FishAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2339();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FishAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FishAltOutline = hmr(FishAltOutline, () => FishAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FishAltOutline[HMR].source;
    set(FishAltOutline[HMR].source, module.default[HMR].original);
  });
}
var FishAltOutline_default = FishAltOutline;

// node_modules/flowbite-svelte-icons/dist/FishAltSolid.svelte
FishAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FishAltSolid.svelte";
var root_1340 = add_locations(from_svg(`<title> </title>`), FishAltSolid[FILENAME], [[41, 4]]);
var root_2340 = add_locations(from_svg(`<desc> </desc>`), FishAltSolid[FILENAME], [[44, 4]]);
var root340 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9.70707 4.29289c-.39052-.39052-1.02369-.39052-1.41421.00001-.39052.39052-.39052 1.02369 0 1.41421l1.79464 1.79461c-.89352.26818-1.7041.62743-2.39859 1.03679-.75153.44298-1.39556.9614-1.86395 1.51679-.05394.0639-.10674.1298-.1579.1975L3.70711 8.29288c-.39053-.39052-1.02369-.39052-1.41422 0-.39052.39053-.39052 1.02369 0 1.41422L4.58579 12l-2.2929 2.2929c-.39052.3905-.39052 1.0237 0 1.4142.39053.3905 1.02369.3905 1.41422 0l1.95995-1.96c.05116.0677.10396.1336.1579.1976.46839.5554 1.11242 1.0738 1.86395 1.5168.05288.0311.10644.062.16065.0926l-.94493 1.2397-.00466.0062C5.91107 18.1185 6.85198 20 8.5 20h1.49997c.57803 0 1.04673-.2818 1.35903-.5316.3262-.261.6028-.5842.816-.8684.2175-.29.395-.5746.5169-.7836.0616-.1056.1104-.1944.1446-.2582.0172-.032.0307-.0579.0404-.0767l.0117-.0228.0037-.0072.0021-.0043c.0736-.1472.1447-.287.1954-.4475.1381.0059.1873-.001.327 0-.1119-.1811-.2137-.3588-.2975-.5251-.8831-1.5257-1.4054-2.8736-1.4079-4.3386-.0025-1.4614.5132-2.89857 1.4025-4.59935.0088-.01699.0182-.03371.028-.05015.0924-.15428.1875-.31964.2809-.48626-.3483.0023-.6193.013-.9563.04469-.0768-.07681-.1814-.17406-.2594-.25204l-2.50003-2.5ZM11.007 16.7345c-.4422-.095-.8687-.2129-1.27603-.3495L8.5 18h1.46745c.01805-.0079.06485-.0315.14225-.0934.1425-.114.3035-.2908.4653-.5066.1575-.21.2925-.4254.3893-.5914.0154-.0263.0296-.0511.0427-.0741Zm8.1536-1.6154c-.94.6583-2.1207 1.2825-3.5044 1.6203-.2955-.4048-.5956-.8506-.7597-1.1826-.0099-.02-.0205-.0397-.0317-.059-.8171-1.4068-1.1517-2.4006-1.1534-3.3652-.0016-.9721.3341-2.0568 1.1618-3.64445.2416-.40531.4939-.8667.696-1.24835 1.4212.33251 2.6317.96898 3.5914 1.64108 1.3918.97475 2.3082 2.05962 2.6505 2.53422.2519.3492.2519.8205 0 1.1698-.3423.4746-1.2587 1.5594-2.6505 2.5342Zm-4.1739-3.4914c0-.5523.4477-1 1-1h.01c.5523 0 1 .4477 1 1s-.4477 1-1 1h-.01c-.5523 0-1-.4477-1-1Z" clip-rule="evenodd"></path></svg>`), FishAltSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FishAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FishAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root340();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1340();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FishAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2340();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FishAltSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FishAltSolid = hmr(FishAltSolid, () => FishAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FishAltSolid[HMR].source;
    set(FishAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FishAltSolid_default = FishAltSolid;

// node_modules/flowbite-svelte-icons/dist/FishOutline.svelte
FishOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FishOutline.svelte";
var root_1341 = add_locations(from_svg(`<title> </title>`), FishOutline[FILENAME], [[43, 4]]);
var root_2341 = add_locations(from_svg(`<desc> </desc>`), FishOutline[FILENAME], [[46, 4]]);
var root341 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 12c0 1.6 3.35786 4 7.5 4 4.1421 0 6.9231-3.2 7.5-4-.5769-.8-3.3579-4-7.5-4C9.35786 8 6 10.4 6 12Zm0 0L3 9m3 3-3 3m12.9866-3.3723h.01M14 8c-1.7264 3.302-1.7098 5.0561 0 8"></path></svg>`), FishOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FishOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FishOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root341();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1341();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FishOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2341();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FishOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FishOutline = hmr(FishOutline, () => FishOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FishOutline[HMR].source;
    set(FishOutline[HMR].source, module.default[HMR].original);
  });
}
var FishOutline_default = FishOutline;

// node_modules/flowbite-svelte-icons/dist/FishSolid.svelte
FishSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FishSolid.svelte";
var root_1342 = add_locations(from_svg(`<title> </title>`), FishSolid[FILENAME], [[41, 4]]);
var root_2342 = add_locations(from_svg(`<desc> </desc>`), FishSolid[FILENAME], [[44, 4]]);
var root342 = add_locations(from_svg(`<svg><!><!><path d="M13.4228 7.00024c-2.2266.01465-4.24648.66154-5.73389 1.53827-.75153.44298-1.39556.9614-1.86395 1.51679-.05394.0639-.10674.1298-.1579.1975L3.70711 8.29288c-.39053-.39052-1.02369-.39052-1.41422 0-.39052.39053-.39052 1.02369 0 1.41422L4.58579 12l-2.2929 2.2929c-.39052.3905-.39052 1.0237 0 1.4142.39053.3905 1.02369.3905 1.41422 0l1.95995-1.96c.05116.0677.10396.1336.1579.1976.46839.5554 1.11242 1.0738 1.86395 1.5168 1.48608.8759 3.50369 1.5224 5.72789 1.5382-.1119-.1811-.2137-.3588-.2975-.5251-.8831-1.5257-1.4054-2.8736-1.4079-4.3386-.0025-1.4614.5132-2.89857 1.4025-4.59935.0088-.01699.0182-.03371.028-.05015.0924-.15428.1875-.31964.2809-.48626Z"></path><path fill-rule="evenodd" d="M15.6562 16.7394c1.3837-.3378 2.5644-.962 3.5044-1.6203 1.3918-.9748 2.3082-2.0596 2.6505-2.5342.2519-.3493.2519-.8206 0-1.1698-.3423-.4746-1.2587-1.55947-2.6505-2.53422-.9597-.6721-2.1702-1.30857-3.5914-1.64108-.2021.38166-.4544.84304-.696 1.24836-.8277 1.58764-1.1634 2.67234-1.1618 3.64444.0017.9646.3363 1.9584 1.1534 3.3652.0112.0193.0218.039.0317.059.1641.332.4642.7778.7597 1.1826Zm.3305-6.1117c-.5523 0-1 .4477-1 1s.4477 1 1 1h.01c.5523 0 1-.4477 1-1s-.4477-1-1-1h-.01Z" clip-rule="evenodd"></path></svg>`), FishSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function FishSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FishSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root342();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1342();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FishSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2342();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FishSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FishSolid = hmr(FishSolid, () => FishSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FishSolid[HMR].source;
    set(FishSolid[HMR].source, module.default[HMR].original);
  });
}
var FishSolid_default = FishSolid;

// node_modules/flowbite-svelte-icons/dist/FixTablesOutline.svelte
FixTablesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FixTablesOutline.svelte";
var root_1343 = add_locations(from_svg(`<title> </title>`), FixTablesOutline[FILENAME], [[43, 4]]);
var root_2343 = add_locations(from_svg(`<desc> </desc>`), FixTablesOutline[FILENAME], [[46, 4]]);
var root343 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h4v-4m-5 0v-4m0 4h5m-5-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v1.98935M3 11h5v4m9.4708 4.1718-.8696-1.4388-2.8164-.235-2.573-4.2573 1.4873-2.8362 1.4441 2.3893c.3865.6396 1.2183.8447 1.8579.4582.6396-.3866.8447-1.2184.4582-1.858l-1.444-2.38925h3.1353l2.6101 4.27715-1.0713 2.5847.8695 1.4388"></path></svg>`), FixTablesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FixTablesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FixTablesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root343();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1343();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FixTablesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2343();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FixTablesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FixTablesOutline = hmr(FixTablesOutline, () => FixTablesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FixTablesOutline[HMR].source;
    set(FixTablesOutline[HMR].source, module.default[HMR].original);
  });
}
var FixTablesOutline_default = FixTablesOutline;

// node_modules/flowbite-svelte-icons/dist/FlagOutline.svelte
FlagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlagOutline.svelte";
var root_1344 = add_locations(from_svg(`<title> </title>`), FlagOutline[FILENAME], [[43, 4]]);
var root_2344 = add_locations(from_svg(`<desc> </desc>`), FlagOutline[FILENAME], [[46, 4]]);
var root344 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 14v7M5 4.971v9.541c5.6-5.538 8.4 2.64 14-.086v-9.54C13.4 7.61 10.6-.568 5 4.97Z"></path></svg>`), FlagOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FlagOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FlagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root344();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1344();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FlagOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2344();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FlagOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FlagOutline = hmr(FlagOutline, () => FlagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlagOutline[HMR].source;
    set(FlagOutline[HMR].source, module.default[HMR].original);
  });
}
var FlagOutline_default = FlagOutline;

// node_modules/flowbite-svelte-icons/dist/FlagSolid.svelte
FlagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlagSolid.svelte";
var root_1345 = add_locations(from_svg(`<title> </title>`), FlagSolid[FILENAME], [[41, 4]]);
var root_2345 = add_locations(from_svg(`<desc> </desc>`), FlagSolid[FILENAME], [[44, 4]]);
var root345 = add_locations(from_svg(`<svg><!><!><path d="M13.09 3.294c1.924.95 3.422 1.69 5.472.692a1 1 0 0 1 1.438.9v9.54a1 1 0 0 1-.562.9c-2.981 1.45-5.382.24-7.25-.701a38.739 38.739 0 0 0-.622-.31c-1.033-.497-1.887-.812-2.756-.77-.76.036-1.672.357-2.81 1.396V21a1 1 0 1 1-2 0V4.971a1 1 0 0 1 .297-.71c1.522-1.506 2.967-2.185 4.417-2.255 1.407-.068 2.653.453 3.72.967.225.108.443.216.655.32Z"></path></svg>`), FlagSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FlagSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FlagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root345();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1345();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FlagSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2345();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FlagSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FlagSolid = hmr(FlagSolid, () => FlagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlagSolid[HMR].source;
    set(FlagSolid[HMR].source, module.default[HMR].original);
  });
}
var FlagSolid_default = FlagSolid;

// node_modules/flowbite-svelte-icons/dist/FlaskOutline.svelte
FlaskOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlaskOutline.svelte";
var root_1346 = add_locations(from_svg(`<title> </title>`), FlaskOutline[FILENAME], [[43, 4]]);
var root_2346 = add_locations(from_svg(`<desc> </desc>`), FlaskOutline[FILENAME], [[46, 4]]);
var root346 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.05 3.00002v5C7.33127 8.93351 5.05005 11.2392 5.05005 14.2c0 3.7555 3.13401 6.8 6.99995 6.8 3.866 0 7-3.0445 7-6.8 0-2.9608-2.2812-5.26649-5-6.19998v-5m-4 0h4m-4 0H8.05005m5.99995 0h2M5.09798 15H19.0021"></path></svg>`), FlaskOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FlaskOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FlaskOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root346();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1346();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FlaskOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2346();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FlaskOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FlaskOutline = hmr(FlaskOutline, () => FlaskOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlaskOutline[HMR].source;
    set(FlaskOutline[HMR].source, module.default[HMR].original);
  });
}
var FlaskOutline_default = FlaskOutline;

// node_modules/flowbite-svelte-icons/dist/FlaskSolid.svelte
FlaskSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlaskSolid.svelte";
var root_1347 = add_locations(from_svg(`<title> </title>`), FlaskSolid[FILENAME], [[41, 4]]);
var root_2347 = add_locations(from_svg(`<desc> </desc>`), FlaskSolid[FILENAME], [[44, 4]]);
var root347 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.05005 2c-.55229 0-1 .44772-1 1s.44771 1 1 1h1v3.31532c-2.69858 1.16334-5 3.63038-5 6.88468 0 4.3349 3.60924 7.8 7.99995 7.8 4.3908 0 8-3.4651 8-7.8 0-3.2543-2.3014-5.72134-5-6.88468V4h1c.5523 0 1-.44772 1-1s-.4477-1-1-1H8.05005ZM11.05 8V4h2v4c0 .42712.2713.8071.6753.9458 2.3906.82083 4.2201 2.7442 4.3204 5.0542H6.05438c.10031-2.31 1.92977-4.23337 4.32042-5.0542.404-.1387.6752-.51868.6752-.9458Z" clip-rule="evenodd"></path></svg>`), FlaskSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FlaskSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FlaskSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root347();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1347();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FlaskSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2347();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FlaskSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FlaskSolid = hmr(FlaskSolid, () => FlaskSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlaskSolid[HMR].source;
    set(FlaskSolid[HMR].source, module.default[HMR].original);
  });
}
var FlaskSolid_default = FlaskSolid;

// node_modules/flowbite-svelte-icons/dist/FloppyDiskAltOutline.svelte
FloppyDiskAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskAltOutline.svelte";
var root_1348 = add_locations(from_svg(`<title> </title>`), FloppyDiskAltOutline[FILENAME], [[43, 4]]);
var root_2348 = add_locations(from_svg(`<desc> </desc>`), FloppyDiskAltOutline[FILENAME], [[46, 4]]);
var root348 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M11 16h2m6.707-9.293-2.414-2.414A1 1 0 0 0 16.586 4H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V7.414a1 1 0 0 0-.293-.707ZM16 20v-6a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v6h8ZM9 4h6v3a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V4Z"></path></svg>`), FloppyDiskAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FloppyDiskAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FloppyDiskAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root348();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1348();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FloppyDiskAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2348();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FloppyDiskAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FloppyDiskAltOutline = hmr(FloppyDiskAltOutline, () => FloppyDiskAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskAltOutline[HMR].source;
    set(FloppyDiskAltOutline[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskAltOutline_default = FloppyDiskAltOutline;

// node_modules/flowbite-svelte-icons/dist/FloppyDiskAltSolid.svelte
FloppyDiskAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskAltSolid.svelte";
var root_1349 = add_locations(from_svg(`<title> </title>`), FloppyDiskAltSolid[FILENAME], [[41, 4]]);
var root_2349 = add_locations(from_svg(`<desc> </desc>`), FloppyDiskAltSolid[FILENAME], [[44, 4]]);
var root349 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7.414A2 2 0 0 0 20.414 6L18 3.586A2 2 0 0 0 16.586 3H5Zm3 11a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v6H8v-6Zm1-7V5h6v2a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 17h-4v-2h4v2Z" clip-rule="evenodd"></path></svg>`), FloppyDiskAltSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function FloppyDiskAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FloppyDiskAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root349();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1349();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FloppyDiskAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2349();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FloppyDiskAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FloppyDiskAltSolid = hmr(FloppyDiskAltSolid, () => FloppyDiskAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskAltSolid[HMR].source;
    set(FloppyDiskAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskAltSolid_default = FloppyDiskAltSolid;

// node_modules/flowbite-svelte-icons/dist/FloppyDiskOutline.svelte
FloppyDiskOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskOutline.svelte";
var root_1350 = add_locations(from_svg(`<title> </title>`), FloppyDiskOutline[FILENAME], [[43, 4]]);
var root_2350 = add_locations(from_svg(`<desc> </desc>`), FloppyDiskOutline[FILENAME], [[46, 4]]);
var root350 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 5a1 1 0 0 1 1-1h11.586a1 1 0 0 1 .707.293l2.414 2.414a1 1 0 0 1 .293.707V19a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M8 4h8v4H8V4Zm7 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), FloppyDiskOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function FloppyDiskOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FloppyDiskOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root350();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1350();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FloppyDiskOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2350();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FloppyDiskOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FloppyDiskOutline = hmr(FloppyDiskOutline, () => FloppyDiskOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskOutline[HMR].source;
    set(FloppyDiskOutline[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskOutline_default = FloppyDiskOutline;

// node_modules/flowbite-svelte-icons/dist/FloppyDiskSolid.svelte
FloppyDiskSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskSolid.svelte";
var root_1351 = add_locations(from_svg(`<title> </title>`), FloppyDiskSolid[FILENAME], [[41, 4]]);
var root_2351 = add_locations(from_svg(`<desc> </desc>`), FloppyDiskSolid[FILENAME], [[44, 4]]);
var root351 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7.414A2 2 0 0 0 20.414 6L18 3.586A2 2 0 0 0 16.586 3H5Zm10 11a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM8 7V5h8v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), FloppyDiskSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FloppyDiskSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FloppyDiskSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root351();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1351();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FloppyDiskSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2351();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FloppyDiskSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FloppyDiskSolid = hmr(FloppyDiskSolid, () => FloppyDiskSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskSolid[HMR].source;
    set(FloppyDiskSolid[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskSolid_default = FloppyDiskSolid;

// node_modules/flowbite-svelte-icons/dist/FlowbiteSolid.svelte
FlowbiteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlowbiteSolid.svelte";
var root_1352 = add_locations(from_svg(`<title> </title>`), FlowbiteSolid[FILENAME], [[41, 4]]);
var root_2352 = add_locations(from_svg(`<desc> </desc>`), FlowbiteSolid[FILENAME], [[44, 4]]);
var root352 = add_locations(from_svg(`<svg><!><!><path d="M15.907 11.998 10.332 9.23a.9.9 0 0 1-.16-.037l-.018-.007v6.554c0 .017.008.034.01.051l2.388-2.974 3.355-.82Z"></path><path d="m11.463 4.054 5.579 3.323A4.02 4.02 0 0 1 18.525 9c.332.668.47 1.414.398 2.155a3.07 3.07 0 0 1-.745 1.65 3.108 3.108 0 0 1-1.55.951c-.022.007-.045.005-.07.01-.062.03-.126.057-.191.08l-2.72.667-1.992 2.48c-.18.227-.41.409-.67.534.047.034.085.077.137.107a2.05 2.05 0 0 0 1.995.035c.592-.33 2.15-1.201 4.636-2.892l.28-.19c1.328-.895 3.616-2.442 3.967-4.215a9.94 9.94 0 0 0-1.713-4.154 10.027 10.027 0 0 0-3.375-2.989 10.107 10.107 0 0 0-8.802-.418c1.162.287 2.287.704 3.354 1.243Z"></path><path d="M5.382 17.082v-6.457a3.7 3.7 0 0 1 .45-1.761 3.733 3.733 0 0 1 1.238-1.34 3.915 3.915 0 0 1 3.433-.245c.176.03.347.084.508.161l5.753 2.856c.082.05.161.105.236.165a2.128 2.128 0 0 0-.953-1.455l-5.51-3.284c-1.74-.857-3.906-1.523-5.244-1.097a9.96 9.96 0 0 0-2.5 3.496 9.895 9.895 0 0 0 .283 8.368 9.973 9.973 0 0 0 2.73 3.322 17.161 17.161 0 0 1-.424-2.729Z"></path><path d="m19.102 16.163-.272.183c-2.557 1.74-4.169 2.64-4.698 2.935a4.083 4.083 0 0 1-2 .53 3.946 3.946 0 0 1-1.983-.535 3.788 3.788 0 0 1-1.36-1.361 3.752 3.752 0 0 1-.51-1.85 1.812 1.812 0 0 1-.043-.26V9.143c0-.024.009-.046.01-.07-.056.02-.11.043-.162.07a1.796 1.796 0 0 0-.787 1.516v6.377a10.67 10.67 0 0 0 1.113 4.27 10.11 10.11 0 0 0 8.505-.53 10.022 10.022 0 0 0 3.282-2.858 9.936 9.936 0 0 0 1.75-3.97 19.615 19.615 0 0 1-2.845 2.216Z"></path></svg>`), FlowbiteSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [52, 2], [55, 2]]]]);
function FlowbiteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FlowbiteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root352();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1352();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FlowbiteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2352();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FlowbiteSolid,
      43,
      2
    );
  }
  next(4);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FlowbiteSolid = hmr(FlowbiteSolid, () => FlowbiteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlowbiteSolid[HMR].source;
    set(FlowbiteSolid[HMR].source, module.default[HMR].original);
  });
}
var FlowbiteSolid_default = FlowbiteSolid;

// node_modules/flowbite-svelte-icons/dist/FolderArrowRightOutline.svelte
FolderArrowRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderArrowRightOutline.svelte";
var root_1353 = add_locations(from_svg(`<title> </title>`), FolderArrowRightOutline[FILENAME], [[43, 4]]);
var root_2353 = add_locations(from_svg(`<desc> </desc>`), FolderArrowRightOutline[FILENAME], [[46, 4]]);
var root353 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 8H4m4 6h8m0 0-2-2m2 2-2 2M4 6v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderArrowRightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FolderArrowRightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderArrowRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root353();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1353();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderArrowRightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2353();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderArrowRightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderArrowRightOutline = hmr(FolderArrowRightOutline, () => FolderArrowRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderArrowRightOutline[HMR].source;
    set(FolderArrowRightOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderArrowRightOutline_default = FolderArrowRightOutline;

// node_modules/flowbite-svelte-icons/dist/FolderArrowRightSolid.svelte
FolderArrowRightSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderArrowRightSolid.svelte";
var root_1354 = add_locations(from_svg(`<title> </title>`), FolderArrowRightSolid[FILENAME], [[41, 4]]);
var root_2354 = add_locations(from_svg(`<desc> </desc>`), FolderArrowRightSolid[FILENAME], [[44, 4]]);
var root354 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 0-2 2v1h10.968l-1.9-2.28A2 2 0 0 0 10.532 4H5ZM3 19V9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm11.707-7.707a1 1 0 0 0-1.414 1.414l.293.293H8a1 1 0 1 0 0 2h5.586l-.293.293a1 1 0 0 0 1.414 1.414l2-2a1 1 0 0 0 0-1.414l-2-2Z" clip-rule="evenodd"></path></svg>`), FolderArrowRightSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderArrowRightSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderArrowRightSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root354();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1354();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderArrowRightSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2354();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderArrowRightSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderArrowRightSolid = hmr(FolderArrowRightSolid, () => FolderArrowRightSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderArrowRightSolid[HMR].source;
    set(FolderArrowRightSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderArrowRightSolid_default = FolderArrowRightSolid;

// node_modules/flowbite-svelte-icons/dist/FolderDuplicateOutline.svelte
FolderDuplicateOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderDuplicateOutline.svelte";
var root_1355 = add_locations(from_svg(`<title> </title>`), FolderDuplicateOutline[FILENAME], [[43, 4]]);
var root_2355 = add_locations(from_svg(`<desc> </desc>`), FolderDuplicateOutline[FILENAME], [[46, 4]]);
var root355 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 11H4m15.5 5a.5.5 0 0 0 .5-.5V8a1 1 0 0 0-1-1h-3.75a1 1 0 0 1-.829-.44l-1.436-2.12a1 1 0 0 0-.828-.44H8a1 1 0 0 0-1 1M4 9v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-3.75a1 1 0 0 1-.829-.44L9.985 8.44A1 1 0 0 0 9.157 8H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderDuplicateOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FolderDuplicateOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderDuplicateOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root355();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1355();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderDuplicateOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2355();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderDuplicateOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderDuplicateOutline = hmr(FolderDuplicateOutline, () => FolderDuplicateOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderDuplicateOutline[HMR].source;
    set(FolderDuplicateOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderDuplicateOutline_default = FolderDuplicateOutline;

// node_modules/flowbite-svelte-icons/dist/FolderDuplicateSolid.svelte
FolderDuplicateSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderDuplicateSolid.svelte";
var root_1356 = add_locations(from_svg(`<title> </title>`), FolderDuplicateSolid[FILENAME], [[41, 4]]);
var root_2356 = add_locations(from_svg(`<desc> </desc>`), FolderDuplicateSolid[FILENAME], [[44, 4]]);
var root356 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 5a2 2 0 0 1 2-2h4.157a2 2 0 0 1 1.656.879L15.249 6H19a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2v-5a3 3 0 0 0-3-3h-3.22l-1.14-1.682A3 3 0 0 0 9.157 6H6V5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M3 9a2 2 0 0 1 2-2h4.157a2 2 0 0 1 1.656.879L12.249 10H3V9Zm0 3v7a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-7H3Z" clip-rule="evenodd"></path></svg>`), FolderDuplicateSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function FolderDuplicateSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderDuplicateSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root356();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1356();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderDuplicateSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2356();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderDuplicateSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderDuplicateSolid = hmr(FolderDuplicateSolid, () => FolderDuplicateSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderDuplicateSolid[HMR].source;
    set(FolderDuplicateSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderDuplicateSolid_default = FolderDuplicateSolid;

// node_modules/flowbite-svelte-icons/dist/FolderOpenOutline.svelte
FolderOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOpenOutline.svelte";
var root_1357 = add_locations(from_svg(`<title> </title>`), FolderOpenOutline[FILENAME], [[43, 4]]);
var root_2357 = add_locations(from_svg(`<desc> </desc>`), FolderOpenOutline[FILENAME], [[46, 4]]);
var root357 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 19V6a1 1 0 0 1 1-1h4.032a1 1 0 0 1 .768.36l1.9 2.28a1 1 0 0 0 .768.36H16a1 1 0 0 1 1 1v1M3 19l3-8h15l-3 8H3Z"></path></svg>`), FolderOpenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FolderOpenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root357();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1357();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderOpenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2357();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderOpenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderOpenOutline = hmr(FolderOpenOutline, () => FolderOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOpenOutline[HMR].source;
    set(FolderOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderOpenOutline_default = FolderOpenOutline;

// node_modules/flowbite-svelte-icons/dist/FolderOpenSolid.svelte
FolderOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOpenSolid.svelte";
var root_1358 = add_locations(from_svg(`<title> </title>`), FolderOpenSolid[FILENAME], [[41, 4]]);
var root_2358 = add_locations(from_svg(`<desc> </desc>`), FolderOpenSolid[FILENAME], [[44, 4]]);
var root358 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 .087.586l2.977-7.937A1 1 0 0 1 6 10h12V9a2 2 0 0 0-2-2h-4.532l-1.9-2.28A2 2 0 0 0 8.032 4H4Zm2.693 8H6.5l-3 8H18l3-8H6.693Z" clip-rule="evenodd"></path></svg>`), FolderOpenSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderOpenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root358();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1358();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderOpenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2358();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderOpenSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderOpenSolid = hmr(FolderOpenSolid, () => FolderOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOpenSolid[HMR].source;
    set(FolderOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderOpenSolid_default = FolderOpenSolid;

// node_modules/flowbite-svelte-icons/dist/FolderOutline.svelte
FolderOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOutline.svelte";
var root_1359 = add_locations(from_svg(`<title> </title>`), FolderOutline[FILENAME], [[43, 4]]);
var root_2359 = add_locations(from_svg(`<desc> </desc>`), FolderOutline[FILENAME], [[46, 4]]);
var root359 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 8H4m0-2v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FolderOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root359();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1359();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2359();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderOutline = hmr(FolderOutline, () => FolderOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOutline[HMR].source;
    set(FolderOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderOutline_default = FolderOutline;

// node_modules/flowbite-svelte-icons/dist/FolderPlusOutline.svelte
FolderPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderPlusOutline.svelte";
var root_1360 = add_locations(from_svg(`<title> </title>`), FolderPlusOutline[FILENAME], [[43, 4]]);
var root_2360 = add_locations(from_svg(`<desc> </desc>`), FolderPlusOutline[FILENAME], [[46, 4]]);
var root360 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 8H4m8 3.5v5M9.5 14h5M4 6v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderPlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FolderPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root360();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1360();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderPlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2360();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderPlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderPlusOutline = hmr(FolderPlusOutline, () => FolderPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderPlusOutline[HMR].source;
    set(FolderPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderPlusOutline_default = FolderPlusOutline;

// node_modules/flowbite-svelte-icons/dist/FolderPlusSolid.svelte
FolderPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderPlusSolid.svelte";
var root_1361 = add_locations(from_svg(`<title> </title>`), FolderPlusSolid[FILENAME], [[41, 4]]);
var root_2361 = add_locations(from_svg(`<desc> </desc>`), FolderPlusSolid[FILENAME], [[44, 4]]);
var root361 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 0-2 2v1h10.968l-1.9-2.28A2 2 0 0 0 10.532 4H5ZM3 19V9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm9-8.5a1 1 0 0 1 1 1V13h1.5a1 1 0 1 1 0 2H13v1.5a1 1 0 1 1-2 0V15H9.5a1 1 0 1 1 0-2H11v-1.5a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), FolderPlusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root361();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1361();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2361();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderPlusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderPlusSolid = hmr(FolderPlusSolid, () => FolderPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderPlusSolid[HMR].source;
    set(FolderPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderPlusSolid_default = FolderPlusSolid;

// node_modules/flowbite-svelte-icons/dist/FolderSolid.svelte
FolderSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderSolid.svelte";
var root_1362 = add_locations(from_svg(`<title> </title>`), FolderSolid[FILENAME], [[41, 4]]);
var root_2362 = add_locations(from_svg(`<desc> </desc>`), FolderSolid[FILENAME], [[44, 4]]);
var root362 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 6a2 2 0 0 1 2-2h5.532a2 2 0 0 1 1.536.72l1.9 2.28H3V6Zm0 3v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9H3Z" clip-rule="evenodd"></path></svg>`), FolderSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FolderSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root362();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1362();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FolderSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2362();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FolderSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FolderSolid = hmr(FolderSolid, () => FolderSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderSolid[HMR].source;
    set(FolderSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderSolid_default = FolderSolid;

// node_modules/flowbite-svelte-icons/dist/FontColorAltSolid.svelte
FontColorAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontColorAltSolid.svelte";
var root_1363 = add_locations(from_svg(`<title> </title>`), FontColorAltSolid[FILENAME], [[41, 4]]);
var root_2363 = add_locations(from_svg(`<desc> </desc>`), FontColorAltSolid[FILENAME], [[44, 4]]);
var root363 = add_locations(from_svg(`<svg><!><!><path d="M19.9999 18.0661c0 1.6203-1.3431 2.9339-3 2.9339-1.6568 0-3-1.3136-3-2.9339 0-1.6204 3-6.0661 3-6.0661s3 4.4457 3 6.0661Z"></path><path fill-rule="evenodd" d="M10.4817 7.52489 9.12238 10.9817H11.841l-1.3593-3.45681Zm3.7494 4.06961-2.7166-6.90843c-.3694-.93918-1.69627-.93917-2.06558 0L6.76269 11.5173c-.03333.0634-.06004.1309-.07922.2014l-1.28309 3.263h-.41869c-.55229 0-1 .4477-1 1s.44771 1 1 1h2.75c.55228 0 1-.4477 1-1s-.44772-1-1-1h-.18223l.78646-2h4.29158l.3676.9349c.2021.514.7826.7668 1.2966.5647.514-.2021.7668-.7826.5647-1.2966l-.6085-1.5473c-.0053-.0144-.0109-.0287-.0168-.0429Z" clip-rule="evenodd"></path></svg>`), FontColorAltSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function FontColorAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FontColorAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root363();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1363();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FontColorAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2363();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FontColorAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FontColorAltSolid = hmr(FontColorAltSolid, () => FontColorAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontColorAltSolid[HMR].source;
    set(FontColorAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FontColorAltSolid_default = FontColorAltSolid;

// node_modules/flowbite-svelte-icons/dist/FontColorOutline.svelte
FontColorOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontColorOutline.svelte";
var root_1364 = add_locations(from_svg(`<title> </title>`), FontColorOutline[FILENAME], [[43, 4]]);
var root_2364 = add_locations(from_svg(`<desc> </desc>`), FontColorOutline[FILENAME], [[46, 4]]);
var root364 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m6.08169 15.9817 1.57292-4m-1.57292 4h-1.1m1.1 0h1.65m-.07708-4 2.72499-6.92967c.0368-.09379.1673-.09379.2042 0l2.725 6.92967m-5.65419 0h-.00607m.00607 0h5.65419m0 0 .6169 1.569m5.1104 4.453c0 1.1025-.8543 1.9963-1.908 1.9963s-1.908-.8938-1.908-1.9963c0-1.1026 1.908-4.1275 1.908-4.1275s1.908 3.0249 1.908 4.1275Z"></path></svg>`), FontColorOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FontColorOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FontColorOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root364();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1364();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FontColorOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2364();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FontColorOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FontColorOutline = hmr(FontColorOutline, () => FontColorOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontColorOutline[HMR].source;
    set(FontColorOutline[HMR].source, module.default[HMR].original);
  });
}
var FontColorOutline_default = FontColorOutline;

// node_modules/flowbite-svelte-icons/dist/FontFamilyOutline.svelte
FontFamilyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontFamilyOutline.svelte";
var root_1365 = add_locations(from_svg(`<title> </title>`), FontFamilyOutline[FILENAME], [[43, 4]]);
var root_2365 = add_locations(from_svg(`<desc> </desc>`), FontFamilyOutline[FILENAME], [[46, 4]]);
var root365 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.5785 19 4.2979-10.92966c.0369-.09379.1674-.09379.2042 0L19.3785 19m-8.8 0H9.47851m1.09999 0h1.65m7.15 0h-1.65m1.65 0h1.1m-7.7-3.9846h4.4M3 16l1.56685-3.9846m0 0 2.73102-6.94506c.03688-.09379.16738-.09379.20426 0l2.50367 6.94506H4.56685Z"></path></svg>`), FontFamilyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FontFamilyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FontFamilyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root365();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1365();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FontFamilyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2365();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FontFamilyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FontFamilyOutline = hmr(FontFamilyOutline, () => FontFamilyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontFamilyOutline[HMR].source;
    set(FontFamilyOutline[HMR].source, module.default[HMR].original);
  });
}
var FontFamilyOutline_default = FontFamilyOutline;

// node_modules/flowbite-svelte-icons/dist/FontHighlightOutline.svelte
FontHighlightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontHighlightOutline.svelte";
var root_1366 = add_locations(from_svg(`<title> </title>`), FontHighlightOutline[FILENAME], [[43, 4]]);
var root_2366 = add_locations(from_svg(`<desc> </desc>`), FontHighlightOutline[FILENAME], [[46, 4]]);
var root366 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M9 20H5.5c-.27614 0-.5-.2239-.5-.5v-3c0-.2761.22386-.5.5-.5h13c.2761 0 .5.2239.5.5v3c0 .2761-.2239.5-.5.5H18m-6-1 1.42 1.8933c.04.0534.12.0534.16 0L15 19m-7-6 3.9072-9.76789c.0335-.08381.1521-.08381.1856 0L16 13m-8 0H7m1 0h1.5m6.5 0h-1.5m1.5 0h1m-7-3.00001h4"></path></svg>`), FontHighlightOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function FontHighlightOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, FontHighlightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root366();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1366();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      FontHighlightOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2366();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      FontHighlightOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  FontHighlightOutline = hmr(FontHighlightOutline, () => FontHighlightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontHighlightOutline[HMR].source;
    set(FontHighlightOutline[HMR].source, module.default[HMR].original);
  });
}
var FontHighlightOutline_default = FontHighlightOutline;

// node_modules/flowbite-svelte-icons/dist/ForwardOutline.svelte
ForwardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardOutline.svelte";
var root_1367 = add_locations(from_svg(`<title> </title>`), ForwardOutline[FILENAME], [[43, 4]]);
var root_2367 = add_locations(from_svg(`<desc> </desc>`), ForwardOutline[FILENAME], [[46, 4]]);
var root367 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4.248 19C3.22 15.77 5.275 8.232 12.466 8.232V6.079a1.025 1.025 0 0 1 1.644-.862l5.479 4.307a1.108 1.108 0 0 1 0 1.723l-5.48 4.307a1.026 1.026 0 0 1-1.643-.861v-2.154C5.275 13.616 4.248 19 4.248 19Z"></path></svg>`), ForwardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ForwardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ForwardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root367();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1367();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ForwardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2367();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ForwardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ForwardOutline = hmr(ForwardOutline, () => ForwardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardOutline[HMR].source;
    set(ForwardOutline[HMR].source, module.default[HMR].original);
  });
}
var ForwardOutline_default = ForwardOutline;

// node_modules/flowbite-svelte-icons/dist/ForwardSolid.svelte
ForwardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardSolid.svelte";
var root_1368 = add_locations(from_svg(`<title> </title>`), ForwardSolid[FILENAME], [[41, 4]]);
var root_2368 = add_locations(from_svg(`<desc> </desc>`), ForwardSolid[FILENAME], [[44, 4]]);
var root368 = add_locations(from_svg(`<svg><!><!><path d="M5.027 10.9a8.729 8.729 0 0 1 6.422-3.62v-1.2A2.061 2.061 0 0 1 12.61 4.2a1.986 1.986 0 0 1 2.104.23l5.491 4.308a2.11 2.11 0 0 1 .588 2.566 2.109 2.109 0 0 1-.588.734l-5.489 4.308a1.983 1.983 0 0 1-2.104.228 2.065 2.065 0 0 1-1.16-1.876v-.942c-5.33 1.284-6.212 5.251-6.25 5.441a1 1 0 0 1-.923.806h-.06a1.003 1.003 0 0 1-.955-.7A10.221 10.221 0 0 1 5.027 10.9Z"></path></svg>`), ForwardSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ForwardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ForwardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root368();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1368();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ForwardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2368();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ForwardSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ForwardSolid = hmr(ForwardSolid, () => ForwardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardSolid[HMR].source;
    set(ForwardSolid[HMR].source, module.default[HMR].original);
  });
}
var ForwardSolid_default = ForwardSolid;

// node_modules/flowbite-svelte-icons/dist/ForwardStepOutline.svelte
ForwardStepOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardStepOutline.svelte";
var root_1369 = add_locations(from_svg(`<title> </title>`), ForwardStepOutline[FILENAME], [[43, 4]]);
var root_2369 = add_locations(from_svg(`<desc> </desc>`), ForwardStepOutline[FILENAME], [[46, 4]]);
var root369 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 6v12M8 6v12l8-6-8-6Z"></path></svg>`), ForwardStepOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ForwardStepOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ForwardStepOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root369();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1369();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ForwardStepOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2369();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ForwardStepOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ForwardStepOutline = hmr(ForwardStepOutline, () => ForwardStepOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardStepOutline[HMR].source;
    set(ForwardStepOutline[HMR].source, module.default[HMR].original);
  });
}
var ForwardStepOutline_default = ForwardStepOutline;

// node_modules/flowbite-svelte-icons/dist/ForwardStepSolid.svelte
ForwardStepSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardStepSolid.svelte";
var root_1370 = add_locations(from_svg(`<title> </title>`), ForwardStepSolid[FILENAME], [[41, 4]]);
var root_2370 = add_locations(from_svg(`<desc> </desc>`), ForwardStepSolid[FILENAME], [[44, 4]]);
var root370 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17 6a1 1 0 1 0-2 0v4L8.6 5.2A1 1 0 0 0 7 6v12a1 1 0 0 0 1.6.8L15 14v4a1 1 0 1 0 2 0V6Z" clip-rule="evenodd"></path></svg>`), ForwardStepSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ForwardStepSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ForwardStepSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root370();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1370();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ForwardStepSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2370();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ForwardStepSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ForwardStepSolid = hmr(ForwardStepSolid, () => ForwardStepSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardStepSolid[HMR].source;
    set(ForwardStepSolid[HMR].source, module.default[HMR].original);
  });
}
var ForwardStepSolid_default = ForwardStepSolid;

// node_modules/flowbite-svelte-icons/dist/GiftBoxOutline.svelte
GiftBoxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GiftBoxOutline.svelte";
var root_1371 = add_locations(from_svg(`<title> </title>`), GiftBoxOutline[FILENAME], [[43, 4]]);
var root_2371 = add_locations(from_svg(`<desc> </desc>`), GiftBoxOutline[FILENAME], [[46, 4]]);
var root371 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 21v-9m3-4H7.5a2.5 2.5 0 1 1 0-5c1.5 0 2.875 1.25 3.875 2.5M14 21v-9m-9 0h14v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-8ZM4 8h16a1 1 0 0 1 1 1v3H3V9a1 1 0 0 1 1-1Zm12.155-5c-3 0-5.5 5-5.5 5h5.5a2.5 2.5 0 0 0 0-5Z"></path></svg>`), GiftBoxOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GiftBoxOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GiftBoxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root371();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1371();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GiftBoxOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2371();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GiftBoxOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GiftBoxOutline = hmr(GiftBoxOutline, () => GiftBoxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GiftBoxOutline[HMR].source;
    set(GiftBoxOutline[HMR].source, module.default[HMR].original);
  });
}
var GiftBoxOutline_default = GiftBoxOutline;

// node_modules/flowbite-svelte-icons/dist/GiftBoxSolid.svelte
GiftBoxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GiftBoxSolid.svelte";
var root_1372 = add_locations(from_svg(`<title> </title>`), GiftBoxSolid[FILENAME], [[41, 4]]);
var root_2372 = add_locations(from_svg(`<desc> </desc>`), GiftBoxSolid[FILENAME], [[44, 4]]);
var root372 = add_locations(from_svg(`<svg><!><!><path d="M20 7h-.7c.229-.467.349-.98.351-1.5a3.5 3.5 0 0 0-3.5-3.5c-1.717 0-3.215 1.2-4.331 2.481C10.4 2.842 8.949 2 7.5 2A3.5 3.5 0 0 0 4 5.5c.003.52.123 1.033.351 1.5H4a2 2 0 0 0-2 2v2a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V9a2 2 0 0 0-2-2Zm-9.942 0H7.5a1.5 1.5 0 0 1 0-3c.9 0 2 .754 3.092 2.122-.219.337-.392.635-.534.878Zm6.1 0h-3.742c.933-1.368 2.371-3 3.739-3a1.5 1.5 0 0 1 0 3h.003ZM13 14h-2v8h2v-8Zm-4 0H4v6a2 2 0 0 0 2 2h3v-8Zm6 0v8h3a2 2 0 0 0 2-2v-6h-5Z"></path></svg>`), GiftBoxSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GiftBoxSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GiftBoxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root372();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1372();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GiftBoxSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2372();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GiftBoxSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GiftBoxSolid = hmr(GiftBoxSolid, () => GiftBoxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GiftBoxSolid[HMR].source;
    set(GiftBoxSolid[HMR].source, module.default[HMR].original);
  });
}
var GiftBoxSolid_default = GiftBoxSolid;

// node_modules/flowbite-svelte-icons/dist/GithubSolid.svelte
GithubSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GithubSolid.svelte";
var root_1373 = add_locations(from_svg(`<title> </title>`), GithubSolid[FILENAME], [[41, 4]]);
var root_2373 = add_locations(from_svg(`<desc> </desc>`), GithubSolid[FILENAME], [[44, 4]]);
var root373 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.006 2a9.847 9.847 0 0 0-6.484 2.44 10.32 10.32 0 0 0-3.393 6.17 10.48 10.48 0 0 0 1.317 6.955 10.045 10.045 0 0 0 5.4 4.418c.504.095.683-.223.683-.494 0-.245-.01-1.052-.014-1.908-2.78.62-3.366-1.21-3.366-1.21a2.711 2.711 0 0 0-1.11-1.5c-.907-.637.07-.621.07-.621.317.044.62.163.885.346.266.183.487.426.647.71.135.253.318.476.538.655a2.079 2.079 0 0 0 2.37.196c.045-.52.27-1.006.635-1.37-2.219-.259-4.554-1.138-4.554-5.07a4.022 4.022 0 0 1 1.031-2.75 3.77 3.77 0 0 1 .096-2.713s.839-.275 2.749 1.05a9.26 9.26 0 0 1 5.004 0c1.906-1.325 2.74-1.05 2.74-1.05.37.858.406 1.828.101 2.713a4.017 4.017 0 0 1 1.029 2.75c0 3.939-2.339 4.805-4.564 5.058a2.471 2.471 0 0 1 .679 1.897c0 1.372-.012 2.477-.012 2.814 0 .272.18.592.687.492a10.05 10.05 0 0 0 5.388-4.421 10.473 10.473 0 0 0 1.313-6.948 10.32 10.32 0 0 0-3.39-6.165A9.847 9.847 0 0 0 12.007 2Z" clip-rule="evenodd"></path></svg>`), GithubSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GithubSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GithubSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root373();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1373();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GithubSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2373();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GithubSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GithubSolid = hmr(GithubSolid, () => GithubSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GithubSolid[HMR].source;
    set(GithubSolid[HMR].source, module.default[HMR].original);
  });
}
var GithubSolid_default = GithubSolid;

// node_modules/flowbite-svelte-icons/dist/GitlabSolid.svelte
GitlabSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GitlabSolid.svelte";
var root_1374 = add_locations(from_svg(`<title> </title>`), GitlabSolid[FILENAME], [[41, 4]]);
var root_2374 = add_locations(from_svg(`<desc> </desc>`), GitlabSolid[FILENAME], [[44, 4]]);
var root374 = add_locations(from_svg(`<svg><!><!><path d="m20.7011 10.1255-.0253-.0672-2.4501-6.63953c-.0498-.13013-.1381-.24053-.2521-.31534-.1141-.07354-.2472-.10896-.3812-.10147-.1341.00748-.2628.05751-.3686.14332-.1047.08828-.1806.2079-.2175.34259l-1.6543 5.2556H8.65334l-1.65429-5.2556c-.03588-.13542-.11197-.25564-.21745-.34356-.10584-.08582-.23449-.13584-.36857-.14333-.13409-.00748-.26716.02794-.38125.10148-.11376.07511-.20195.18541-.25213.31534l-2.45472 6.6367-.02437.0671c-.35269.9569-.39623 2.007-.12404 2.9918.27219.9849.84535 1.8511 1.63305 2.4682l.00844.0068.02249.0166 3.73223 2.9022 1.84647 1.4512 1.1247.8817c.1316.1037.2922.1599.4574.1599.1652 0 .3258-.0562.4574-.1599l1.1247-.8817 1.8464-1.4512 3.7548-2.9198.0093-.0077c.786-.6172 1.3578-1.4826 1.6296-2.4661.2717-.9835.2288-2.0321-.1224-2.9881Z"></path></svg>`), GitlabSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GitlabSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GitlabSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root374();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1374();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GitlabSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2374();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GitlabSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GitlabSolid = hmr(GitlabSolid, () => GitlabSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GitlabSolid[HMR].source;
    set(GitlabSolid[HMR].source, module.default[HMR].original);
  });
}
var GitlabSolid_default = GitlabSolid;

// node_modules/flowbite-svelte-icons/dist/GlassWaterDropletOutline.svelte
GlassWaterDropletOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlassWaterDropletOutline.svelte";
var root_1375 = add_locations(from_svg(`<title> </title>`), GlassWaterDropletOutline[FILENAME], [[43, 4]]);
var root_2375 = add_locations(from_svg(`<desc> </desc>`), GlassWaterDropletOutline[FILENAME], [[46, 4]]);
var root375 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 17h10M6 3l1.07554 16.133C7.14558 20.1836 8.01818 21 9.07111 21h5.85779c1.0529 0 1.9255-.8164 1.9956-1.867L18 3H6Zm8 8c0 1.1046-.8954 2-2 2s-2-.8954-2-2c0-1.10457 1.7912-4 2-4 .2088 0 2 2.89543 2 4Z"></path></svg>`), GlassWaterDropletOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GlassWaterDropletOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlassWaterDropletOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root375();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1375();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlassWaterDropletOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2375();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlassWaterDropletOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlassWaterDropletOutline = hmr(GlassWaterDropletOutline, () => GlassWaterDropletOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlassWaterDropletOutline[HMR].source;
    set(GlassWaterDropletOutline[HMR].source, module.default[HMR].original);
  });
}
var GlassWaterDropletOutline_default = GlassWaterDropletOutline;

// node_modules/flowbite-svelte-icons/dist/GlassWaterDropletSolid.svelte
GlassWaterDropletSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlassWaterDropletSolid.svelte";
var root_1376 = add_locations(from_svg(`<title> </title>`), GlassWaterDropletSolid[FILENAME], [[41, 4]]);
var root_2376 = add_locations(from_svg(`<desc> </desc>`), GlassWaterDropletSolid[FILENAME], [[44, 4]]);
var root376 = add_locations(from_svg(`<svg><!><!><path d="M12 6c-.268 0-.4602.10529-.5254.14309-.0858.0497-.1506.10275-.1893.13652-.0789.06896-.1458.1435-.1939.20022-.1011.11923-.2104.26866-.3176.42564-.2184.31962-.4786.74423-.7284 1.19853-.24933.4535-.49952.9569-.69038 1.43273C9.17832 9.97724 9 10.5183 9 11c0 1.6569 1.3431 3 3 3s3-1.3431 3-3c0-.4817-.1783-1.02276-.355-1.46327-.1909-.47583-.4411-.97923-.6904-1.43273-.2498-.4543-.5099-.87891-.7284-1.19853-.1072-.15698-.2165-.30641-.3176-.42564-.0481-.05672-.1149-.13126-.1939-.20022-.0387-.03377-.1035-.08682-.1892-.13652C12.4602 6.10529 12.268 6 12 6Z"></path><path fill-rule="evenodd" d="M6 2c-.27677 0-.54116.11471-.73024.31682-.18909.20211-.28595.47354-.26754.7497L6.07775 19.1996C6.18281 20.7755 7.49172 22 9.07111 22h5.85779c1.5794 0 2.8883-1.2246 2.9934-2.8004l1.0755-16.13308c.0184-.27616-.0785-.54759-.2676-.7497C18.5412 2.11471 18.2768 2 18 2H6Zm1.86889 14-.8-12h9.86221l-.8 12H7.86889Z" clip-rule="evenodd"></path></svg>`), GlassWaterDropletSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function GlassWaterDropletSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlassWaterDropletSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root376();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1376();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlassWaterDropletSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2376();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlassWaterDropletSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlassWaterDropletSolid = hmr(GlassWaterDropletSolid, () => GlassWaterDropletSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlassWaterDropletSolid[HMR].source;
    set(GlassWaterDropletSolid[HMR].source, module.default[HMR].original);
  });
}
var GlassWaterDropletSolid_default = GlassWaterDropletSolid;

// node_modules/flowbite-svelte-icons/dist/GlassWaterOutline.svelte
GlassWaterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlassWaterOutline.svelte";
var root_1377 = add_locations(from_svg(`<title> </title>`), GlassWaterOutline[FILENAME], [[43, 4]]);
var root_2377 = add_locations(from_svg(`<desc> </desc>`), GlassWaterOutline[FILENAME], [[46, 4]]);
var root377 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6.31531 7c1.41852 0 1.41852 1.5 2.83703 1.5C10.5709 8.5 10.5709 7 11.9894 7s1.4185 1.5 2.837 1.5S17.6635 7 17.6635 7M6 3l1.07554 16.133C7.14558 20.1836 8.01818 21 9.07111 21h5.85779c1.0529 0 1.9255-.8164 1.9956-1.867L18 3H6Z"></path></svg>`), GlassWaterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GlassWaterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlassWaterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root377();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1377();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlassWaterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2377();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlassWaterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlassWaterOutline = hmr(GlassWaterOutline, () => GlassWaterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlassWaterOutline[HMR].source;
    set(GlassWaterOutline[HMR].source, module.default[HMR].original);
  });
}
var GlassWaterOutline_default = GlassWaterOutline;

// node_modules/flowbite-svelte-icons/dist/GlassWaterSolid.svelte
GlassWaterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlassWaterSolid.svelte";
var root_1378 = add_locations(from_svg(`<title> </title>`), GlassWaterSolid[FILENAME], [[41, 4]]);
var root_2378 = add_locations(from_svg(`<desc> </desc>`), GlassWaterSolid[FILENAME], [[44, 4]]);
var root378 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 2c-.27677 0-.54116.11471-.73024.31682-.18909.20211-.28595.47354-.26754.7497L6.07775 19.1996C6.18281 20.7755 7.49172 22 9.07111 22h5.85779c1.5794 0 2.8883-1.2246 2.9934-2.8004l1.0755-16.13308c.0184-.27616-.0785-.54759-.2676-.7497C18.5412 2.11471 18.2768 2 18 2H6Zm1.2124 4.15264L7.06889 4h9.86221l-.1651 2.47714-.0179.0163c-.133.12056-.3226.28077-.5474.43924-.4853.34209-.9823.56732-1.3743.56732-.2473 0-.3394-.06433-.6919-.4371l-.0272-.02876C13.7466 6.65192 13.1314 6 11.9894 6c-1.1421 0-1.7573.65192-2.11794 1.03414l-.02716.02876c-.35252.37277-.44468.4371-.69195.4371-.24728 0-.33944-.06433-.69196-.4371l-.02716-.02876c-.25189-.26693-.62791-.66541-1.22083-.8815Z" clip-rule="evenodd"></path></svg>`), GlassWaterSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GlassWaterSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlassWaterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root378();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1378();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlassWaterSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2378();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlassWaterSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlassWaterSolid = hmr(GlassWaterSolid, () => GlassWaterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlassWaterSolid[HMR].source;
    set(GlassWaterSolid[HMR].source, module.default[HMR].original);
  });
}
var GlassWaterSolid_default = GlassWaterSolid;

// node_modules/flowbite-svelte-icons/dist/GlobeOutline.svelte
GlobeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlobeOutline.svelte";
var root_1379 = add_locations(from_svg(`<title> </title>`), GlobeOutline[FILENAME], [[43, 4]]);
var root_2379 = add_locations(from_svg(`<desc> </desc>`), GlobeOutline[FILENAME], [[46, 4]]);
var root379 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M4.37 7.657c2.063.528 2.396 2.806 3.202 3.87 1.07 1.413 2.075 1.228 3.192 2.644 1.805 2.289 1.312 5.705 1.312 6.705M20 15h-1a4 4 0 0 0-4 4v1M8.587 3.992c0 .822.112 1.886 1.515 2.58 1.402.693 2.918.351 2.918 2.334 0 .276 0 2.008 1.972 2.008 2.026.031 2.026-1.678 2.026-2.008 0-.65.527-.9 1.177-.9H20M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), GlobeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GlobeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlobeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root379();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1379();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlobeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2379();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlobeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlobeOutline = hmr(GlobeOutline, () => GlobeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlobeOutline[HMR].source;
    set(GlobeOutline[HMR].source, module.default[HMR].original);
  });
}
var GlobeOutline_default = GlobeOutline;

// node_modules/flowbite-svelte-icons/dist/GlobeSolid.svelte
GlobeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlobeSolid.svelte";
var root_1380 = add_locations(from_svg(`<title> </title>`), GlobeSolid[FILENAME], [[41, 4]]);
var root_2380 = add_locations(from_svg(`<desc> </desc>`), GlobeSolid[FILENAME], [[44, 4]]);
var root380 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.64 4.737A7.97 7.97 0 0 1 12 4a7.997 7.997 0 0 1 6.933 4.006h-.738c-.65 0-1.177.25-1.177.9 0 .33 0 2.04-2.026 2.008-1.972 0-1.972-1.732-1.972-2.008 0-1.429-.787-1.65-1.752-1.923-.374-.105-.774-.218-1.166-.411-1.004-.497-1.347-1.183-1.461-1.835ZM6 4a10.06 10.06 0 0 0-2.812 3.27A9.956 9.956 0 0 0 2 12c0 5.289 4.106 9.619 9.304 9.976l.054.004a10.12 10.12 0 0 0 1.155.007h.002a10.024 10.024 0 0 0 1.5-.19 9.925 9.925 0 0 0 2.259-.754 10.041 10.041 0 0 0 4.987-5.263A9.917 9.917 0 0 0 22 12a10.025 10.025 0 0 0-.315-2.5A10.001 10.001 0 0 0 12 2a9.964 9.964 0 0 0-6 2Zm13.372 11.113a2.575 2.575 0 0 0-.75-.112h-.217A3.405 3.405 0 0 0 15 18.405v1.014a8.027 8.027 0 0 0 4.372-4.307ZM12.114 20H12A8 8 0 0 1 5.1 7.95c.95.541 1.421 1.537 1.835 2.415.209.441.403.853.637 1.162.54.712 1.063 1.019 1.591 1.328.52.305 1.047.613 1.6 1.316 1.44 1.825 1.419 4.366 1.35 5.828Z" clip-rule="evenodd"></path></svg>`), GlobeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GlobeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GlobeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root380();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1380();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GlobeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2380();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GlobeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GlobeSolid = hmr(GlobeSolid, () => GlobeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlobeSolid[HMR].source;
    set(GlobeSolid[HMR].source, module.default[HMR].original);
  });
}
var GlobeSolid_default = GlobeSolid;

// node_modules/flowbite-svelte-icons/dist/GoogleSolid.svelte
GoogleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoogleSolid.svelte";
var root_1381 = add_locations(from_svg(`<title> </title>`), GoogleSolid[FILENAME], [[41, 4]]);
var root_2381 = add_locations(from_svg(`<desc> </desc>`), GoogleSolid[FILENAME], [[44, 4]]);
var root381 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.037 21.998a10.313 10.313 0 0 1-7.168-3.049 9.888 9.888 0 0 1-2.868-7.118 9.947 9.947 0 0 1 3.064-6.949A10.37 10.37 0 0 1 12.212 2h.176a9.935 9.935 0 0 1 6.614 2.564L16.457 6.88a6.187 6.187 0 0 0-4.131-1.566 6.9 6.9 0 0 0-4.794 1.913 6.618 6.618 0 0 0-2.045 4.657 6.608 6.608 0 0 0 1.882 4.723 6.891 6.891 0 0 0 4.725 2.07h.143c1.41.072 2.8-.354 3.917-1.2a5.77 5.77 0 0 0 2.172-3.41l.043-.117H12.22v-3.41h9.678c.075.617.109 1.238.1 1.859-.099 5.741-4.017 9.6-9.746 9.6l-.215-.002Z" clip-rule="evenodd"></path></svg>`), GoogleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GoogleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GoogleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root381();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1381();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GoogleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2381();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GoogleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GoogleSolid = hmr(GoogleSolid, () => GoogleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoogleSolid[HMR].source;
    set(GoogleSolid[HMR].source, module.default[HMR].original);
  });
}
var GoogleSolid_default = GoogleSolid;

// node_modules/flowbite-svelte-icons/dist/GoToNextCellOutline.svelte
GoToNextCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoToNextCellOutline.svelte";
var root_1382 = add_locations(from_svg(`<title> </title>`), GoToNextCellOutline[FILENAME], [[43, 4]]);
var root_2382 = add_locations(from_svg(`<desc> </desc>`), GoToNextCellOutline[FILENAME], [[46, 4]]);
var root382 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h9.5M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5H3Zm5 0v8m4-8v8m7.0999-1.0999L21 16m0 0-1.9001-1.9001M21 16h-5"></path></svg>`), GoToNextCellOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GoToNextCellOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GoToNextCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root382();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1382();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GoToNextCellOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2382();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GoToNextCellOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GoToNextCellOutline = hmr(GoToNextCellOutline, () => GoToNextCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoToNextCellOutline[HMR].source;
    set(GoToNextCellOutline[HMR].source, module.default[HMR].original);
  });
}
var GoToNextCellOutline_default = GoToNextCellOutline;

// node_modules/flowbite-svelte-icons/dist/GoToPrevCellOutline.svelte
GoToPrevCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoToPrevCellOutline.svelte";
var root_1383 = add_locations(from_svg(`<title> </title>`), GoToPrevCellOutline[FILENAME], [[43, 4]]);
var root_2383 = add_locations(from_svg(`<desc> </desc>`), GoToPrevCellOutline[FILENAME], [[46, 4]]);
var root383 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h9.5M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5H3Zm5 0v8m4-8v8m5.9001-1.0999L16 16m0 0 1.9001-1.9001M16 16h5"></path></svg>`), GoToPrevCellOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GoToPrevCellOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GoToPrevCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root383();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1383();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GoToPrevCellOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2383();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GoToPrevCellOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GoToPrevCellOutline = hmr(GoToPrevCellOutline, () => GoToPrevCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoToPrevCellOutline[HMR].source;
    set(GoToPrevCellOutline[HMR].source, module.default[HMR].original);
  });
}
var GoToPrevCellOutline_default = GoToPrevCellOutline;

// node_modules/flowbite-svelte-icons/dist/GraduationCapOutline.svelte
GraduationCapOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GraduationCapOutline.svelte";
var root_1384 = add_locations(from_svg(`<title> </title>`), GraduationCapOutline[FILENAME], [[43, 4]]);
var root_2384 = add_locations(from_svg(`<desc> </desc>`), GraduationCapOutline[FILENAME], [[46, 4]]);
var root384 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3.78552 9.5 12.7855 14l9-4.5-9-4.5-8.99998 4.5Zm0 0V17m3-6v6.2222c0 .3483 2 1.7778 5.99998 1.7778 4 0 6-1.3738 6-1.7778V11"></path></svg>`), GraduationCapOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GraduationCapOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GraduationCapOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root384();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1384();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GraduationCapOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2384();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GraduationCapOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GraduationCapOutline = hmr(GraduationCapOutline, () => GraduationCapOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GraduationCapOutline[HMR].source;
    set(GraduationCapOutline[HMR].source, module.default[HMR].original);
  });
}
var GraduationCapOutline_default = GraduationCapOutline;

// node_modules/flowbite-svelte-icons/dist/GraduationCapSolid.svelte
GraduationCapSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GraduationCapSolid.svelte";
var root_1385 = add_locations(from_svg(`<title> </title>`), GraduationCapSolid[FILENAME], [[41, 4]]);
var root_2385 = add_locations(from_svg(`<desc> </desc>`), GraduationCapSolid[FILENAME], [[44, 4]]);
var root385 = add_locations(from_svg(`<svg><!><!><path d="M12.4472 4.10557c-.2815-.14076-.6129-.14076-.8944 0L2.76981 8.49706l9.21949 4.39024L21 8.38195l-8.5528-4.27638Z"></path><path d="M5 17.2222v-5.448l6.5701 3.1286c.278.1325.6016.1293.8771-.0084L19 11.618v5.6042c0 .2857-.1229.5583-.3364.7481l-.0025.0022-.0041.0036-.0103.009-.0119.0101-.0181.0152c-.024.02-.0562.0462-.0965.0776-.0807.0627-.1942.1465-.3405.2441-.2926.195-.7171.4455-1.2736.6928C15.7905 19.5208 14.1527 20 12 20c-2.15265 0-3.79045-.4792-4.90614-.9751-.5565-.2473-.98098-.4978-1.27356-.6928-.14631-.0976-.2598-.1814-.34049-.2441-.04036-.0314-.07254-.0576-.09656-.0776-.01201-.01-.02198-.0185-.02991-.0253l-.01038-.009-.00404-.0036-.00174-.0015-.0008-.0007s-.00004 0 .00978-.0112l-.00009-.0012-.01043.0117C5.12215 17.7799 5 17.5079 5 17.2222Zm-3-6.8765 2 .9523V17c0 .5523-.44772 1-1 1s-1-.4477-1-1v-6.6543Z"></path></svg>`), GraduationCapSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function GraduationCapSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GraduationCapSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root385();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1385();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GraduationCapSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2385();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GraduationCapSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GraduationCapSolid = hmr(GraduationCapSolid, () => GraduationCapSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GraduationCapSolid[HMR].source;
    set(GraduationCapSolid[HMR].source, module.default[HMR].original);
  });
}
var GraduationCapSolid_default = GraduationCapSolid;

// node_modules/flowbite-svelte-icons/dist/GridOutline.svelte
GridOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridOutline.svelte";
var root_1386 = add_locations(from_svg(`<title> </title>`), GridOutline[FILENAME], [[43, 4]]);
var root_2386 = add_locations(from_svg(`<desc> </desc>`), GridOutline[FILENAME], [[46, 4]]);
var root386 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.143 4H4.857A.857.857 0 0 0 4 4.857v4.286c0 .473.384.857.857.857h4.286A.857.857 0 0 0 10 9.143V4.857A.857.857 0 0 0 9.143 4Zm10 0h-4.286a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286A.857.857 0 0 0 20 9.143V4.857A.857.857 0 0 0 19.143 4Zm-10 10H4.857a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286a.857.857 0 0 0 .857-.857v-4.286A.857.857 0 0 0 9.143 14Zm10 0h-4.286a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286a.857.857 0 0 0 .857-.857v-4.286a.857.857 0 0 0-.857-.857Z"></path></svg>`), GridOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GridOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GridOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root386();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1386();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GridOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2386();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GridOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GridOutline = hmr(GridOutline, () => GridOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridOutline[HMR].source;
    set(GridOutline[HMR].source, module.default[HMR].original);
  });
}
var GridOutline_default = GridOutline;

// node_modules/flowbite-svelte-icons/dist/GridPlusOutline.svelte
GridPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridPlusOutline.svelte";
var root_1387 = add_locations(from_svg(`<title> </title>`), GridPlusOutline[FILENAME], [[43, 4]]);
var root_2387 = add_locations(from_svg(`<desc> </desc>`), GridPlusOutline[FILENAME], [[46, 4]]);
var root387 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 17h6m-3 3v-6M4.857 4h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857H4.857A.857.857 0 0 1 4 9.143V4.857C4 4.384 4.384 4 4.857 4Zm10 0h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857h-4.286A.857.857 0 0 1 14 9.143V4.857c0-.473.384-.857.857-.857Zm-10 10h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857H4.857A.857.857 0 0 1 4 19.143v-4.286c0-.473.384-.857.857-.857Z"></path></svg>`), GridPlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function GridPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GridPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root387();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1387();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GridPlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2387();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GridPlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GridPlusOutline = hmr(GridPlusOutline, () => GridPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridPlusOutline[HMR].source;
    set(GridPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var GridPlusOutline_default = GridPlusOutline;

// node_modules/flowbite-svelte-icons/dist/GridPlusSolid.svelte
GridPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridPlusSolid.svelte";
var root_1388 = add_locations(from_svg(`<title> </title>`), GridPlusSolid[FILENAME], [[41, 4]]);
var root_2388 = add_locations(from_svg(`<desc> </desc>`), GridPlusSolid[FILENAME], [[44, 4]]);
var root388 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4.857 3A1.857 1.857 0 0 0 3 4.857v4.286C3 10.169 3.831 11 4.857 11h4.286A1.857 1.857 0 0 0 11 9.143V4.857A1.857 1.857 0 0 0 9.143 3H4.857Zm10 0A1.857 1.857 0 0 0 13 4.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 9.143V4.857A1.857 1.857 0 0 0 19.143 3h-4.286Zm-10 10A1.857 1.857 0 0 0 3 14.857v4.286C3 20.169 3.831 21 4.857 21h4.286A1.857 1.857 0 0 0 11 19.143v-4.286A1.857 1.857 0 0 0 9.143 13H4.857ZM18 14a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2Z" clip-rule="evenodd"></path></svg>`), GridPlusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GridPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GridPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root388();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1388();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GridPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2388();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GridPlusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GridPlusSolid = hmr(GridPlusSolid, () => GridPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridPlusSolid[HMR].source;
    set(GridPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var GridPlusSolid_default = GridPlusSolid;

// node_modules/flowbite-svelte-icons/dist/GridSolid.svelte
GridSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridSolid.svelte";
var root_1389 = add_locations(from_svg(`<title> </title>`), GridSolid[FILENAME], [[41, 4]]);
var root_2389 = add_locations(from_svg(`<desc> </desc>`), GridSolid[FILENAME], [[44, 4]]);
var root389 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4.857 3A1.857 1.857 0 0 0 3 4.857v4.286C3 10.169 3.831 11 4.857 11h4.286A1.857 1.857 0 0 0 11 9.143V4.857A1.857 1.857 0 0 0 9.143 3H4.857Zm10 0A1.857 1.857 0 0 0 13 4.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 9.143V4.857A1.857 1.857 0 0 0 19.143 3h-4.286Zm-10 10A1.857 1.857 0 0 0 3 14.857v4.286C3 20.169 3.831 21 4.857 21h4.286A1.857 1.857 0 0 0 11 19.143v-4.286A1.857 1.857 0 0 0 9.143 13H4.857Zm10 0A1.857 1.857 0 0 0 13 14.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 19.143v-4.286A1.857 1.857 0 0 0 19.143 13h-4.286Z" clip-rule="evenodd"></path></svg>`), GridSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function GridSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, GridSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root389();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1389();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      GridSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2389();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      GridSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  GridSolid = hmr(GridSolid, () => GridSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridSolid[HMR].source;
    set(GridSolid[HMR].source, module.default[HMR].original);
  });
}
var GridSolid_default = GridSolid;

// node_modules/flowbite-svelte-icons/dist/HammerOutline.svelte
HammerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HammerOutline.svelte";
var root_1390 = add_locations(from_svg(`<title> </title>`), HammerOutline[FILENAME], [[43, 4]]);
var root_2390 = add_locations(from_svg(`<desc> </desc>`), HammerOutline[FILENAME], [[46, 4]]);
var root390 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="m20.9532 11.7634-2.0523-2.05225-2.0523 2.05225 2.0523 2.0523 2.0523-2.0523Zm-1.3681-2.73651-4.1046-4.10457L12.06 8.3428l4.1046 4.1046 3.4205-3.42051Zm-4.1047 2.73651-2.7363-2.73638-8.20919 8.20918 2.73639 2.7364 8.2091-8.2092Z"></path><path stroke="currentColor" stroke-linejoin="round" d="m12.9306 3.74083 1.8658 1.86571-2.0523 2.05229-1.5548-1.55476c-.995-.99505-3.23389-.49753-3.91799.18657l2.73639-2.73639c.6841-.68409 1.9901-.74628 2.9229.18658Z"></path></svg>`), HammerOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function HammerOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HammerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root390();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1390();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HammerOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2390();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HammerOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HammerOutline = hmr(HammerOutline, () => HammerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HammerOutline[HMR].source;
    set(HammerOutline[HMR].source, module.default[HMR].original);
  });
}
var HammerOutline_default = HammerOutline;

// node_modules/flowbite-svelte-icons/dist/HammerSolid.svelte
HammerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HammerSolid.svelte";
var root_1391 = add_locations(from_svg(`<title> </title>`), HammerSolid[FILENAME], [[41, 4]]);
var root_2391 = add_locations(from_svg(`<desc> </desc>`), HammerSolid[FILENAME], [[44, 4]]);
var root391 = add_locations(from_svg(`<svg><!><!><path d="M8.4 6.763c-.251.1-.383.196-.422.235L6.564 5.584l2.737-2.737c1.113-1.113 3.053-1.097 4.337.187l1.159 1.159a1 1 0 0 1 1.39.022l4.105 4.105a1 1 0 0 1 .023 1.39l1.345 1.346a1 1 0 0 1 0 1.415l-2.052 2.052a1 1 0 0 1-1.414 0l-1.346-1.346a1 1 0 0 1-1.323.039L11.29 8.983a1 1 0 0 1 .04-1.324l-.849-.848c-.18-.18-.606-.322-1.258-.25a3.271 3.271 0 0 0-.824.202Zm1.519 3.675L3.828 16.53a1 1 0 0 0 0 1.414l2.736 2.737a1 1 0 0 0 1.414 0l6.091-6.091-4.15-4.15Z"></path></svg>`), HammerSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HammerSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HammerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root391();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1391();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HammerSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2391();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HammerSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HammerSolid = hmr(HammerSolid, () => HammerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HammerSolid[HMR].source;
    set(HammerSolid[HMR].source, module.default[HMR].original);
  });
}
var HammerSolid_default = HammerSolid;

// node_modules/flowbite-svelte-icons/dist/HeadphonesOutline.svelte
HeadphonesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeadphonesOutline.svelte";
var root_1392 = add_locations(from_svg(`<title> </title>`), HeadphonesOutline[FILENAME], [[43, 4]]);
var root_2392 = add_locations(from_svg(`<desc> </desc>`), HeadphonesOutline[FILENAME], [[46, 4]]);
var root392 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M20 16v-4a8 8 0 1 0-16 0v4m16 0v2a2 2 0 0 1-2 2h-2v-6h2a2 2 0 0 1 2 2ZM4 16v2a2 2 0 0 0 2 2h2v-6H6a2 2 0 0 0-2 2Z"></path></svg>`), HeadphonesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function HeadphonesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HeadphonesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root392();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1392();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HeadphonesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2392();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HeadphonesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HeadphonesOutline = hmr(HeadphonesOutline, () => HeadphonesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeadphonesOutline[HMR].source;
    set(HeadphonesOutline[HMR].source, module.default[HMR].original);
  });
}
var HeadphonesOutline_default = HeadphonesOutline;

// node_modules/flowbite-svelte-icons/dist/HeadphonesSolid.svelte
HeadphonesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeadphonesSolid.svelte";
var root_1393 = add_locations(from_svg(`<title> </title>`), HeadphonesSolid[FILENAME], [[41, 4]]);
var root_2393 = add_locations(from_svg(`<desc> </desc>`), HeadphonesSolid[FILENAME], [[44, 4]]);
var root393 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 5a7 7 0 0 0-7 7v1.17c.313-.11.65-.17 1-.17h2a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H6a3 3 0 0 1-3-3v-6a9 9 0 0 1 18 0v6a3 3 0 0 1-3 3h-2a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1h2c.35 0 .687.06 1 .17V12a7 7 0 0 0-7-7Z" clip-rule="evenodd"></path></svg>`), HeadphonesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HeadphonesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HeadphonesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root393();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1393();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HeadphonesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2393();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HeadphonesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HeadphonesSolid = hmr(HeadphonesSolid, () => HeadphonesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeadphonesSolid[HMR].source;
    set(HeadphonesSolid[HMR].source, module.default[HMR].original);
  });
}
var HeadphonesSolid_default = HeadphonesSolid;

// node_modules/flowbite-svelte-icons/dist/HeartOutline.svelte
HeartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeartOutline.svelte";
var root_1394 = add_locations(from_svg(`<title> </title>`), HeartOutline[FILENAME], [[43, 4]]);
var root_2394 = add_locations(from_svg(`<desc> </desc>`), HeartOutline[FILENAME], [[46, 4]]);
var root394 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.01 6.001C6.5 1 1 8 5.782 13.001L12.011 20l6.23-7C23 8 17.5 1 12.01 6.002Z"></path></svg>`), HeartOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function HeartOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HeartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root394();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1394();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HeartOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2394();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HeartOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HeartOutline = hmr(HeartOutline, () => HeartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeartOutline[HMR].source;
    set(HeartOutline[HMR].source, module.default[HMR].original);
  });
}
var HeartOutline_default = HeartOutline;

// node_modules/flowbite-svelte-icons/dist/HeartSolid.svelte
HeartSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeartSolid.svelte";
var root_1395 = add_locations(from_svg(`<title> </title>`), HeartSolid[FILENAME], [[41, 4]]);
var root_2395 = add_locations(from_svg(`<desc> </desc>`), HeartSolid[FILENAME], [[44, 4]]);
var root395 = add_locations(from_svg(`<svg><!><!><path d="m12.75 20.66 6.184-7.098c2.677-2.884 2.559-6.506.754-8.705-.898-1.095-2.206-1.816-3.72-1.855-1.293-.034-2.652.43-3.963 1.442-1.315-1.012-2.678-1.476-3.973-1.442-1.515.04-2.825.76-3.724 1.855-1.806 2.201-1.915 5.823.772 8.706l6.183 7.097c.19.216.46.34.743.34a.985.985 0 0 0 .743-.34Z"></path></svg>`), HeartSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HeartSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HeartSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root395();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1395();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HeartSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2395();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HeartSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HeartSolid = hmr(HeartSolid, () => HeartSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeartSolid[HMR].source;
    set(HeartSolid[HMR].source, module.default[HMR].original);
  });
}
var HeartSolid_default = HeartSolid;

// node_modules/flowbite-svelte-icons/dist/HomeOutline.svelte
HomeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HomeOutline.svelte";
var root_1396 = add_locations(from_svg(`<title> </title>`), HomeOutline[FILENAME], [[43, 4]]);
var root_2396 = add_locations(from_svg(`<desc> </desc>`), HomeOutline[FILENAME], [[46, 4]]);
var root396 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4 12 8-8 8 8M6 10.5V19a1 1 0 0 0 1 1h3v-3a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3h3a1 1 0 0 0 1-1v-8.5"></path></svg>`), HomeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function HomeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HomeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root396();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1396();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HomeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2396();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HomeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HomeOutline = hmr(HomeOutline, () => HomeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HomeOutline[HMR].source;
    set(HomeOutline[HMR].source, module.default[HMR].original);
  });
}
var HomeOutline_default = HomeOutline;

// node_modules/flowbite-svelte-icons/dist/HomeSolid.svelte
HomeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HomeSolid.svelte";
var root_1397 = add_locations(from_svg(`<title> </title>`), HomeSolid[FILENAME], [[41, 4]]);
var root_2397 = add_locations(from_svg(`<desc> </desc>`), HomeSolid[FILENAME], [[44, 4]]);
var root397 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.293 3.293a1 1 0 0 1 1.414 0l6 6 2 2a1 1 0 0 1-1.414 1.414L19 12.414V19a2 2 0 0 1-2 2h-3a1 1 0 0 1-1-1v-3h-2v3a1 1 0 0 1-1 1H7a2 2 0 0 1-2-2v-6.586l-.293.293a1 1 0 0 1-1.414-1.414l2-2 6-6Z" clip-rule="evenodd"></path></svg>`), HomeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HomeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HomeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root397();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1397();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HomeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2397();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HomeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HomeSolid = hmr(HomeSolid, () => HomeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HomeSolid[HMR].source;
    set(HomeSolid[HMR].source, module.default[HMR].original);
  });
}
var HomeSolid_default = HomeSolid;

// node_modules/flowbite-svelte-icons/dist/HorizontalLinesOutline.svelte
HorizontalLinesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HorizontalLinesOutline.svelte";
var root_1398 = add_locations(from_svg(`<title> </title>`), HorizontalLinesOutline[FILENAME], [[43, 4]]);
var root_2398 = add_locations(from_svg(`<desc> </desc>`), HorizontalLinesOutline[FILENAME], [[46, 4]]);
var root398 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 12h14"></path><path stroke="currentColor" stroke-linecap="round" d="M6 9.5h12m-12-2h12m-12-2h12m-12 13h12m-12-2h12m-12-2h12"></path></svg>`), HorizontalLinesOutline[FILENAME], [[31, 0, [[48, 2], [49, 2]]]]);
function HorizontalLinesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HorizontalLinesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root398();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1398();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HorizontalLinesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2398();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HorizontalLinesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  next();
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HorizontalLinesOutline = hmr(HorizontalLinesOutline, () => HorizontalLinesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HorizontalLinesOutline[HMR].source;
    set(HorizontalLinesOutline[HMR].source, module.default[HMR].original);
  });
}
var HorizontalLinesOutline_default = HorizontalLinesOutline;

// node_modules/flowbite-svelte-icons/dist/HotdogOutline.svelte
HotdogOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HotdogOutline.svelte";
var root_1399 = add_locations(from_svg(`<title> </title>`), HotdogOutline[FILENAME], [[43, 4]]);
var root_2399 = add_locations(from_svg(`<desc> </desc>`), HotdogOutline[FILENAME], [[46, 4]]);
var root399 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m11.5 8.00003 1-1M11.5 12.5l1-1m-1 5.5 1-1M9 20V4.00003h-.5c-1.933 0-3.5 1.567-3.5 3.5V16.5C5 18.433 6.567 20 8.5 20H9Zm6 0V4.00003h.5c1.933 0 3.5 1.567 3.5 3.5V16.5c0 1.933-1.567 3.5-3.5 3.5H15Zm0-2V6.00003c0-1.65685-1.3431-3-3-3s-3 1.34315-3 3V18c0 1.6569 1.3431 3 3 3s3-1.3431 3-3Z"></path></svg>`), HotdogOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function HotdogOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HotdogOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root399();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1399();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HotdogOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2399();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HotdogOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HotdogOutline = hmr(HotdogOutline, () => HotdogOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HotdogOutline[HMR].source;
    set(HotdogOutline[HMR].source, module.default[HMR].original);
  });
}
var HotdogOutline_default = HotdogOutline;

// node_modules/flowbite-svelte-icons/dist/HotdogSolid.svelte
HotdogSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HotdogSolid.svelte";
var root_1400 = add_locations(from_svg(`<title> </title>`), HotdogSolid[FILENAME], [[41, 4]]);
var root_2400 = add_locations(from_svg(`<desc> </desc>`), HotdogSolid[FILENAME], [[44, 4]]);
var root400 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10 2.53528c.5883-.34034 1.2714-.53513 2-.53513.7286 0 1.4117.19479 2 .53513V21.465c-.5883.3404-1.2714.5352-2 .5352-.7286 0-1.4117-.1948-2-.5352V2.53528Zm3.2071 5.17192c.3905-.39053.3905-1.02369 0-1.41422-.3905-.39052-1.0237-.39052-1.4142 0l-1 1c-.3905.39053-.3905 1.02369 0 1.41422.3905.39052 1.0237.39052 1.4142 0l1-1Zm0 4.5c.3905-.3905.3905-1.0237 0-1.4142-.3905-.3905-1.0237-.3905-1.4142 0l-1 1c-.3905.3905-.3905 1.0237 0 1.4142.3905.3905 1.0237.3905 1.4142 0l1-1Zm0 4.5c.3905-.3905.3905-1.0237 0-1.4142-.3905-.3905-1.0237-.3905-1.4142 0l-1 1c-.3905.3905-.3905 1.0237 0 1.4142.3905.3905 1.0237.3905 1.4142 0l1-1Z" clip-rule="evenodd"></path><path d="M8 3.02762c-2.24998.24872-4 2.15626-4 4.47253v9.00005c0 2.3162 1.75002 4.2238 4 4.4725V3.02762Zm8 17.94508c2.25-.2487 4-2.1563 4-4.4725V7.50015c0-2.31627-1.75-4.22381-4-4.47253V20.9727Z"></path></svg>`), HotdogSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function HotdogSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HotdogSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root400();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1400();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HotdogSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2400();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HotdogSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HotdogSolid = hmr(HotdogSolid, () => HotdogSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HotdogSolid[HMR].source;
    set(HotdogSolid[HMR].source, module.default[HMR].original);
  });
}
var HotdogSolid_default = HotdogSolid;

// node_modules/flowbite-svelte-icons/dist/HourglassOutline.svelte
HourglassOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HourglassOutline.svelte";
var root_1401 = add_locations(from_svg(`<title> </title>`), HourglassOutline[FILENAME], [[43, 4]]);
var root_2401 = add_locations(from_svg(`<desc> </desc>`), HourglassOutline[FILENAME], [[46, 4]]);
var root401 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5 4h-13m13 16h-13M8 20v-3.333a2 2 0 0 1 .4-1.2L10 12.6a1 1 0 0 0 0-1.2L8.4 8.533a2 2 0 0 1-.4-1.2V4h8v3.333a2 2 0 0 1-.4 1.2L13.957 11.4a1 1 0 0 0 0 1.2l1.643 2.867a2 2 0 0 1 .4 1.2V20H8Z"></path></svg>`), HourglassOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function HourglassOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HourglassOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root401();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1401();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HourglassOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2401();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HourglassOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HourglassOutline = hmr(HourglassOutline, () => HourglassOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HourglassOutline[HMR].source;
    set(HourglassOutline[HMR].source, module.default[HMR].original);
  });
}
var HourglassOutline_default = HourglassOutline;

// node_modules/flowbite-svelte-icons/dist/HourglassSolid.svelte
HourglassSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HourglassSolid.svelte";
var root_1402 = add_locations(from_svg(`<title> </title>`), HourglassSolid[FILENAME], [[41, 4]]);
var root_2402 = add_locations(from_svg(`<desc> </desc>`), HourglassSolid[FILENAME], [[44, 4]]);
var root402 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.5 3a1 1 0 0 0 0 2H7v2.333a3 3 0 0 0 .556 1.74l1.57 2.814A1.1 1.1 0 0 0 9.2 12a.998.998 0 0 0-.073.113l-1.57 2.814A3 3 0 0 0 7 16.667V19H5.5a1 1 0 1 0 0 2h13a1 1 0 1 0 0-2H17v-2.333a3 3 0 0 0-.56-1.745l-1.616-2.82a1 1 0 0 0-.067-.102 1 1 0 0 0 .067-.103l1.616-2.819A3 3 0 0 0 17 7.333V5h1.5a1 1 0 1 0 0-2h-13Z" clip-rule="evenodd"></path></svg>`), HourglassSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HourglassSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HourglassSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root402();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1402();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HourglassSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2402();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HourglassSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HourglassSolid = hmr(HourglassSolid, () => HourglassSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HourglassSolid[HMR].source;
    set(HourglassSolid[HMR].source, module.default[HMR].original);
  });
}
var HourglassSolid_default = HourglassSolid;

// node_modules/flowbite-svelte-icons/dist/HtmlSolid.svelte
HtmlSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HtmlSolid.svelte";
var root_1403 = add_locations(from_svg(`<title> </title>`), HtmlSolid[FILENAME], [[41, 4]]);
var root_2403 = add_locations(from_svg(`<desc> </desc>`), HtmlSolid[FILENAME], [[44, 4]]);
var root403 = add_locations(from_svg(`<svg><!><!><path d="m3 2 1.578 17.824L12 22l7.467-2.175L21 2H3Zm14.049 6.048H9.075l.172 2.016h7.697l-.626 6.565-4.246 1.381-4.281-1.455-.288-2.932h2.024l.16 1.411 2.4.815 2.346-.763.297-3.005H7.416l-.562-6.05h10.412l-.217 2.017Z"></path></svg>`), HtmlSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function HtmlSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, HtmlSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root403();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1403();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      HtmlSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2403();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      HtmlSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  HtmlSolid = hmr(HtmlSolid, () => HtmlSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HtmlSolid[HMR].source;
    set(HtmlSolid[HMR].source, module.default[HMR].original);
  });
}
var HtmlSolid_default = HtmlSolid;

// node_modules/flowbite-svelte-icons/dist/IcecreamAltOutline.svelte
IcecreamAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IcecreamAltOutline.svelte";
var root_1404 = add_locations(from_svg(`<title> </title>`), IcecreamAltOutline[FILENAME], [[43, 4]]);
var root_2404 = add_locations(from_svg(`<desc> </desc>`), IcecreamAltOutline[FILENAME], [[46, 4]]);
var root404 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 6c0-1.65685 1.3431-3 3-3s3 1.34315 3 3M9 6c0 1.04349.53275 1.96254 1.3411 2.5M9 6C7.34315 6 6 7.34315 6 9c0 1.6569 1.34315 3 3 3m6.3893 0c1.6568 0 3-1.3431 3-3 0-1.65685-1.3432-3-3-3-.6134 0-1.1838.18408-1.6589.5M8 12h8l-4 9-4-9Z"></path></svg>`), IcecreamAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function IcecreamAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IcecreamAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root404();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1404();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IcecreamAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2404();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IcecreamAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IcecreamAltOutline = hmr(IcecreamAltOutline, () => IcecreamAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IcecreamAltOutline[HMR].source;
    set(IcecreamAltOutline[HMR].source, module.default[HMR].original);
  });
}
var IcecreamAltOutline_default = IcecreamAltOutline;

// node_modules/flowbite-svelte-icons/dist/IcecreamAltSolid.svelte
IcecreamAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IcecreamAltSolid.svelte";
var root_1405 = add_locations(from_svg(`<title> </title>`), IcecreamAltSolid[FILENAME], [[41, 4]]);
var root_2405 = add_locations(from_svg(`<desc> </desc>`), IcecreamAltSolid[FILENAME], [[44, 4]]);
var root405 = add_locations(from_svg(`<svg><!><!><path d="M16 12H8l4 9 4-9Z"></path><path d="M14 6c0 .55228.4477 1 1 1s1-.44772 1-1h-2ZM9.78743 9.33273c.45987.30579 1.08057.18085 1.38637-.27906.3058-.4599.1809-1.08062-.279-1.3864L9.78743 9.33273ZM15.3893 11c-.5523 0-1 .4477-1 1s.4477 1 1 1v-2Zm-2.2126-5.33273c-.4599.30578-.5848.9265-.2791 1.3864.3058.45991.9265.58485 1.3865.27906l-1.1074-1.66546ZM8 12v-1c-.33851 0-.65403.1713-.83849.4551-.18446.2838-.2128.6417-.07532.951L8 12Zm8 0 .9138.4061c.1375-.3093.1091-.6672-.0753-.951C16.654 11.1713 16.3385 11 16 11v1Zm-4 9-.9138.4061c.1605.3612.5186.5939.9138.5939s.7533-.2327.9138-.5939L12 21ZM10 6c0-1.10457.8954-2 2-2V2C9.79086 2 8 3.79086 8 6h2Zm2-2c1.1046 0 2 .89543 2 2h2c0-2.20914-1.7909-4-4-4v2Zm-1.1052 3.66727C10.3533 7.30728 10 6.69469 10 6H8c0 1.39228.71216 2.6178 1.78743 3.33273l1.10737-1.66546ZM9 11c-1.10457 0-2-.8954-2-2H5c0 2.2091 1.79086 4 4 4v-2ZM7 9c0-1.10457.89543-2 2-2V5C6.79086 5 5 6.79086 5 9h2Zm10.3893 0c0 1.1046-.8955 2-2 2v2c2.2091 0 4-1.7909 4-4h-2Zm-2-2c1.1045 0 2 .89543 2 2h2c0-2.20914-1.7909-4-4-4v2Zm-1.1052.33273C14.6002 7.1225 14.9789 7 15.3893 7V5c-.8164 0-1.5785.24565-2.2126.66727l1.1074 1.66546ZM8 13h8v-2H8v2Zm7.0862-1.4061-4 9 1.8276.8122 4-9-1.8276-.8122Zm-2.1724 9-3.99999-9-1.82762.8122 4.00001 9 1.8276-.8122Z"></path></svg>`), IcecreamAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function IcecreamAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IcecreamAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root405();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1405();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IcecreamAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2405();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IcecreamAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IcecreamAltSolid = hmr(IcecreamAltSolid, () => IcecreamAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IcecreamAltSolid[HMR].source;
    set(IcecreamAltSolid[HMR].source, module.default[HMR].original);
  });
}
var IcecreamAltSolid_default = IcecreamAltSolid;

// node_modules/flowbite-svelte-icons/dist/IcecreamOutline.svelte
IcecreamOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IcecreamOutline.svelte";
var root_1406 = add_locations(from_svg(`<title> </title>`), IcecreamOutline[FILENAME], [[43, 4]]);
var root_2406 = add_locations(from_svg(`<desc> </desc>`), IcecreamOutline[FILENAME], [[46, 4]]);
var root406 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 8v6c0 .5523.44772 1 1 1h4M7 8c0-2.76142 2.23858-5 5-5 2.7614 0 5 2.23858 5 5v6c0 .5523-.4477 1-1 1h-4M7 8h2c1.1046 0 2 .89543 2 2v.5c0 .8284.6716 1.5 1.5 1.5s1.5-.6716 1.5-1.5c0-.82843.6716-1.5 1.5-1.5H17m-5 6v6"></path></svg>`), IcecreamOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function IcecreamOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IcecreamOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root406();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1406();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IcecreamOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2406();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IcecreamOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IcecreamOutline = hmr(IcecreamOutline, () => IcecreamOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IcecreamOutline[HMR].source;
    set(IcecreamOutline[HMR].source, module.default[HMR].original);
  });
}
var IcecreamOutline_default = IcecreamOutline;

// node_modules/flowbite-svelte-icons/dist/IcecreamSolid.svelte
IcecreamSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IcecreamSolid.svelte";
var root_1407 = add_locations(from_svg(`<title> </title>`), IcecreamSolid[FILENAME], [[41, 4]]);
var root_2407 = add_locations(from_svg(`<desc> </desc>`), IcecreamSolid[FILENAME], [[44, 4]]);
var root407 = add_locations(from_svg(`<svg><!><!><path d="M6.08296 7C6.55904 4.16229 9.027 2 12 2c3.3137 0 6 2.68629 6 6h-2.5C14.1193 8 13 9.11929 13 10.5c0 .2761-.2239.5-.5.5s-.5-.2239-.5-.5V10c0-1.65685-1.3431-3-3-3H6.08296Z"></path><path d="M6 9v5c0 1.1046.89543 2 2 2h3v5c0 .5523.4477 1 1 1s1-.4477 1-1v-5h3c1.1046 0 2-.8954 2-2v-4h-2.5c-.2761 0-.5.2239-.5.5 0 1.3807-1.1193 2.5-2.5 2.5S10 11.8807 10 10.5V10c0-.55228-.44772-1-1-1H6Z"></path></svg>`), IcecreamSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function IcecreamSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IcecreamSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root407();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1407();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IcecreamSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2407();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IcecreamSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IcecreamSolid = hmr(IcecreamSolid, () => IcecreamSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IcecreamSolid[HMR].source;
    set(IcecreamSolid[HMR].source, module.default[HMR].original);
  });
}
var IcecreamSolid_default = IcecreamSolid;

// node_modules/flowbite-svelte-icons/dist/IconOutline.svelte
IconOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IconOutline.svelte";
function IconOutline($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, IconOutline);
  let color = prop($$props, "color", 3, "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "Icon",
      "size",
      "role",
      "color",
      "ariaLabel",
      "class"
    ],
    "restProps"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => $$props.Icon, ($$anchor2, Icon_1) => {
      Icon_1($$anchor2, spread_props(
        {
          fill: "none",
          get color() {
            return color();
          }
        },
        () => restProps,
        {
          get role() {
            return $$props.role;
          },
          get size() {
            return $$props.size;
          },
          get class() {
            return $$props.class;
          },
          get ariaLabel() {
            return $$props.ariaLabel;
          }
        }
      ));
    }),
    "component",
    IconOutline,
    24,
    0,
    { componentTag: "Icon" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  IconOutline = hmr(IconOutline, () => IconOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IconOutline[HMR].source;
    set(IconOutline[HMR].source, module.default[HMR].original);
  });
}
var IconOutline_default = IconOutline;

// node_modules/flowbite-svelte-icons/dist/IconSolid.svelte
IconSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IconSolid.svelte";
function IconSolid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, IconSolid);
  let color = prop($$props, "color", 3, "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "Icon",
      "size",
      "role",
      "color",
      "ariaLabel",
      "strokeWidth",
      "class"
    ],
    "restProps"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => $$props.Icon, ($$anchor2, Icon_1) => {
      Icon_1($$anchor2, spread_props(
        {
          get fill() {
            return color();
          }
        },
        () => restProps,
        {
          get role() {
            return $$props.role;
          },
          get size() {
            return $$props.size;
          },
          get strokeWidth() {
            return $$props.strokeWidth;
          },
          get class() {
            return $$props.class;
          },
          get ariaLabel() {
            return $$props.ariaLabel;
          }
        }
      ));
    }),
    "component",
    IconSolid,
    26,
    0,
    { componentTag: "Icon" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  IconSolid = hmr(IconSolid, () => IconSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IconSolid[HMR].source;
    set(IconSolid[HMR].source, module.default[HMR].original);
  });
}
var IconSolid_default = IconSolid;

// node_modules/flowbite-svelte-icons/dist/ImageOutline.svelte
ImageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ImageOutline.svelte";
var root_1408 = add_locations(from_svg(`<title> </title>`), ImageOutline[FILENAME], [[43, 4]]);
var root_2408 = add_locations(from_svg(`<desc> </desc>`), ImageOutline[FILENAME], [[46, 4]]);
var root408 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m3 16 5-7 6 6.5m6.5 2.5L16 13l-4.286 6M14 10h.01M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), ImageOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ImageOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ImageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root408();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1408();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ImageOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2408();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ImageOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ImageOutline = hmr(ImageOutline, () => ImageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageOutline[HMR].source;
    set(ImageOutline[HMR].source, module.default[HMR].original);
  });
}
var ImageOutline_default = ImageOutline;

// node_modules/flowbite-svelte-icons/dist/ImageSolid.svelte
ImageSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ImageSolid.svelte";
var root_1409 = add_locations(from_svg(`<title> </title>`), ImageSolid[FILENAME], [[41, 4]]);
var root_2409 = add_locations(from_svg(`<desc> </desc>`), ImageSolid[FILENAME], [[44, 4]]);
var root409 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13 10a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H14a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12c0 .556-.227 1.06-.593 1.422A.999.999 0 0 1 20.5 20H4a2.002 2.002 0 0 1-2-2V6Zm6.892 12 3.833-5.356-3.99-4.322a1 1 0 0 0-1.549.097L4 12.879V6h16v9.95l-3.257-3.619a1 1 0 0 0-1.557.088L11.2 18H8.892Z" clip-rule="evenodd"></path></svg>`), ImageSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function ImageSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ImageSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root409();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1409();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ImageSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2409();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ImageSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ImageSolid = hmr(ImageSolid, () => ImageSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageSolid[HMR].source;
    set(ImageSolid[HMR].source, module.default[HMR].original);
  });
}
var ImageSolid_default = ImageSolid;

// node_modules/flowbite-svelte-icons/dist/InboxFullOutline.svelte
InboxFullOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxFullOutline.svelte";
var root_1410 = add_locations(from_svg(`<title> </title>`), InboxFullOutline[FILENAME], [[43, 4]]);
var root_2410 = add_locations(from_svg(`<desc> </desc>`), InboxFullOutline[FILENAME], [[46, 4]]);
var root410 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 13h3.439a.991.991 0 0 1 .908.6 3.978 3.978 0 0 0 7.306 0 .99.99 0 0 1 .908-.6H20M4 13v6a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-6M4 13l2-9h12l2 9M9 7h6m-7 3h8"></path></svg>`), InboxFullOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InboxFullOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InboxFullOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root410();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1410();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InboxFullOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2410();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InboxFullOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InboxFullOutline = hmr(InboxFullOutline, () => InboxFullOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxFullOutline[HMR].source;
    set(InboxFullOutline[HMR].source, module.default[HMR].original);
  });
}
var InboxFullOutline_default = InboxFullOutline;

// node_modules/flowbite-svelte-icons/dist/InboxFullSolid.svelte
InboxFullSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxFullSolid.svelte";
var root_1411 = add_locations(from_svg(`<title> </title>`), InboxFullSolid[FILENAME], [[41, 4]]);
var root_2411 = add_locations(from_svg(`<desc> </desc>`), InboxFullSolid[FILENAME], [[44, 4]]);
var root411 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Zm5-7a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm0 2a1 1 0 0 0 0 2h8a1 1 0 1 0 0-2H8Z" clip-rule="evenodd"></path></svg>`), InboxFullSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function InboxFullSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InboxFullSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root411();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1411();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InboxFullSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2411();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InboxFullSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InboxFullSolid = hmr(InboxFullSolid, () => InboxFullSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxFullSolid[HMR].source;
    set(InboxFullSolid[HMR].source, module.default[HMR].original);
  });
}
var InboxFullSolid_default = InboxFullSolid;

// node_modules/flowbite-svelte-icons/dist/InboxOutline.svelte
InboxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxOutline.svelte";
var root_1412 = add_locations(from_svg(`<title> </title>`), InboxOutline[FILENAME], [[43, 4]]);
var root_2412 = add_locations(from_svg(`<desc> </desc>`), InboxOutline[FILENAME], [[46, 4]]);
var root412 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 13h3.439a.991.991 0 0 1 .908.6 3.978 3.978 0 0 0 7.306 0 .99.99 0 0 1 .908-.6H20M4 13v6a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-6M4 13l2-9h12l2 9"></path></svg>`), InboxOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InboxOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InboxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root412();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1412();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InboxOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2412();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InboxOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InboxOutline = hmr(InboxOutline, () => InboxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxOutline[HMR].source;
    set(InboxOutline[HMR].source, module.default[HMR].original);
  });
}
var InboxOutline_default = InboxOutline;

// node_modules/flowbite-svelte-icons/dist/InboxSolid.svelte
InboxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxSolid.svelte";
var root_1413 = add_locations(from_svg(`<title> </title>`), InboxSolid[FILENAME], [[41, 4]]);
var root_2413 = add_locations(from_svg(`<desc> </desc>`), InboxSolid[FILENAME], [[44, 4]]);
var root413 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Z" clip-rule="evenodd"></path></svg>`), InboxSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function InboxSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InboxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root413();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1413();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InboxSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2413();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InboxSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InboxSolid = hmr(InboxSolid, () => InboxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxSolid[HMR].source;
    set(InboxSolid[HMR].source, module.default[HMR].original);
  });
}
var InboxSolid_default = InboxSolid;

// node_modules/flowbite-svelte-icons/dist/IncomingCallOutline.svelte
IncomingCallOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IncomingCallOutline.svelte";
var root_1414 = add_locations(from_svg(`<title> </title>`), IncomingCallOutline[FILENAME], [[43, 4]]);
var root_2414 = add_locations(from_svg(`<desc> </desc>`), IncomingCallOutline[FILENAME], [[46, 4]]);
var root414 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19.0225 4 14 8.98132m0 0 3.03.00002M14 8.98132V5.99998m4.2327 8.51492-1.1431-1.1439c-1.143-1.1439-1.9758-.3696-2.8382.4565-.3159.3161-.7443.4936-1.1911.4936-.4467 0-.8751-.1775-1.191-.4936L9.998 11.9549c-.65643-.6564-.92477-1.4591 0-2.38383.8488-.86837 1.6837-1.61177.4926-2.8037L9.2995 5.57544c-.90492-.90556-1.99137-.383-2.61843.23625-3.13257 3.1118-1.72021 6.77001 1.41066 9.90141s6.78747 4.5465 9.90477 1.4254c.1744-.1461.551-.565.6473-.7712.0962-.2062.1461-.4311.1461-.6587 0-.2277-.0499-.4525-.1461-.6588-.0963-.2062-.2366-.3888-.4111-.5349Z"></path></svg>`), IncomingCallOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function IncomingCallOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IncomingCallOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root414();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1414();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IncomingCallOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2414();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IncomingCallOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IncomingCallOutline = hmr(IncomingCallOutline, () => IncomingCallOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IncomingCallOutline[HMR].source;
    set(IncomingCallOutline[HMR].source, module.default[HMR].original);
  });
}
var IncomingCallOutline_default = IncomingCallOutline;

// node_modules/flowbite-svelte-icons/dist/IncomingCallSolid.svelte
IncomingCallSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IncomingCallSolid.svelte";
var root_1415 = add_locations(from_svg(`<title> </title>`), IncomingCallSolid[FILENAME], [[41, 4]]);
var root_2415 = add_locations(from_svg(`<desc> </desc>`), IncomingCallSolid[FILENAME], [[44, 4]]);
var root415 = add_locations(from_svg(`<svg><!><!><path d="M6.97825 3.99999c-.3729 0-.74128.08169-1.07926.23934-.32394.15109-.61243.36845-.84696.63786-1.81892 1.82189-2.35302 3.87423-1.89899 5.93671.43916 1.9949 1.77747 3.8929 3.45642 5.572 1.67897 1.6791 3.57614 3.0176 5.57034 3.4591 2.0612.4563 4.1141-.0726 5.9396-1.8853.2705-.2348.4888-.524.6405-.8489.1581-.3387.2401-.7081.2401-1.0819 0-.3739-.082-.7432-.2401-1.0819-.1516-.3247-.3696-.6137-.6398-.8483l-1.2098-1.2106c-.5043-.5041-1.1879-.7872-1.9007-.7872-.7128 0-1.3968.2835-1.9011.7876l-.6178.6181c-.1512.1513-.3563.2363-.5701.2363-.2138 0-.4189-.085-.5701-.2363l-1.85336-1.8545c-.15117-.1513-.23609-.3565-.23609-.5704 0-.214.08493-.4192.23613-.5705l.61812-.61851c.5037-.50461.7867-1.18868.7867-1.90191s-.2833-1.39767-.7871-1.90228L8.90499 4.8778c-.23462-.26969-.5233-.48727-.84749-.63847-.33798-.15765-.70636-.23934-1.07925-.23934Z"></path><path fill-rule="evenodd" d="M18.0299 8.98132c0 .55229-.4477 1-1 .99999l-3.03-.00002c-.5522 0-1-.44772-1-1V5.99995c0-.55229.4478-1 1-1 .5523 0 1 .44771 1 1v.58112l3.3184-3.29111c.3921-.38892 1.0253-.38631 1.4142.00582.3889.39213.3863 1.02529-.0058 1.4142l-3.2984 3.27133h.6016c.5523.00001 1 .44773 1 1.00001Z" clip-rule="evenodd"></path></svg>`), IncomingCallSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function IncomingCallSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IncomingCallSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root415();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1415();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IncomingCallSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2415();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IncomingCallSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IncomingCallSolid = hmr(IncomingCallSolid, () => IncomingCallSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IncomingCallSolid[HMR].source;
    set(IncomingCallSolid[HMR].source, module.default[HMR].original);
  });
}
var IncomingCallSolid_default = IncomingCallSolid;

// node_modules/flowbite-svelte-icons/dist/IndentOutline.svelte
IndentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IndentOutline.svelte";
var root_1416 = add_locations(from_svg(`<title> </title>`), IndentOutline[FILENAME], [[43, 4]]);
var root_2416 = add_locations(from_svg(`<desc> </desc>`), IndentOutline[FILENAME], [[46, 4]]);
var root416 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h12M6 18h12m-5-8h5m-5 4h5M6 9v6l3.5-3L6 9Z"></path></svg>`), IndentOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function IndentOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IndentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root416();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1416();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IndentOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2416();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IndentOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IndentOutline = hmr(IndentOutline, () => IndentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IndentOutline[HMR].source;
    set(IndentOutline[HMR].source, module.default[HMR].original);
  });
}
var IndentOutline_default = IndentOutline;

// node_modules/flowbite-svelte-icons/dist/IndentSolid.svelte
IndentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IndentSolid.svelte";
var root_1417 = add_locations(from_svg(`<title> </title>`), IndentSolid[FILENAME], [[41, 4]]);
var root_2417 = add_locations(from_svg(`<desc> </desc>`), IndentSolid[FILENAME], [[44, 4]]);
var root417 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 6a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm0 12a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm1.65-9.76A1 1 0 0 0 5 9v6a1 1 0 0 0 1.65.76l3.5-3a1 1 0 0 0 0-1.52l-3.5-3ZM12 10a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Zm0 4a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), IndentSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function IndentSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, IndentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root417();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1417();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      IndentSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2417();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      IndentSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  IndentSolid = hmr(IndentSolid, () => IndentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IndentSolid[HMR].source;
    set(IndentSolid[HMR].source, module.default[HMR].original);
  });
}
var IndentSolid_default = IndentSolid;

// node_modules/flowbite-svelte-icons/dist/InfoCircleOutline.svelte
InfoCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InfoCircleOutline.svelte";
var root_1418 = add_locations(from_svg(`<title> </title>`), InfoCircleOutline[FILENAME], [[43, 4]]);
var root_2418 = add_locations(from_svg(`<desc> </desc>`), InfoCircleOutline[FILENAME], [[46, 4]]);
var root418 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 11h2v5m-2 0h4m-2.592-8.5h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), InfoCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InfoCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InfoCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root418();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1418();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InfoCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2418();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InfoCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InfoCircleOutline = hmr(InfoCircleOutline, () => InfoCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InfoCircleOutline[HMR].source;
    set(InfoCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var InfoCircleOutline_default = InfoCircleOutline;

// node_modules/flowbite-svelte-icons/dist/InfoCircleSolid.svelte
InfoCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InfoCircleSolid.svelte";
var root_1419 = add_locations(from_svg(`<title> </title>`), InfoCircleSolid[FILENAME], [[41, 4]]);
var root_2419 = add_locations(from_svg(`<desc> </desc>`), InfoCircleSolid[FILENAME], [[44, 4]]);
var root419 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.408-5.5a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM10 10a1 1 0 1 0 0 2h1v3h-1a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-1v-4a1 1 0 0 0-1-1h-2Z" clip-rule="evenodd"></path></svg>`), InfoCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function InfoCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InfoCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root419();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1419();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InfoCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2419();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InfoCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InfoCircleSolid = hmr(InfoCircleSolid, () => InfoCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InfoCircleSolid[HMR].source;
    set(InfoCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var InfoCircleSolid_default = InfoCircleSolid;

// node_modules/flowbite-svelte-icons/dist/InsertRowAfterOutline.svelte
InsertRowAfterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertRowAfterOutline.svelte";
var root_1420 = add_locations(from_svg(`<title> </title>`), InsertRowAfterOutline[FILENAME], [[43, 4]]);
var root_2420 = add_locations(from_svg(`<desc> </desc>`), InsertRowAfterOutline[FILENAME], [[46, 4]]);
var root420 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 9V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44771 1 1v3M3 9v9c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1V9M3 9h18M8 9V5m4 4V5m4 4V5m-6 9h2m0 0h2m-2 0v-2m0 2v2"></path></svg>`), InsertRowAfterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InsertRowAfterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InsertRowAfterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root420();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1420();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InsertRowAfterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2420();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InsertRowAfterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InsertRowAfterOutline = hmr(InsertRowAfterOutline, () => InsertRowAfterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertRowAfterOutline[HMR].source;
    set(InsertRowAfterOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertRowAfterOutline_default = InsertRowAfterOutline;

// node_modules/flowbite-svelte-icons/dist/InsertRowBeforeOutline.svelte
InsertRowBeforeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertRowBeforeOutline.svelte";
var root_1421 = add_locations(from_svg(`<title> </title>`), InsertRowBeforeOutline[FILENAME], [[43, 4]]);
var root_2421 = add_locations(from_svg(`<desc> </desc>`), InsertRowBeforeOutline[FILENAME], [[46, 4]]);
var root421 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-6-9h2m0 0h2m-2 0v2m0-2V8"></path></svg>`), InsertRowBeforeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InsertRowBeforeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InsertRowBeforeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root421();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1421();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InsertRowBeforeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2421();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InsertRowBeforeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InsertRowBeforeOutline = hmr(InsertRowBeforeOutline, () => InsertRowBeforeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertRowBeforeOutline[HMR].source;
    set(InsertRowBeforeOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertRowBeforeOutline_default = InsertRowBeforeOutline;

// node_modules/flowbite-svelte-icons/dist/InsertTableAltOutline.svelte
InsertTableAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertTableAltOutline.svelte";
var root_1422 = add_locations(from_svg(`<title> </title>`), InsertTableAltOutline[FILENAME], [[43, 4]]);
var root_2422 = add_locations(from_svg(`<desc> </desc>`), InsertTableAltOutline[FILENAME], [[46, 4]]);
var root422 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10.5M3 15v-4m0 4h11M3 11V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5M3 11h18m0 0v1M8 11v8m4-8v8m4-8v2m1 4h2m0 0h2m-2 0v2m0-2v-2"></path></svg>`), InsertTableAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InsertTableAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InsertTableAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root422();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1422();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InsertTableAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2422();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InsertTableAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InsertTableAltOutline = hmr(InsertTableAltOutline, () => InsertTableAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertTableAltOutline[HMR].source;
    set(InsertTableAltOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertTableAltOutline_default = InsertTableAltOutline;

// node_modules/flowbite-svelte-icons/dist/InsertTableOutline.svelte
InsertTableOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertTableOutline.svelte";
var root_1423 = add_locations(from_svg(`<title> </title>`), InsertTableOutline[FILENAME], [[43, 4]]);
var root_2423 = add_locations(from_svg(`<desc> </desc>`), InsertTableOutline[FILENAME], [[46, 4]]);
var root423 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M3 11h18M3 15h18M8 10.792V19m4-8.208V19m4-8.208V19M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), InsertTableOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function InsertTableOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InsertTableOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root423();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1423();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InsertTableOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2423();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InsertTableOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InsertTableOutline = hmr(InsertTableOutline, () => InsertTableOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertTableOutline[HMR].source;
    set(InsertTableOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertTableOutline_default = InsertTableOutline;

// node_modules/flowbite-svelte-icons/dist/InstagramSolid.svelte
InstagramSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InstagramSolid.svelte";
var root_1424 = add_locations(from_svg(`<title> </title>`), InstagramSolid[FILENAME], [[41, 4]]);
var root_2424 = add_locations(from_svg(`<desc> </desc>`), InstagramSolid[FILENAME], [[44, 4]]);
var root424 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 8a5 5 0 0 1 5-5h8a5 5 0 0 1 5 5v8a5 5 0 0 1-5 5H8a5 5 0 0 1-5-5V8Zm5-3a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3H8Zm7.597 2.214a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2h-.01a1 1 0 0 1-1-1ZM12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6Zm-5 3a5 5 0 1 1 10 0 5 5 0 0 1-10 0Z" clip-rule="evenodd"></path></svg>`), InstagramSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function InstagramSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, InstagramSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root424();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1424();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      InstagramSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2424();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      InstagramSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  InstagramSolid = hmr(InstagramSolid, () => InstagramSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstagramSolid[HMR].source;
    set(InstagramSolid[HMR].source, module.default[HMR].original);
  });
}
var InstagramSolid_default = InstagramSolid;

// node_modules/flowbite-svelte-icons/dist/JarOutline.svelte
JarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/JarOutline.svelte";
var root_1425 = add_locations(from_svg(`<title> </title>`), JarOutline[FILENAME], [[43, 4]]);
var root_2425 = add_locations(from_svg(`<desc> </desc>`), JarOutline[FILENAME], [[46, 4]]);
var root425 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 6H8m8 0s3 2.5 3 5m-3-5V3H8v3m0 0s-3 2.5-3 5v8.002C5 20.6589 6.34315 22 8 22h8c1.6569 0 3-1.3411 3-2.998V11m0 0h-8v7h8v-7ZM6 6h12"></path></svg>`), JarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function JarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, JarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root425();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1425();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      JarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2425();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      JarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  JarOutline = hmr(JarOutline, () => JarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = JarOutline[HMR].source;
    set(JarOutline[HMR].source, module.default[HMR].original);
  });
}
var JarOutline_default = JarOutline;

// node_modules/flowbite-svelte-icons/dist/JarSolid.svelte
JarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/JarSolid.svelte";
var root_1426 = add_locations(from_svg(`<title> </title>`), JarSolid[FILENAME], [[41, 4]]);
var root_2426 = add_locations(from_svg(`<desc> </desc>`), JarSolid[FILENAME], [[44, 4]]);
var root426 = add_locations(from_svg(`<svg><!><!><path d="M7 3c0-.55228.44772-1 1-1h8c.5523 0 1 .44772 1 1v2h1c.5523 0 1 .44772 1 1 0 .44954-.2966.8298-.7048.95572.6113.76712 1.3165 1.84205 1.589 3.04428H11c-.5523 0-1 .4477-1 1v7c0 .5523.4477 1 1 1h9v.002C20 21.2121 18.2083 23 16 23H8c-2.20825 0-4-1.7879-4-3.998V11c0-1.59816.92812-3.06965 1.70483-4.04428C5.29662 6.82979 5 6.44954 5 6c0-.55228.44772-1 1-1h1V3Z"></path><path d="M20 17v-5h-8v5h8Z"></path></svg>`), JarSolid[FILENAME], [[30, 0, [[46, 2], [48, 5]]]]);
function JarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, JarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root426();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1426();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      JarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2426();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      JarSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  JarSolid = hmr(JarSolid, () => JarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = JarSolid[HMR].source;
    set(JarSolid[HMR].source, module.default[HMR].original);
  });
}
var JarSolid_default = JarSolid;

// node_modules/flowbite-svelte-icons/dist/JarWheatOutline.svelte
JarWheatOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/JarWheatOutline.svelte";
var root_1427 = add_locations(from_svg(`<title> </title>`), JarWheatOutline[FILENAME], [[43, 4]]);
var root_2427 = add_locations(from_svg(`<desc> </desc>`), JarWheatOutline[FILENAME], [[46, 4]]);
var root427 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 6H8m8 0s3 2.5 3 5v8.002C19 20.6589 17.6569 22 16 22H8c-1.65685 0-3-1.3411-3-2.998V11c0-2.5 3-5 3-5m8 0V3H8v3m4 3v10M6 6h12m-4.8345 9.7454c-.323.2567-.9647 1.1716-.9257 1.2279.039.0563 1.0454-.4292 1.4008-.6387.3554-.2095.9274-1.1943.9-1.2298-.0275-.0356-1.0771.4039-1.3751.6406Zm0-3.972c-.323.2567-.9647 1.1716-.9257 1.228.039.0563 1.0454-.4292 1.4008-.6387.3554-.2096.9274-1.1943.9-1.2299-.0275-.0355-1.0771.404-1.3751.6406Zm-2.331 3.972c.323.2567.9647 1.1716.9257 1.2279-.0391.0563-1.0455-.4292-1.4009-.6387-.3553-.2095-.92738-1.1943-.8999-1.2298.02748-.0356 1.0771.4039 1.3751.6406Zm0-3.972c.323.2567.9647 1.1716.9257 1.228-.0391.0563-1.0455-.4292-1.4009-.6387-.3553-.2096-.92738-1.1943-.8999-1.2299.02748-.0355 1.0771.404 1.3751.6406Z"></path></svg>`), JarWheatOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function JarWheatOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, JarWheatOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root427();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1427();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      JarWheatOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2427();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      JarWheatOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  JarWheatOutline = hmr(JarWheatOutline, () => JarWheatOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = JarWheatOutline[HMR].source;
    set(JarWheatOutline[HMR].source, module.default[HMR].original);
  });
}
var JarWheatOutline_default = JarWheatOutline;

// node_modules/flowbite-svelte-icons/dist/JarWheatSolid.svelte
JarWheatSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/JarWheatSolid.svelte";
var root_1428 = add_locations(from_svg(`<title> </title>`), JarWheatSolid[FILENAME], [[41, 4]]);
var root_2428 = add_locations(from_svg(`<desc> </desc>`), JarWheatSolid[FILENAME], [[44, 4]]);
var root428 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 2c-.55228 0-1 .44772-1 1v2H6c-.55228 0-1 .44772-1 1 0 .44954.29662.82979.70483.95572C4.92812 7.93035 4 9.40184 4 11v8.002C4 21.2121 5.79175 23 8 23h8c2.2083 0 4-1.7879 4-3.998V11c0-1.59816-.9281-3.06965-1.7048-4.04428C18.7034 6.8298 19 6.44954 19 6c0-.55228-.4477-1-1-1h-1V3c0-.55228-.4477-1-1-1H8Zm5 7c0-.55228-.4477-1-1-1-.5522 0-1 .44772-1 1v1.703c-.194-.104-.3946-.1973-.5475-.2654-.1648-.0734-.3276-.1409-.45886-.1898-.06227-.0233-.13576-.0493-.20586-.0692-.02974-.0085-.09377-.0261-.17034-.037-.03336-.0048-.11836-.0159-.22524-.0081-.05401.004-.15081.0151-.26455.0554-.111.0393-.30275.1296-.45957.3326-.14595.1889-.18661.3793-.20009.477-.01449.1049-.0093.1904-.00456.2385.00943.0956.03059.1697.03992.2007.02096.0699.04596.1276.05898.1568.02991.0671.06629.1367.09992.1979.07011.1275.16492.2844.27078.4437.10518.1582.23212.3352.36751.4957.11722.139.30928.3498.55094.4923.21752.1282.59062.3174.90382.4637.0816.0381.1647.0759.2447.1108v.8763c-.194-.104-.3946-.1973-.5475-.2654-.1648-.0734-.3276-.1408-.45886-.1898-.06227-.0233-.13576-.0493-.20586-.0692-.02974-.0085-.09377-.0261-.17034-.037-.03336-.0047-.11836-.0159-.22524-.0081-.05401.004-.15081.0151-.26455.0554-.111.0393-.30275.1296-.45957.3326-.14595.189-.18661.3793-.20009.477-.01449.105-.0093.1904-.00456.2386.00943.0955.03059.1696.03992.2006.02096.0699.04596.1276.05898.1568.02991.0671.06629.1368.09992.1979.07011.1275.16492.2844.27078.4437.10518.1582.23212.3352.36751.4957.11722.139.30928.3498.55094.4923.21752.1282.59062.3174.90382.4637.0816.0381.1647.0759.2447.1109V19c0 .5523.4478 1 1 1 .5523 0 1-.4477 1-1v-1.2295c.0801-.0349.1632-.0727.2447-.1108.3132-.1463.6864-.3355.9039-.4637.2416-.1425.4337-.3533.5509-.4923.1354-.1605.2623-.3375.3675-.4957.1059-.1593.2007-.3162.2708-.4437.0336-.0611.07-.1308.0999-.1979.013-.0292.038-.0869.059-.1568.0093-.031.0305-.1051.0399-.2006.0048-.0482.0099-.1336-.0045-.2386-.0135-.0977-.0542-.288-.2001-.477-.1569-.203-.3486-.2933-.4596-.3326-.1137-.0403-.2105-.0514-.2645-.0554-.1069-.0078-.1919.0034-.2253.0081-.0766.0109-.1406.0285-.1703.037-.0701.0199-.1436.0459-.2059.0692-.1312.049-.294.1164-.4588.1898-.1529.0681-.3536.1614-.5476.2654v-.8763c.0801-.0349.1632-.0727.2447-.1108.3132-.1463.6864-.3355.9039-.4637.2416-.1425.4337-.3533.5509-.4923.1354-.1605.2623-.3375.3675-.4957.1059-.1593.2007-.3162.2708-.4437.0336-.0612.07-.1308.0999-.1979.013-.0292.038-.0869.059-.1568.0093-.031.0305-.1051.0399-.2007.0048-.0481.0099-.1336-.0045-.2385-.0135-.0977-.0542-.2881-.2001-.477-.1569-.203-.3486-.2933-.4596-.3326-.1137-.0403-.2105-.0514-.2645-.0554-.1069-.0078-.1919.0033-.2253.0081-.0766.0109-.1406.0285-.1703.037-.0701.0199-.1436.0459-.2059.0692-.1312.0489-.294.1164-.4588.1898-.1529.0681-.3536.1613-.5476.2654V9Z" clip-rule="evenodd"></path></svg>`), JarWheatSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function JarWheatSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, JarWheatSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root428();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1428();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      JarWheatSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2428();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      JarWheatSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  JarWheatSolid = hmr(JarWheatSolid, () => JarWheatSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = JarWheatSolid[HMR].source;
    set(JarWheatSolid[HMR].source, module.default[HMR].original);
  });
}
var JarWheatSolid_default = JarWheatSolid;

// node_modules/flowbite-svelte-icons/dist/KeyboardOutline.svelte
KeyboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/KeyboardOutline.svelte";
var root_1429 = add_locations(from_svg(`<title> </title>`), KeyboardOutline[FILENAME], [[43, 4]]);
var root_2429 = add_locations(from_svg(`<desc> </desc>`), KeyboardOutline[FILENAME], [[46, 4]]);
var root429 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" d="M8 15h7.01v.01H15L8 15Z"></path><path stroke="currentColor" stroke-linecap="square" d="M20 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Z"></path><path stroke="currentColor" stroke-linecap="square" d="M6 9h.01v.01H6V9Zm0 3h.01v.01H6V12Zm0 3h.01v.01H6V15Zm3-6h.01v.01H9V9Zm0 3h.01v.01H9V12Zm3-3h.01v.01H12V9Zm0 3h.01v.01H12V12Zm3 0h.01v.01H15V12Zm3 0h.01v.01H18V12Zm0 3h.01v.01H18V15Zm-3-6h.01v.01H15V9Zm3 0h.01v.01H18V9Z"></path></svg>`), KeyboardOutline[FILENAME], [[31, 0, [[48, 2], [54, 2], [60, 2]]]]);
function KeyboardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, KeyboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root429();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1429();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      KeyboardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2429();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      KeyboardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  var path_2 = sibling(path_1);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
    set_attribute(path_2, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  KeyboardOutline = hmr(KeyboardOutline, () => KeyboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = KeyboardOutline[HMR].source;
    set(KeyboardOutline[HMR].source, module.default[HMR].original);
  });
}
var KeyboardOutline_default = KeyboardOutline;

// node_modules/flowbite-svelte-icons/dist/KeyboardSolid.svelte
KeyboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/KeyboardSolid.svelte";
var root_1430 = add_locations(from_svg(`<title> </title>`), KeyboardSolid[FILENAME], [[41, 4]]);
var root_2430 = add_locations(from_svg(`<desc> </desc>`), KeyboardSolid[FILENAME], [[44, 4]]);
var root430 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7Zm5.01 1H5v2.01h2.01V8Zm3 0H8v2.01h2.01V8Zm3 0H11v2.01h2.01V8Zm3 0H14v2.01h2.01V8Zm3 0H17v2.01h2.01V8Zm-12 3H5v2.01h2.01V11Zm3 0H8v2.01h2.01V11Zm3 0H11v2.01h2.01V11Zm3 0H14v2.01h2.01V11Zm3 0H17v2.01h2.01V11Zm-12 3H5v2.01h2.01V14ZM8 14l-.001 2 8.011.01V14H8Zm11.01 0H17v2.01h2.01V14Z" clip-rule="evenodd"></path></svg>`), KeyboardSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function KeyboardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, KeyboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root430();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1430();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      KeyboardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2430();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      KeyboardSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  KeyboardSolid = hmr(KeyboardSolid, () => KeyboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = KeyboardSolid[HMR].source;
    set(KeyboardSolid[HMR].source, module.default[HMR].original);
  });
}
var KeyboardSolid_default = KeyboardSolid;

// node_modules/flowbite-svelte-icons/dist/LabelOutline.svelte
LabelOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LabelOutline.svelte";
var root_1431 = add_locations(from_svg(`<title> </title>`), LabelOutline[FILENAME], [[43, 4]]);
var root_2431 = add_locations(from_svg(`<desc> </desc>`), LabelOutline[FILENAME], [[46, 4]]);
var root431 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.2 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11.2a1 1 0 0 0 .747-.334l4.46-5a1 1 0 0 0 0-1.332l-4.46-5A1 1 0 0 0 15.2 6Z"></path></svg>`), LabelOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LabelOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LabelOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root431();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1431();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LabelOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2431();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LabelOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LabelOutline = hmr(LabelOutline, () => LabelOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LabelOutline[HMR].source;
    set(LabelOutline[HMR].source, module.default[HMR].original);
  });
}
var LabelOutline_default = LabelOutline;

// node_modules/flowbite-svelte-icons/dist/LabelSolid.svelte
LabelSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LabelSolid.svelte";
var root_1432 = add_locations(from_svg(`<title> </title>`), LabelSolid[FILENAME], [[41, 4]]);
var root_2432 = add_locations(from_svg(`<desc> </desc>`), LabelSolid[FILENAME], [[44, 4]]);
var root432 = add_locations(from_svg(`<svg><!><!><path d="M4 6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11.613a2 2 0 0 0 1.346-.52l4.4-4a2 2 0 0 0 0-2.96l-4.4-4A2 2 0 0 0 15.613 6H4Z"></path></svg>`), LabelSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LabelSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LabelSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root432();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1432();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LabelSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2432();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LabelSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LabelSolid = hmr(LabelSolid, () => LabelSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LabelSolid[HMR].source;
    set(LabelSolid[HMR].source, module.default[HMR].original);
  });
}
var LabelSolid_default = LabelSolid;

// node_modules/flowbite-svelte-icons/dist/LandmarkOutline.svelte
LandmarkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LandmarkOutline.svelte";
var root_1433 = add_locations(from_svg(`<title> </title>`), LandmarkOutline[FILENAME], [[43, 4]]);
var root_2433 = add_locations(from_svg(`<desc> </desc>`), LandmarkOutline[FILENAME], [[46, 4]]);
var root433 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M3 21h18M4 18h16M6 10v8m4-8v8m4-8v8m4-8v8M4 9.5v-.955a1 1 0 0 1 .458-.84l7-4.52a1 1 0 0 1 1.084 0l7 4.52a1 1 0 0 1 .458.84V9.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5Z"></path></svg>`), LandmarkOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LandmarkOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LandmarkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root433();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1433();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LandmarkOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2433();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LandmarkOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LandmarkOutline = hmr(LandmarkOutline, () => LandmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LandmarkOutline[HMR].source;
    set(LandmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var LandmarkOutline_default = LandmarkOutline;

// node_modules/flowbite-svelte-icons/dist/LandmarkSolid.svelte
LandmarkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LandmarkSolid.svelte";
var root_1434 = add_locations(from_svg(`<title> </title>`), LandmarkSolid[FILENAME], [[41, 4]]);
var root_2434 = add_locations(from_svg(`<desc> </desc>`), LandmarkSolid[FILENAME], [[44, 4]]);
var root434 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10.915 2.345a2 2 0 0 1 2.17 0l7 4.52A2 2 0 0 1 21 8.544V9.5a1.5 1.5 0 0 1-1.5 1.5H19v6h1a1 1 0 1 1 0 2H4a1 1 0 1 1 0-2h1v-6h-.5A1.5 1.5 0 0 1 3 9.5v-.955a2 2 0 0 1 .915-1.68l7-4.52ZM17 17v-6h-2v6h2Zm-6-6h2v6h-2v-6Zm-2 6v-6H7v6h2Z" clip-rule="evenodd"></path><path d="M2 21a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Z"></path></svg>`), LandmarkSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function LandmarkSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LandmarkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root434();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1434();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LandmarkSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2434();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LandmarkSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LandmarkSolid = hmr(LandmarkSolid, () => LandmarkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LandmarkSolid[HMR].source;
    set(LandmarkSolid[HMR].source, module.default[HMR].original);
  });
}
var LandmarkSolid_default = LandmarkSolid;

// node_modules/flowbite-svelte-icons/dist/LanguageOutline.svelte
LanguageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LanguageOutline.svelte";
var root_1435 = add_locations(from_svg(`<title> </title>`), LanguageOutline[FILENAME], [[43, 4]]);
var root_2435 = add_locations(from_svg(`<desc> </desc>`), LanguageOutline[FILENAME], [[46, 4]]);
var root435 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m13 19 3.5-9 3.5 9m-6.125-2h5.25M3 7h7m0 0h2m-2 0c0 1.63-.793 3.926-2.239 5.655M7.5 6.818V5m.261 7.655C6.79 13.82 5.521 14.725 4 15m3.761-2.345L5 10m2.761 2.655L10.2 15"></path></svg>`), LanguageOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LanguageOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LanguageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root435();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1435();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LanguageOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2435();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LanguageOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LanguageOutline = hmr(LanguageOutline, () => LanguageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LanguageOutline[HMR].source;
    set(LanguageOutline[HMR].source, module.default[HMR].original);
  });
}
var LanguageOutline_default = LanguageOutline;

// node_modules/flowbite-svelte-icons/dist/LaptopCodeOutline.svelte
LaptopCodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaptopCodeOutline.svelte";
var root_1436 = add_locations(from_svg(`<title> </title>`), LaptopCodeOutline[FILENAME], [[43, 4]]);
var root_2436 = add_locations(from_svg(`<desc> </desc>`), LaptopCodeOutline[FILENAME], [[46, 4]]);
var root436 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.35709 16V5.78571c0-.43393.34822-.78571.77777-.78571H18.5793c.4296 0 .7778.35178.7778.78571V16M5.35709 16h-1c-.55229 0-1 .4477-1 1v1c0 .5523.44771 1 1 1H20.3571c.5523 0 1-.4477 1-1v-1c0-.5523-.4477-1-1-1h-1M5.35709 16H19.3571M9.35709 8l2.62501 2.5L9.35709 13m4.00001 0h2"></path></svg>`), LaptopCodeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LaptopCodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LaptopCodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root436();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1436();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LaptopCodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2436();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LaptopCodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LaptopCodeOutline = hmr(LaptopCodeOutline, () => LaptopCodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaptopCodeOutline[HMR].source;
    set(LaptopCodeOutline[HMR].source, module.default[HMR].original);
  });
}
var LaptopCodeOutline_default = LaptopCodeOutline;

// node_modules/flowbite-svelte-icons/dist/LaptopCodeSolid.svelte
LaptopCodeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaptopCodeSolid.svelte";
var root_1437 = add_locations(from_svg(`<title> </title>`), LaptopCodeSolid[FILENAME], [[41, 4]]);
var root_2437 = add_locations(from_svg(`<desc> </desc>`), LaptopCodeSolid[FILENAME], [[44, 4]]);
var root437 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 5.78571C4 4.80909 4.78639 4 5.77778 4H18.2222C19.2136 4 20 4.80909 20 5.78571V15H4V5.78571ZM12 12c0-.5523.4477-1 1-1h2c.5523 0 1 .4477 1 1s-.4477 1-1 1h-2c-.5523 0-1-.4477-1-1ZM8.27586 6.31035c.38089-.39993 1.01387-.41537 1.4138-.03449l2.62504 2.5c.1981.18875.3103.45047.3103.72414 0 .27368-.1122.5354-.3103.7241l-2.62504 2.5c-.39993.3809-1.03291.3655-1.4138-.0344-.38088-.4-.36544-1.033.03449-1.4138L10.175 9.5 8.31035 7.72414c-.39993-.38089-.41537-1.01386-.03449-1.41379Z" clip-rule="evenodd"></path><path d="M2 17v1c0 1.1046.89543 2 2 2h16c1.1046 0 2-.8954 2-2v-1H2Z"></path></svg>`), LaptopCodeSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function LaptopCodeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LaptopCodeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root437();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1437();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LaptopCodeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2437();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LaptopCodeSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LaptopCodeSolid = hmr(LaptopCodeSolid, () => LaptopCodeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaptopCodeSolid[HMR].source;
    set(LaptopCodeSolid[HMR].source, module.default[HMR].original);
  });
}
var LaptopCodeSolid_default = LaptopCodeSolid;

// node_modules/flowbite-svelte-icons/dist/LaptopFileOutline.svelte
LaptopFileOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaptopFileOutline.svelte";
var root_1438 = add_locations(from_svg(`<title> </title>`), LaptopFileOutline[FILENAME], [[43, 4]]);
var root_2438 = add_locations(from_svg(`<desc> </desc>`), LaptopFileOutline[FILENAME], [[46, 4]]);
var root438 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19.2857 7V5.78571c0-.43393-.3482-.78571-.7778-.78571H6.06345c-.42955 0-.77777.35178-.77777.78571V16m0 0h-1c-.55229 0-1 .4477-1 1v1c0 .5523.44771 1 1 1h5m-4-3h4m7.00002-6v3c0 .5523-.4477 1-1 1h-3m8-3v8c0 .5523-.4477 1-1 1h-6c-.5523 0-1-.4477-1-1v-5.397c0-.2536.0963-.4977.2696-.683l2.434-2.603c.189-.2022.4535-.317.7304-.317h3.566c.5523 0 1 .4477 1 1Z"></path></svg>`), LaptopFileOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LaptopFileOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LaptopFileOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root438();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1438();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LaptopFileOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2438();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LaptopFileOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LaptopFileOutline = hmr(LaptopFileOutline, () => LaptopFileOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaptopFileOutline[HMR].source;
    set(LaptopFileOutline[HMR].source, module.default[HMR].original);
  });
}
var LaptopFileOutline_default = LaptopFileOutline;

// node_modules/flowbite-svelte-icons/dist/LaptopFileSolid.svelte
LaptopFileSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaptopFileSolid.svelte";
var root_1439 = add_locations(from_svg(`<title> </title>`), LaptopFileSolid[FILENAME], [[41, 4]]);
var root_2439 = add_locations(from_svg(`<desc> </desc>`), LaptopFileSolid[FILENAME], [[44, 4]]);
var root439 = add_locations(from_svg(`<svg><!><!><path d="M4 5.78571C4 4.80909 4.78639 4 5.77778 4H18.2222C19.2136 4 20 4.80909 20 5.78571v1.34031C19.6804 7.04375 19.3453 7 19 7h-3.566c-1.1074 0-2.1653.45912-2.9217 1.26802l-2.434 2.60308C9.38544 11.612 9 12.5886 9 13.603V19c0 .3453.04375.6804.12602 1H4c-1.10457 0-2-.8954-2-2v-1c0-1.1046.89543-2 2-2V5.78571Z"></path><path d="M15 9.04765V13h-3.9069c.0892-.282.2406-.5432.4461-.763l2.434-2.60299c.2776-.29692.6365-.49959 1.0268-.58636Z"></path><path d="M17 9v4c0 1.1046-.8954 2-2 2h-4v4c0 1.1046.8954 2 2 2h6c1.1046 0 2-.8954 2-2v-8c0-1.10457-.8954-2-2-2h-2Z"></path></svg>`), LaptopFileSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [52, 2]]]]);
function LaptopFileSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LaptopFileSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root439();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1439();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LaptopFileSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2439();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LaptopFileSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LaptopFileSolid = hmr(LaptopFileSolid, () => LaptopFileSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaptopFileSolid[HMR].source;
    set(LaptopFileSolid[HMR].source, module.default[HMR].original);
  });
}
var LaptopFileSolid_default = LaptopFileSolid;

// node_modules/flowbite-svelte-icons/dist/LaravelSolid.svelte
LaravelSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaravelSolid.svelte";
var root_1440 = add_locations(from_svg(`<title> </title>`), LaravelSolid[FILENAME], [[41, 4]]);
var root_2440 = add_locations(from_svg(`<desc> </desc>`), LaravelSolid[FILENAME], [[44, 4]]);
var root440 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="m17 13 3.4641-2V7L17 5l-3.4641 2v4M17 13l-3.4641-2M17 13v4l-7.00001 4M17 13V9m0 4-7.00001 4m3.53591-6L10.5 12.7348M9.99999 21l-3.4641-2.1318M9.99999 21v-4m-3.4641 2v-.1318m0 0V15L10.5 12.7348m-3.96411 6.1334L3.5 17V5m0 0L7 3l3.5 2m-7 0 2.99999 2M10.5 5v7.7348M10.5 5 6.49999 7M17 9l3.5-2M17 9l-3.5-2M9.99999 17l-3.5-2m0 .5V7"></path></svg>`), LaravelSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LaravelSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LaravelSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root440();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1440();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LaravelSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2440();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LaravelSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LaravelSolid = hmr(LaravelSolid, () => LaravelSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaravelSolid[HMR].source;
    set(LaravelSolid[HMR].source, module.default[HMR].original);
  });
}
var LaravelSolid_default = LaravelSolid;

// node_modules/flowbite-svelte-icons/dist/LayersOutline.svelte
LayersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LayersOutline.svelte";
var root_1441 = add_locations(from_svg(`<title> </title>`), LayersOutline[FILENAME], [[43, 4]]);
var root_2441 = add_locations(from_svg(`<desc> </desc>`), LayersOutline[FILENAME], [[46, 4]]);
var root441 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.005 11.19V12l6.998 4.042L19 12v-.81M5 16.15v.81L11.997 21l6.998-4.042v-.81M12.003 3 5.005 7.042l6.998 4.042L19 7.042 12.003 3Z"></path></svg>`), LayersOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LayersOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LayersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root441();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1441();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LayersOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2441();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LayersOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LayersOutline = hmr(LayersOutline, () => LayersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LayersOutline[HMR].source;
    set(LayersOutline[HMR].source, module.default[HMR].original);
  });
}
var LayersOutline_default = LayersOutline;

// node_modules/flowbite-svelte-icons/dist/LayersSolid.svelte
LayersSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LayersSolid.svelte";
var root_1442 = add_locations(from_svg(`<title> </title>`), LayersSolid[FILENAME], [[41, 4]]);
var root_2442 = add_locations(from_svg(`<desc> </desc>`), LayersSolid[FILENAME], [[44, 4]]);
var root442 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.005 10.19a1 1 0 0 1 1 1v.233l5.998 3.464L18 11.423v-.232a1 1 0 1 1 2 0V12a1 1 0 0 1-.5.866l-6.997 4.042a1 1 0 0 1-1 0l-6.998-4.042a1 1 0 0 1-.5-.866v-.81a1 1 0 0 1 1-1ZM5 15.15a1 1 0 0 1 1 1v.232l5.997 3.464 5.998-3.464v-.232a1 1 0 1 1 2 0v.81a1 1 0 0 1-.5.865l-6.998 4.042a1 1 0 0 1-1 0L4.5 17.824a1 1 0 0 1-.5-.866v-.81a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M12.503 2.134a1 1 0 0 0-1 0L4.501 6.17A1 1 0 0 0 4.5 7.902l7.002 4.047a1 1 0 0 0 1 0l6.998-4.04a1 1 0 0 0 0-1.732l-6.997-4.042Z"></path></svg>`), LayersSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function LayersSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LayersSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root442();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1442();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LayersSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2442();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LayersSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LayersSolid = hmr(LayersSolid, () => LayersSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LayersSolid[HMR].source;
    set(LayersSolid[HMR].source, module.default[HMR].original);
  });
}
var LayersSolid_default = LayersSolid;

// node_modules/flowbite-svelte-icons/dist/LemonOutline.svelte
LemonOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LemonOutline.svelte";
var root_1443 = add_locations(from_svg(`<title> </title>`), LemonOutline[FILENAME], [[43, 4]]);
var root_2443 = add_locations(from_svg(`<desc> </desc>`), LemonOutline[FILENAME], [[46, 4]]);
var root443 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.3058 8.29519C9.55698 9.38222 8.81979 11.2498 9.00197 13.9395M14.667 4.18096l-1.0565.50487c-.3418.13297-1.523.3194-1.7152.3194-4.83207.6468-7.74553 5.76877-5.88136 10.33957l.4506 1.1049c.07315.1793.1279.4848.13448.5625.00656.0775.09722 1.1779.09749 1.1811.00001.0001 0 .0001.00001.0002.10784 1.3052 1.46355 2.1014 2.63163 1.5474.00336-.0016.00624-.003.00959-.0046.07162-.0347.97416-.4719 1.05206-.5027.081-.032.3576-.1377.5472-.1631l1.168-.1563c4.832-.6468 7.7455-5.7687 5.8813-10.33958l-.4506-1.10485c-.0731-.17935-.1185-.3691-.1345-.56253l-.0975-1.18113c-.1079-1.30718-1.4674-2.10389-2.6367-1.54515Z"></path></svg>`), LemonOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LemonOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LemonOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root443();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1443();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LemonOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2443();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LemonOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LemonOutline = hmr(LemonOutline, () => LemonOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LemonOutline[HMR].source;
    set(LemonOutline[HMR].source, module.default[HMR].original);
  });
}
var LemonOutline_default = LemonOutline;

// node_modules/flowbite-svelte-icons/dist/LemonSolid.svelte
LemonSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LemonSolid.svelte";
var root_1444 = add_locations(from_svg(`<title> </title>`), LemonSolid[FILENAME], [[41, 4]]);
var root_2444 = add_locations(from_svg(`<desc> </desc>`), LemonSolid[FILENAME], [[44, 4]]);
var root444 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14.2357 3.27869c1.8195-.86945 3.9007.38069 4.0645 2.36516l.0975 1.18113c.0076.09216.0292.1823.0638.26716l.4506 1.10484c2.1046 5.16042-1.1766 10.97242-6.6746 11.70842l-1.1662.1561s-.0119.002-.0374.0087c-.0288.0074-.0633.0177-.1013.0301-.0764.0249-.1452.0514-.1755.0633.0117-.0046.007-.0024-.0213.0108-.021.0098-.0549.0257-.1048.0494-.0942.0447-.2147.1024-.3364.1609-.2429.1168-.48538.2343-.52094.2515l-.01715.0082c-1.81776.8622-3.89304-.387-4.05675-2.3686-.00127-.0155-.08435-1.0237-.09627-1.1666-.0008-.0054-.0021-.0137-.00399-.0249-.00463-.0272-.01145-.0632-.01997-.1022-.00858-.0394-.01778-.0769-.02671-.1085-.00811-.0288-.01333-.0433-.0143-.046l-.45069-1.1051C2.9832 10.562 6.26445 4.75002 11.7625 4.01408l.066-.00884h.0667c-.0154 0-.0147-.00007.0069-.00241.0242-.00264.0748-.00813.1587-.01959.1294-.01768.2935-.04317.4638-.07293.1709-.02985.3404-.06263.4824-.09437.0709-.01587.1301-.03039.1764-.043.0198-.00541.0347-.00976.0451-.01294l1.0072-.48131Zm-1.5623 5.94643c.5136-.2031.7653-.78409.5622-1.29767-.2031-.51359-.7841-.76529-1.2977-.56219-1.5354.60719-2.6205 1.4812-3.26395 2.67734-.63096 1.1729-.76717 2.5276-.66985 3.9645.03732.551.51427.9674 1.06529.9301.55102-.0373.96741-.5143.93014-1.0653-.08486-1.2529.05647-2.1767.43577-2.8818.3668-.6819 1.0247-1.28514 2.2381-1.76498Z" clip-rule="evenodd"></path></svg>`), LemonSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LemonSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LemonSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root444();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1444();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LemonSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2444();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LemonSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LemonSolid = hmr(LemonSolid, () => LemonSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LemonSolid[HMR].source;
    set(LemonSolid[HMR].source, module.default[HMR].original);
  });
}
var LemonSolid_default = LemonSolid;

// node_modules/flowbite-svelte-icons/dist/LetterBoldOutline.svelte
LetterBoldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterBoldOutline.svelte";
var root_1445 = add_locations(from_svg(`<title> </title>`), LetterBoldOutline[FILENAME], [[43, 4]]);
var root_2445 = add_locations(from_svg(`<desc> </desc>`), LetterBoldOutline[FILENAME], [[46, 4]]);
var root445 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 5h4.5a3.5 3.5 0 1 1 0 7H8m0-7v7m0-7H6m2 7h6.5a3.5 3.5 0 1 1 0 7H8m0-7v7m0 0H6"></path></svg>`), LetterBoldOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LetterBoldOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LetterBoldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root445();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1445();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LetterBoldOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2445();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LetterBoldOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LetterBoldOutline = hmr(LetterBoldOutline, () => LetterBoldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterBoldOutline[HMR].source;
    set(LetterBoldOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterBoldOutline_default = LetterBoldOutline;

// node_modules/flowbite-svelte-icons/dist/LetterItalicOutline.svelte
LetterItalicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterItalicOutline.svelte";
var root_1446 = add_locations(from_svg(`<title> </title>`), LetterItalicOutline[FILENAME], [[43, 4]]);
var root_2446 = add_locations(from_svg(`<desc> </desc>`), LetterItalicOutline[FILENAME], [[46, 4]]);
var root446 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8.874 19 6.143-14M6 19h6.33m-.66-14H18"></path></svg>`), LetterItalicOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LetterItalicOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LetterItalicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root446();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1446();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LetterItalicOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2446();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LetterItalicOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LetterItalicOutline = hmr(LetterItalicOutline, () => LetterItalicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterItalicOutline[HMR].source;
    set(LetterItalicOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterItalicOutline_default = LetterItalicOutline;

// node_modules/flowbite-svelte-icons/dist/LetterUnderlineOutline.svelte
LetterUnderlineOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterUnderlineOutline.svelte";
var root_1447 = add_locations(from_svg(`<title> </title>`), LetterUnderlineOutline[FILENAME], [[43, 4]]);
var root_2447 = add_locations(from_svg(`<desc> </desc>`), LetterUnderlineOutline[FILENAME], [[46, 4]]);
var root447 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M6 19h12M8 5v9a4 4 0 0 0 8 0V5M6 5h4m4 0h4"></path></svg>`), LetterUnderlineOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LetterUnderlineOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LetterUnderlineOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root447();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1447();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LetterUnderlineOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2447();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LetterUnderlineOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LetterUnderlineOutline = hmr(LetterUnderlineOutline, () => LetterUnderlineOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterUnderlineOutline[HMR].source;
    set(LetterUnderlineOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterUnderlineOutline_default = LetterUnderlineOutline;

// node_modules/flowbite-svelte-icons/dist/LifeSaverOutline.svelte
LifeSaverOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LifeSaverOutline.svelte";
var root_1448 = add_locations(from_svg(`<title> </title>`), LifeSaverOutline[FILENAME], [[43, 4]]);
var root_2448 = add_locations(from_svg(`<desc> </desc>`), LifeSaverOutline[FILENAME], [[46, 4]]);
var root448 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m13.46 8.291 3.849-3.849a1.5 1.5 0 0 1 2.122 0l.127.127a1.5 1.5 0 0 1 0 2.122l-3.84 3.838a4 4 0 0 0-2.258-2.238Zm0 0a4 4 0 0 1 2.263 2.238l3.662-3.662a8.961 8.961 0 0 1 0 10.27l-3.676-3.676m-2.25-5.17 3.678-3.676a8.961 8.961 0 0 0-10.27 0l3.662 3.662a4 4 0 0 0-2.238 2.258L4.615 6.863a8.96 8.96 0 0 0 0 10.27l3.662-3.662a4 4 0 0 0 2.258 2.238l-3.672 3.676a8.96 8.96 0 0 0 10.27 0l-3.662-3.662a4.001 4.001 0 0 0 2.238-2.262m0 0 3.849 3.848a1.5 1.5 0 0 1 0 2.122l-.127.126a1.499 1.499 0 0 1-2.122 0l-3.838-3.838a4 4 0 0 0 2.238-2.258Zm.29-1.461a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-7.718 1.471-3.84 3.838a1.5 1.5 0 0 0 0 2.122l.128.126a1.5 1.5 0 0 0 2.122 0l3.848-3.848a4 4 0 0 1-2.258-2.238Zm2.248-5.19L6.69 4.442a1.5 1.5 0 0 0-2.122 0l-.127.127a1.5 1.5 0 0 0 0 2.122l3.849 3.848a4 4 0 0 1 2.238-2.258Z"></path></svg>`), LifeSaverOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LifeSaverOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LifeSaverOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root448();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1448();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LifeSaverOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2448();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LifeSaverOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LifeSaverOutline = hmr(LifeSaverOutline, () => LifeSaverOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LifeSaverOutline[HMR].source;
    set(LifeSaverOutline[HMR].source, module.default[HMR].original);
  });
}
var LifeSaverOutline_default = LifeSaverOutline;

// node_modules/flowbite-svelte-icons/dist/LifeSaverSolid.svelte
LifeSaverSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LifeSaverSolid.svelte";
var root_1449 = add_locations(from_svg(`<title> </title>`), LifeSaverSolid[FILENAME], [[41, 4]]);
var root_2449 = add_locations(from_svg(`<desc> </desc>`), LifeSaverSolid[FILENAME], [[44, 4]]);
var root449 = add_locations(from_svg(`<svg><!><!><path d="m7.4 3.736 3.43 3.429A5.046 5.046 0 0 1 12.133 7c.356.01.71.06 1.056.147l3.41-3.412a2.32 2.32 0 0 1 .451-.344A9.89 9.89 0 0 0 12.268 2a10.022 10.022 0 0 0-5.322 1.392c.165.095.318.211.454.344Zm11.451 1.54-.127-.127a.5.5 0 0 0-.706 0l-2.932 2.932c.03.023.05.054.078.077.237.194.454.41.651.645.033.038.077.067.11.107l2.926-2.927a.5.5 0 0 0 0-.707Zm-2.931 9.81c-.025.03-.058.052-.082.082a4.97 4.97 0 0 1-.633.639c-.04.036-.072.083-.115.117l2.927 2.927a.5.5 0 0 0 .707 0l.127-.127a.5.5 0 0 0 0-.707l-2.932-2.931Zm-1.443-4.763a3.037 3.037 0 0 0-1.383-1.1l-.012-.007a2.956 2.956 0 0 0-1-.213H12a2.964 2.964 0 0 0-2.122.893c-.285.29-.509.634-.657 1.013l-.009.016a2.96 2.96 0 0 0-.21 1 2.99 2.99 0 0 0 .488 1.716l.032.04a3.04 3.04 0 0 0 1.384 1.1l.012.007c.319.129.657.2 1 .213.393.015.784-.05 1.15-.192.012-.005.021-.013.033-.018a3.01 3.01 0 0 0 1.676-1.7v-.007a2.89 2.89 0 0 0 0-2.207 2.868 2.868 0 0 0-.27-.515c-.007-.012-.02-.025-.03-.039Zm6.137-3.373a2.53 2.53 0 0 1-.349.447l-3.426 3.426c.112.428.166.869.161 1.311a4.954 4.954 0 0 1-.148 1.054l3.413 3.412c.133.134.249.283.347.444A9.88 9.88 0 0 0 22 12.269a9.913 9.913 0 0 0-1.386-5.319ZM16.6 20.264l-3.42-3.421c-.386.1-.782.152-1.18.157h-.135c-.356-.01-.71-.06-1.056-.147L7.4 20.265a2.503 2.503 0 0 1-.444.347A9.884 9.884 0 0 0 11.732 22H12a9.9 9.9 0 0 0 5.044-1.388 2.515 2.515 0 0 1-.444-.348ZM3.735 16.6l3.426-3.426a4.608 4.608 0 0 1-.013-2.367L3.735 7.4a2.508 2.508 0 0 1-.349-.447 9.889 9.889 0 0 0 0 10.1 2.48 2.48 0 0 1 .35-.453Zm5.101-.758a4.959 4.959 0 0 1-.65-.645c-.034-.038-.078-.067-.11-.107L5.15 18.017a.5.5 0 0 0 0 .707l.127.127a.5.5 0 0 0 .706 0l2.932-2.933c-.029-.018-.049-.053-.078-.076Zm-.755-6.928c.03-.037.07-.063.1-.1.183-.22.383-.423.6-.609.046-.04.081-.092.128-.13L5.983 5.149a.5.5 0 0 0-.707 0l-.127.127a.5.5 0 0 0 0 .707l2.932 2.931Z"></path></svg>`), LifeSaverSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LifeSaverSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LifeSaverSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root449();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1449();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LifeSaverSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2449();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LifeSaverSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LifeSaverSolid = hmr(LifeSaverSolid, () => LifeSaverSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LifeSaverSolid[HMR].source;
    set(LifeSaverSolid[HMR].source, module.default[HMR].original);
  });
}
var LifeSaverSolid_default = LifeSaverSolid;

// node_modules/flowbite-svelte-icons/dist/LightbulbOutline.svelte
LightbulbOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LightbulbOutline.svelte";
var root_1450 = add_locations(from_svg(`<title> </title>`), LightbulbOutline[FILENAME], [[43, 4]]);
var root_2450 = add_locations(from_svg(`<desc> </desc>`), LightbulbOutline[FILENAME], [[46, 4]]);
var root450 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 9a3 3 0 0 1 3-3m-2 15h4m0-3c0-4.1 4-4.9 4-9A6 6 0 1 0 6 9c0 4 4 5 4 9h4Z"></path></svg>`), LightbulbOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LightbulbOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LightbulbOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root450();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1450();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LightbulbOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2450();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LightbulbOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LightbulbOutline = hmr(LightbulbOutline, () => LightbulbOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LightbulbOutline[HMR].source;
    set(LightbulbOutline[HMR].source, module.default[HMR].original);
  });
}
var LightbulbOutline_default = LightbulbOutline;

// node_modules/flowbite-svelte-icons/dist/LightbulbSolid.svelte
LightbulbSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LightbulbSolid.svelte";
var root_1451 = add_locations(from_svg(`<title> </title>`), LightbulbSolid[FILENAME], [[41, 4]]);
var root_2451 = add_locations(from_svg(`<desc> </desc>`), LightbulbSolid[FILENAME], [[44, 4]]);
var root451 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7.05 4.05A7 7 0 0 1 19 9c0 2.407-1.197 3.874-2.186 5.084l-.04.048C15.77 15.362 15 16.34 15 18a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1c0-1.612-.77-2.613-1.78-3.875l-.045-.056C6.193 12.842 5 11.352 5 9a7 7 0 0 1 2.05-4.95ZM9 21a1 1 0 0 1 1-1h4a1 1 0 1 1 0 2h-4a1 1 0 0 1-1-1Zm1.586-13.414A2 2 0 0 1 12 7a1 1 0 1 0 0-2 4 4 0 0 0-4 4 1 1 0 0 0 2 0 2 2 0 0 1 .586-1.414Z" clip-rule="evenodd"></path></svg>`), LightbulbSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LightbulbSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LightbulbSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root451();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1451();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LightbulbSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2451();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LightbulbSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LightbulbSolid = hmr(LightbulbSolid, () => LightbulbSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LightbulbSolid[HMR].source;
    set(LightbulbSolid[HMR].source, module.default[HMR].original);
  });
}
var LightbulbSolid_default = LightbulbSolid;

// node_modules/flowbite-svelte-icons/dist/LinkBreakOutline.svelte
LinkBreakOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkBreakOutline.svelte";
var root_1452 = add_locations(from_svg(`<title> </title>`), LinkBreakOutline[FILENAME], [[43, 4]]);
var root_2452 = add_locations(from_svg(`<desc> </desc>`), LinkBreakOutline[FILENAME], [[46, 4]]);
var root452 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M13.2131 9.78732c-.6359-.63557-1.4983-.99259-2.3974-.99259-.89911 0-1.76143.35702-2.39741.99259l-3.4253 3.42528C4.35719 13.8485 4 14.7108 4 15.61c0 .8992.35719 1.7616.99299 2.3974.63598.6356 1.4983.9926 2.39742.9926.89912 0 1.76144-.357 2.39742-.9926l.32157-.3043m-.32157-4.4905c.63587.6358 1.49827.993 2.39747.993.8991 0 1.7615-.3572 2.3974-.993l3.4243-3.42528c.6358-.63585.993-1.49822.993-2.39741 0-.89919-.3572-1.76156-.993-2.39741C17.3712 4.357 16.509 4 15.6101 4c-.899 0-1.7612.357-2.397.9925l-1.0278.96062m7.3873 14.04678-1.7862-1.7862m0 0L16 16.4274m1.7864 1.7863 1.7862-1.7863m-1.7862 1.7863L16 20"></path></svg>`), LinkBreakOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LinkBreakOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LinkBreakOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root452();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1452();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LinkBreakOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2452();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LinkBreakOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LinkBreakOutline = hmr(LinkBreakOutline, () => LinkBreakOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkBreakOutline[HMR].source;
    set(LinkBreakOutline[HMR].source, module.default[HMR].original);
  });
}
var LinkBreakOutline_default = LinkBreakOutline;

// node_modules/flowbite-svelte-icons/dist/LinkedinSolid.svelte
LinkedinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkedinSolid.svelte";
var root_1453 = add_locations(from_svg(`<title> </title>`), LinkedinSolid[FILENAME], [[41, 4]]);
var root_2453 = add_locations(from_svg(`<desc> </desc>`), LinkedinSolid[FILENAME], [[44, 4]]);
var root453 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12.51 8.796v1.697a3.738 3.738 0 0 1 3.288-1.684c3.455 0 4.202 2.16 4.202 4.97V19.5h-3.2v-5.072c0-1.21-.244-2.766-2.128-2.766-1.827 0-2.139 1.317-2.139 2.676V19.5h-3.19V8.796h3.168ZM7.2 6.106a1.61 1.61 0 0 1-.988 1.483 1.595 1.595 0 0 1-1.743-.348A1.607 1.607 0 0 1 5.6 4.5a1.601 1.601 0 0 1 1.6 1.606Z" clip-rule="evenodd"></path><path d="M7.2 8.809H4V19.5h3.2V8.809Z"></path></svg>`), LinkedinSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function LinkedinSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LinkedinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root453();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1453();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LinkedinSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2453();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LinkedinSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LinkedinSolid = hmr(LinkedinSolid, () => LinkedinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkedinSolid[HMR].source;
    set(LinkedinSolid[HMR].source, module.default[HMR].original);
  });
}
var LinkedinSolid_default = LinkedinSolid;

// node_modules/flowbite-svelte-icons/dist/LinkOutline.svelte
LinkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkOutline.svelte";
var root_1454 = add_locations(from_svg(`<title> </title>`), LinkOutline[FILENAME], [[43, 4]]);
var root_2454 = add_locations(from_svg(`<desc> </desc>`), LinkOutline[FILENAME], [[46, 4]]);
var root454 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.213 9.787a3.391 3.391 0 0 0-4.795 0l-3.425 3.426a3.39 3.39 0 0 0 4.795 4.794l.321-.304m-.321-4.49a3.39 3.39 0 0 0 4.795 0l3.424-3.426a3.39 3.39 0 0 0-4.794-4.795l-1.028.961"></path></svg>`), LinkOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LinkOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LinkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root454();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1454();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LinkOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2454();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LinkOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LinkOutline = hmr(LinkOutline, () => LinkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkOutline[HMR].source;
    set(LinkOutline[HMR].source, module.default[HMR].original);
  });
}
var LinkOutline_default = LinkOutline;

// node_modules/flowbite-svelte-icons/dist/ListMusicOutline.svelte
ListMusicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListMusicOutline.svelte";
var root_1455 = add_locations(from_svg(`<title> </title>`), ListMusicOutline[FILENAME], [[43, 4]]);
var root_2455 = add_locations(from_svg(`<desc> </desc>`), ListMusicOutline[FILENAME], [[46, 4]]);
var root455 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 15.5V5s3 1 3 4m-7-3H4m9 4H4m4 4H4m13 2.4c0 1.326-1.343 2.4-3 2.4s-3-1.075-3-2.4 1.343-2.4 3-2.4 3 1.075 3 2.4Z"></path></svg>`), ListMusicOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ListMusicOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ListMusicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root455();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1455();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ListMusicOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2455();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ListMusicOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ListMusicOutline = hmr(ListMusicOutline, () => ListMusicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListMusicOutline[HMR].source;
    set(ListMusicOutline[HMR].source, module.default[HMR].original);
  });
}
var ListMusicOutline_default = ListMusicOutline;

// node_modules/flowbite-svelte-icons/dist/ListMusicSolid.svelte
ListMusicSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListMusicSolid.svelte";
var root_1456 = add_locations(from_svg(`<title> </title>`), ListMusicSolid[FILENAME], [[41, 4]]);
var root_2456 = add_locations(from_svg(`<desc> </desc>`), ListMusicSolid[FILENAME], [[44, 4]]);
var root456 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17.316 4.052a.99.99 0 0 0-.9.14c-.262.19-.416.495-.416.82v8.566a4.573 4.573 0 0 0-2-.464c-1.99 0-4 1.342-4 3.443 0 2.1 2.01 3.443 4 3.443 1.99 0 4-1.342 4-3.443V6.801c.538.5 1 1.219 1 2.262 0 .56.448 1.013 1 1.013s1-.453 1-1.013c0-1.905-.956-3.18-1.86-3.942a6.391 6.391 0 0 0-1.636-.998 4 4 0 0 0-.166-.063l-.013-.005-.005-.002h-.002l-.002-.001ZM4 5.012c-.552 0-1 .454-1 1.013 0 .56.448 1.013 1 1.013h9c.552 0 1-.453 1-1.013 0-.559-.448-1.012-1-1.012H4Zm0 4.051c-.552 0-1 .454-1 1.013 0 .56.448 1.013 1 1.013h9c.552 0 1-.454 1-1.013 0-.56-.448-1.013-1-1.013H4Zm0 4.05c-.552 0-1 .454-1 1.014 0 .559.448 1.012 1 1.012h4c.552 0 1-.453 1-1.012 0-.56-.448-1.013-1-1.013H4Z" clip-rule="evenodd"></path></svg>`), ListMusicSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ListMusicSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ListMusicSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root456();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1456();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ListMusicSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2456();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ListMusicSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ListMusicSolid = hmr(ListMusicSolid, () => ListMusicSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListMusicSolid[HMR].source;
    set(ListMusicSolid[HMR].source, module.default[HMR].original);
  });
}
var ListMusicSolid_default = ListMusicSolid;

// node_modules/flowbite-svelte-icons/dist/ListOutline.svelte
ListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListOutline.svelte";
var root_1457 = add_locations(from_svg(`<title> </title>`), ListOutline[FILENAME], [[43, 4]]);
var root_2457 = add_locations(from_svg(`<desc> </desc>`), ListOutline[FILENAME], [[46, 4]]);
var root457 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M9 8h10M9 12h10M9 16h10M4.99 8H5m-.02 4h.01m0 4H5"></path></svg>`), ListOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ListOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root457();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1457();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ListOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2457();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ListOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ListOutline = hmr(ListOutline, () => ListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListOutline[HMR].source;
    set(ListOutline[HMR].source, module.default[HMR].original);
  });
}
var ListOutline_default = ListOutline;

// node_modules/flowbite-svelte-icons/dist/LockOpenOutline.svelte
LockOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOpenOutline.svelte";
var root_1458 = add_locations(from_svg(`<title> </title>`), LockOpenOutline[FILENAME], [[43, 4]]);
var root_2458 = add_locations(from_svg(`<desc> </desc>`), LockOpenOutline[FILENAME], [[46, 4]]);
var root458 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 14v3m4-6V7a3 3 0 1 1 6 0v4M5 11h10a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1Z"></path></svg>`), LockOpenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LockOpenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root458();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1458();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockOpenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2458();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockOpenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockOpenOutline = hmr(LockOpenOutline, () => LockOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOpenOutline[HMR].source;
    set(LockOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var LockOpenOutline_default = LockOpenOutline;

// node_modules/flowbite-svelte-icons/dist/LockOpenSolid.svelte
LockOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOpenSolid.svelte";
var root_1459 = add_locations(from_svg(`<title> </title>`), LockOpenSolid[FILENAME], [[41, 4]]);
var root_2459 = add_locations(from_svg(`<desc> </desc>`), LockOpenSolid[FILENAME], [[44, 4]]);
var root459 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15 7a2 2 0 1 1 4 0v4a1 1 0 1 0 2 0V7a4 4 0 0 0-8 0v3H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V7Zm-5 6a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-3a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), LockOpenSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LockOpenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root459();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1459();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockOpenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2459();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockOpenSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockOpenSolid = hmr(LockOpenSolid, () => LockOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOpenSolid[HMR].source;
    set(LockOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var LockOpenSolid_default = LockOpenSolid;

// node_modules/flowbite-svelte-icons/dist/LockOutline.svelte
LockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOutline.svelte";
var root_1460 = add_locations(from_svg(`<title> </title>`), LockOutline[FILENAME], [[43, 4]]);
var root_2460 = add_locations(from_svg(`<desc> </desc>`), LockOutline[FILENAME], [[46, 4]]);
var root460 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 14v3m-3-6V7a3 3 0 1 1 6 0v4m-8 0h10a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1Z"></path></svg>`), LockOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LockOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root460();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1460();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2460();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockOutline = hmr(LockOutline, () => LockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOutline[HMR].source;
    set(LockOutline[HMR].source, module.default[HMR].original);
  });
}
var LockOutline_default = LockOutline;

// node_modules/flowbite-svelte-icons/dist/LockSolid.svelte
LockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockSolid.svelte";
var root_1461 = add_locations(from_svg(`<title> </title>`), LockSolid[FILENAME], [[41, 4]]);
var root_2461 = add_locations(from_svg(`<desc> </desc>`), LockSolid[FILENAME], [[44, 4]]);
var root461 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 10V7a4 4 0 1 1 8 0v3h1a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1Zm2-3a2 2 0 1 1 4 0v3h-4V7Zm2 6a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-3a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), LockSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function LockSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root461();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1461();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2461();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockSolid = hmr(LockSolid, () => LockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockSolid[HMR].source;
    set(LockSolid[HMR].source, module.default[HMR].original);
  });
}
var LockSolid_default = LockSolid;

// node_modules/flowbite-svelte-icons/dist/LockTimeOutline.svelte
LockTimeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockTimeOutline.svelte";
var root_1462 = add_locations(from_svg(`<title> </title>`), LockTimeOutline[FILENAME], [[43, 4]]);
var root_2462 = add_locations(from_svg(`<desc> </desc>`), LockTimeOutline[FILENAME], [[46, 4]]);
var root462 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.5 11H5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h4.5M7 11V7a3 3 0 0 1 6 0v1.5m2.5 5.5v1.5l1 1m3.5-1a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z"></path></svg>`), LockTimeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function LockTimeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockTimeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root462();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1462();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockTimeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2462();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockTimeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockTimeOutline = hmr(LockTimeOutline, () => LockTimeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockTimeOutline[HMR].source;
    set(LockTimeOutline[HMR].source, module.default[HMR].original);
  });
}
var LockTimeOutline_default = LockTimeOutline;

// node_modules/flowbite-svelte-icons/dist/LockTimeSolid.svelte
LockTimeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockTimeSolid.svelte";
var root_1463 = add_locations(from_svg(`<title> </title>`), LockTimeSolid[FILENAME], [[41, 4]]);
var root_2463 = add_locations(from_svg(`<desc> </desc>`), LockTimeSolid[FILENAME], [[44, 4]]);
var root463 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10 5a2 2 0 0 0-2 2v3h2.4A7.48 7.48 0 0 0 8 15.5a7.48 7.48 0 0 0 2.4 5.5H5a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1V7a4 4 0 1 1 8 0v1.15a7.446 7.446 0 0 0-1.943.685A.999.999 0 0 1 12 8.5V7a2 2 0 0 0-2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M10 15.5a5.5 5.5 0 1 1 11 0 5.5 5.5 0 0 1-11 0Zm6.5-1.5a1 1 0 1 0-2 0v1.5a1 1 0 0 0 .293.707l1 1a1 1 0 0 0 1.414-1.414l-.707-.707V14Z" clip-rule="evenodd"></path></svg>`), LockTimeSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function LockTimeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, LockTimeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root463();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1463();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      LockTimeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2463();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      LockTimeSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  LockTimeSolid = hmr(LockTimeSolid, () => LockTimeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockTimeSolid[HMR].source;
    set(LockTimeSolid[HMR].source, module.default[HMR].original);
  });
}
var LockTimeSolid_default = LockTimeSolid;

// node_modules/flowbite-svelte-icons/dist/MailBoxOutline.svelte
MailBoxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MailBoxOutline.svelte";
var root_1464 = add_locations(from_svg(`<title> </title>`), MailBoxOutline[FILENAME], [[43, 4]]);
var root_2464 = add_locations(from_svg(`<desc> </desc>`), MailBoxOutline[FILENAME], [[46, 4]]);
var root464 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 16v-5.5A3.5 3.5 0 0 0 7.5 7m3.5 9H4v-5.5A3.5 3.5 0 0 1 7.5 7m3.5 9v4M7.5 7H14m0 0V4h2.5M14 7v3m-3.5 6H20v-6a3 3 0 0 0-3-3m-2 9v4m-8-6.5h1"></path></svg>`), MailBoxOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MailBoxOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MailBoxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root464();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1464();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MailBoxOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2464();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MailBoxOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MailBoxOutline = hmr(MailBoxOutline, () => MailBoxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MailBoxOutline[HMR].source;
    set(MailBoxOutline[HMR].source, module.default[HMR].original);
  });
}
var MailBoxOutline_default = MailBoxOutline;

// node_modules/flowbite-svelte-icons/dist/MailBoxSolid.svelte
MailBoxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MailBoxSolid.svelte";
var root_1465 = add_locations(from_svg(`<title> </title>`), MailBoxSolid[FILENAME], [[41, 4]]);
var root_2465 = add_locations(from_svg(`<desc> </desc>`), MailBoxSolid[FILENAME], [[44, 4]]);
var root465 = add_locations(from_svg(`<svg><!><!><path d="M17 6h-2V5h1a1 1 0 1 0 0-2h-2a1 1 0 0 0-1 1v2h-.541A5.965 5.965 0 0 1 14 10v4a1 1 0 1 1-2 0v-4c0-2.206-1.794-4-4-4-.075 0-.148.012-.22.028C7.686 6.022 7.596 6 7.5 6A4.505 4.505 0 0 0 3 10.5V16a1 1 0 0 0 1 1h7v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3h5a1 1 0 0 0 1-1v-6c0-2.206-1.794-4-4-4Zm-9 8.5H7a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2Z"></path></svg>`), MailBoxSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MailBoxSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MailBoxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root465();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1465();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MailBoxSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2465();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MailBoxSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MailBoxSolid = hmr(MailBoxSolid, () => MailBoxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MailBoxSolid[HMR].source;
    set(MailBoxSolid[HMR].source, module.default[HMR].original);
  });
}
var MailBoxSolid_default = MailBoxSolid;

// node_modules/flowbite-svelte-icons/dist/MapPinAltOutline.svelte
MapPinAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinAltOutline.svelte";
var root_1466 = add_locations(from_svg(`<title> </title>`), MapPinAltOutline[FILENAME], [[43, 4]]);
var root_2466 = add_locations(from_svg(`<desc> </desc>`), MapPinAltOutline[FILENAME], [[46, 4]]);
var root466 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.8 13.938h-.011a7 7 0 1 0-11.464.144h-.016l.14.171c.1.127.2.251.3.371L12 21l5.13-6.248c.194-.209.374-.429.54-.659l.13-.155Z"></path></svg>`), MapPinAltOutline[FILENAME], [[31, 0, [[48, 2], [55, 2]]]]);
function MapPinAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MapPinAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root466();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1466();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MapPinAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2466();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MapPinAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MapPinAltOutline = hmr(MapPinAltOutline, () => MapPinAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinAltOutline[HMR].source;
    set(MapPinAltOutline[HMR].source, module.default[HMR].original);
  });
}
var MapPinAltOutline_default = MapPinAltOutline;

// node_modules/flowbite-svelte-icons/dist/MapPinAltSolid.svelte
MapPinAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinAltSolid.svelte";
var root_1467 = add_locations(from_svg(`<title> </title>`), MapPinAltSolid[FILENAME], [[41, 4]]);
var root_2467 = add_locations(from_svg(`<desc> </desc>`), MapPinAltSolid[FILENAME], [[44, 4]]);
var root467 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.906 1.994a8.002 8.002 0 0 1 8.09 8.421 7.996 7.996 0 0 1-1.297 3.957.996.996 0 0 1-.133.204l-.108.129c-.178.243-.37.477-.573.699l-5.112 6.224a1 1 0 0 1-1.545 0L5.982 15.26l-.002-.002a18.146 18.146 0 0 1-.309-.38l-.133-.163a.999.999 0 0 1-.13-.202 7.995 7.995 0 0 1 6.498-12.518ZM15 9.997a3 3 0 1 1-5.999 0 3 3 0 0 1 5.999 0Z" clip-rule="evenodd"></path></svg>`), MapPinAltSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MapPinAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MapPinAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root467();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1467();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MapPinAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2467();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MapPinAltSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MapPinAltSolid = hmr(MapPinAltSolid, () => MapPinAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinAltSolid[HMR].source;
    set(MapPinAltSolid[HMR].source, module.default[HMR].original);
  });
}
var MapPinAltSolid_default = MapPinAltSolid;

// node_modules/flowbite-svelte-icons/dist/MapPinOutline.svelte
MapPinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinOutline.svelte";
var root_1468 = add_locations(from_svg(`<title> </title>`), MapPinOutline[FILENAME], [[43, 4]]);
var root_2468 = add_locations(from_svg(`<desc> </desc>`), MapPinOutline[FILENAME], [[46, 4]]);
var root468 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0 0v6M9.5 9A2.5 2.5 0 0 1 12 6.5"></path></svg>`), MapPinOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MapPinOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MapPinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root468();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1468();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MapPinOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2468();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MapPinOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MapPinOutline = hmr(MapPinOutline, () => MapPinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinOutline[HMR].source;
    set(MapPinOutline[HMR].source, module.default[HMR].original);
  });
}
var MapPinOutline_default = MapPinOutline;

// node_modules/flowbite-svelte-icons/dist/MapPinSolid.svelte
MapPinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinSolid.svelte";
var root_1469 = add_locations(from_svg(`<title> </title>`), MapPinSolid[FILENAME], [[41, 4]]);
var root_2469 = add_locations(from_svg(`<desc> </desc>`), MapPinSolid[FILENAME], [[44, 4]]);
var root469 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 9a7 7 0 1 1 8 6.93V21a1 1 0 1 1-2 0v-5.07A7.001 7.001 0 0 1 5 9Zm5.94-1.06A1.5 1.5 0 0 1 12 7.5a1 1 0 1 0 0-2A3.5 3.5 0 0 0 8.5 9a1 1 0 0 0 2 0c0-.398.158-.78.44-1.06Z" clip-rule="evenodd"></path></svg>`), MapPinSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MapPinSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MapPinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root469();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1469();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MapPinSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2469();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MapPinSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MapPinSolid = hmr(MapPinSolid, () => MapPinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinSolid[HMR].source;
    set(MapPinSolid[HMR].source, module.default[HMR].original);
  });
}
var MapPinSolid_default = MapPinSolid;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassCitrusOutline.svelte
MartiniGlassCitrusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassCitrusOutline.svelte";
var root_1470 = add_locations(from_svg(`<title> </title>`), MartiniGlassCitrusOutline[FILENAME], [[43, 4]]);
var root_2470 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassCitrusOutline[FILENAME], [[46, 4]]);
var root470 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10 14 6-6H4l6 6Zm0 0v6m-3.00004 0H13m.0354-12C13.0121 7.8367 13 7.66976 13 7.5 13 5.567 14.567 4 16.5 4S20 5.567 20 7.5 18.433 11 16.5 11c-.9537 0-1.8183-.3814-2.4495-1"></path></svg>`), MartiniGlassCitrusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MartiniGlassCitrusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassCitrusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root470();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1470();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassCitrusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2470();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassCitrusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassCitrusOutline = hmr(MartiniGlassCitrusOutline, () => MartiniGlassCitrusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassCitrusOutline[HMR].source;
    set(MartiniGlassCitrusOutline[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassCitrusOutline_default = MartiniGlassCitrusOutline;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassCitrusSolid.svelte
MartiniGlassCitrusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassCitrusSolid.svelte";
var root_1471 = add_locations(from_svg(`<title> </title>`), MartiniGlassCitrusSolid[FILENAME], [[41, 4]]);
var root_2471 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassCitrusSolid[FILENAME], [[44, 4]]);
var root471 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4.00003 7h8.02747c.2487-2.24998 2.1562-4 4.4725-4C18.9853 3 21 5.01472 21 7.5S18.9853 12 16.5 12c-.8801 0-1.702-.2533-2.3956-.6902L11 14.4142V19h2c.5523 0 1 .4477 1 1s-.4477 1-1 1H6.99999c-.55228 0-1-.4477-1-1s.44772-1 1-1h2.00004v-4.5858L3.29292 8.70711c-.286-.286-.37155-.71612-.21677-1.08979C3.23093 7.24364 3.59557 7 4.00003 7ZM16 7h-1.95c.2316-1.14112 1.2405-2 2.45-2C17.8807 5 19 6.11929 19 7.5S17.8807 10 16.5 10c-.3228 0-.6308-.06086-.9138-.17198l1.1209-1.12091c.286-.286.3716-.71612.2168-1.08979C16.7691 7.24364 16.4045 7 16 7Z" clip-rule="evenodd"></path></svg>`), MartiniGlassCitrusSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MartiniGlassCitrusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassCitrusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root471();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1471();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassCitrusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2471();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassCitrusSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassCitrusSolid = hmr(MartiniGlassCitrusSolid, () => MartiniGlassCitrusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassCitrusSolid[HMR].source;
    set(MartiniGlassCitrusSolid[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassCitrusSolid_default = MartiniGlassCitrusSolid;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassEmptyOutline.svelte
MartiniGlassEmptyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassEmptyOutline.svelte";
var root_1472 = add_locations(from_svg(`<title> </title>`), MartiniGlassEmptyOutline[FILENAME], [[43, 4]]);
var root_2472 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassEmptyOutline[FILENAME], [[46, 4]]);
var root472 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m12 12 7-8H5l7 8Zm0 0v8m-3 0h6"></path></svg>`), MartiniGlassEmptyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MartiniGlassEmptyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassEmptyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root472();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1472();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassEmptyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2472();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassEmptyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassEmptyOutline = hmr(MartiniGlassEmptyOutline, () => MartiniGlassEmptyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassEmptyOutline[HMR].source;
    set(MartiniGlassEmptyOutline[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassEmptyOutline_default = MartiniGlassEmptyOutline;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassEmptySolid.svelte
MartiniGlassEmptySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassEmptySolid.svelte";
var root_1473 = add_locations(from_svg(`<title> </title>`), MartiniGlassEmptySolid[FILENAME], [[41, 4]]);
var root_2473 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassEmptySolid[FILENAME], [[44, 4]]);
var root473 = add_locations(from_svg(`<svg><!><!><path d="M5.00002 3c-.39238 0-.7485.22947-.91064.58678-.16213.35732-.10032.77643.15806 1.07172L11 12.3757V19H9.00002c-.55229 0-1 .4477-1 1s.44771 1 1 1H15c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2v-6.6243l6.7526-7.7172c.2584-.29529.3202-.7144.158-1.07172C19.7485 3.22947 19.3924 3 19 3H5.00002Z"></path></svg>`), MartiniGlassEmptySolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MartiniGlassEmptySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassEmptySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root473();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1473();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassEmptySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2473();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassEmptySolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassEmptySolid = hmr(MartiniGlassEmptySolid, () => MartiniGlassEmptySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassEmptySolid[HMR].source;
    set(MartiniGlassEmptySolid[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassEmptySolid_default = MartiniGlassEmptySolid;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassOutline.svelte
MartiniGlassOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassOutline.svelte";
var root_1474 = add_locations(from_svg(`<title> </title>`), MartiniGlassOutline[FILENAME], [[43, 4]]);
var root_2474 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassOutline[FILENAME], [[46, 4]]);
var root474 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m12 12 7-8H5l7 8Zm0 0v8m-3 0h6M8.54939 8h6.95051"></path></svg>`), MartiniGlassOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MartiniGlassOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root474();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1474();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2474();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassOutline = hmr(MartiniGlassOutline, () => MartiniGlassOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassOutline[HMR].source;
    set(MartiniGlassOutline[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassOutline_default = MartiniGlassOutline;

// node_modules/flowbite-svelte-icons/dist/MartiniGlassSolid.svelte
MartiniGlassSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MartiniGlassSolid.svelte";
var root_1475 = add_locations(from_svg(`<title> </title>`), MartiniGlassSolid[FILENAME], [[41, 4]]);
var root_2475 = add_locations(from_svg(`<desc> </desc>`), MartiniGlassSolid[FILENAME], [[44, 4]]);
var root475 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.00002 3c-.39238 0-.7485.22947-.91064.58678-.16213.35732-.10032.77643.15806 1.07172L11 12.3757V19H9.00002c-.55229 0-1 .4477-1 1s.44771 1 1 1H15c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2v-6.6243l6.7526-7.71719c.2584-.29529.3202-.71441.1581-1.07172C19.7485 3.22947 19.3924 3 19 3H5.00002ZM15.0462 7H8.95378l-1.75-2h9.59242l-1.75 2Z" clip-rule="evenodd"></path></svg>`), MartiniGlassSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MartiniGlassSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MartiniGlassSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root475();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1475();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MartiniGlassSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2475();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MartiniGlassSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MartiniGlassSolid = hmr(MartiniGlassSolid, () => MartiniGlassSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MartiniGlassSolid[HMR].source;
    set(MartiniGlassSolid[HMR].source, module.default[HMR].original);
  });
}
var MartiniGlassSolid_default = MartiniGlassSolid;

// node_modules/flowbite-svelte-icons/dist/MastercardSolid.svelte
MastercardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MastercardSolid.svelte";
var root_1476 = add_locations(from_svg(`<title> </title>`), MastercardSolid[FILENAME], [[41, 4]]);
var root_2476 = add_locations(from_svg(`<desc> </desc>`), MastercardSolid[FILENAME], [[44, 4]]);
var root476 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm5.178 12.137a4.137 4.137 0 1 1 1.036-8.144A6.113 6.113 0 0 0 8.726 12c0 1.531.56 2.931 1.488 4.006a4.114 4.114 0 0 1-1.036.131ZM10.726 12c0-1.183.496-2.252 1.294-3.006A4.125 4.125 0 0 1 13.315 12a4.126 4.126 0 0 1-1.294 3.006A4.126 4.126 0 0 1 10.726 12Zm4.59 0a6.11 6.11 0 0 1-1.489 4.006 4.137 4.137 0 1 0 0-8.013A6.113 6.113 0 0 1 15.315 12Z" clip-rule="evenodd"></path></svg>`), MastercardSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MastercardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MastercardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root476();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1476();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MastercardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2476();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MastercardSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MastercardSolid = hmr(MastercardSolid, () => MastercardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MastercardSolid[HMR].source;
    set(MastercardSolid[HMR].source, module.default[HMR].original);
  });
}
var MastercardSolid_default = MastercardSolid;

// node_modules/flowbite-svelte-icons/dist/MergeCellsOutline.svelte
MergeCellsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MergeCellsOutline.svelte";
var root_1477 = add_locations(from_svg(`<title> </title>`), MergeCellsOutline[FILENAME], [[43, 4]]);
var root_2477 = add_locations(from_svg(`<desc> </desc>`), MergeCellsOutline[FILENAME], [[46, 4]]);
var root477 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 18v2H4V4h6v2m4 12v2h6V4h-6v2m-6.49543 8.4954L10 12m0 0L7.50457 9.50457M10 12H4.05191m12.50199 2.5539L14 12m0 0 2.5539-2.55392M14 12h5.8319"></path></svg>`), MergeCellsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MergeCellsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MergeCellsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root477();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1477();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MergeCellsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2477();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MergeCellsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MergeCellsOutline = hmr(MergeCellsOutline, () => MergeCellsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MergeCellsOutline[HMR].source;
    set(MergeCellsOutline[HMR].source, module.default[HMR].original);
  });
}
var MergeCellsOutline_default = MergeCellsOutline;

// node_modules/flowbite-svelte-icons/dist/MergeOrSplitOutline.svelte
MergeOrSplitOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MergeOrSplitOutline.svelte";
var root_1478 = add_locations(from_svg(`<title> </title>`), MergeOrSplitOutline[FILENAME], [[43, 4]]);
var root_2478 = add_locations(from_svg(`<desc> </desc>`), MergeOrSplitOutline[FILENAME], [[46, 4]]);
var root478 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5045 14.4954 21 12m0 0-2.4955-2.49542M21 12h-5.9481m-9.49798 2.5539L3 12m0 0 2.55392-2.55392M3 12h5.83192m.16807 7V5H15v14H8.99999Z"></path></svg>`), MergeOrSplitOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MergeOrSplitOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MergeOrSplitOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root478();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1478();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MergeOrSplitOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2478();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MergeOrSplitOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MergeOrSplitOutline = hmr(MergeOrSplitOutline, () => MergeOrSplitOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MergeOrSplitOutline[HMR].source;
    set(MergeOrSplitOutline[HMR].source, module.default[HMR].original);
  });
}
var MergeOrSplitOutline_default = MergeOrSplitOutline;

// node_modules/flowbite-svelte-icons/dist/MessageCaptionOutline.svelte
MessageCaptionOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageCaptionOutline.svelte";
var root_1479 = add_locations(from_svg(`<title> </title>`), MessageCaptionOutline[FILENAME], [[43, 4]]);
var root_2479 = add_locations(from_svg(`<desc> </desc>`), MessageCaptionOutline[FILENAME], [[46, 4]]);
var root479 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 9h5m3 0h2M7 12h2m3 0h5M5 5h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-6.616a1 1 0 0 0-.67.257l-2.88 2.592A.5.5 0 0 1 8 18.477V17a1 1 0 0 0-1-1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), MessageCaptionOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MessageCaptionOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessageCaptionOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root479();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1479();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessageCaptionOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2479();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessageCaptionOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessageCaptionOutline = hmr(MessageCaptionOutline, () => MessageCaptionOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageCaptionOutline[HMR].source;
    set(MessageCaptionOutline[HMR].source, module.default[HMR].original);
  });
}
var MessageCaptionOutline_default = MessageCaptionOutline;

// node_modules/flowbite-svelte-icons/dist/MessageCaptionSolid.svelte
MessageCaptionSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageCaptionSolid.svelte";
var root_1480 = add_locations(from_svg(`<title> </title>`), MessageCaptionSolid[FILENAME], [[41, 4]]);
var root_2480 = add_locations(from_svg(`<desc> </desc>`), MessageCaptionSolid[FILENAME], [[44, 4]]);
var root480 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 6a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-6.616l-2.88 2.592C8.537 20.461 7 19.776 7 18.477V17H5a2 2 0 0 1-2-2V6Zm4 2a1 1 0 0 0 0 2h5a1 1 0 1 0 0-2H7Zm8 0a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2Zm-8 3a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2H7Zm5 0a1 1 0 1 0 0 2h5a1 1 0 1 0 0-2h-5Z" clip-rule="evenodd"></path></svg>`), MessageCaptionSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MessageCaptionSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessageCaptionSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root480();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1480();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessageCaptionSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2480();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessageCaptionSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessageCaptionSolid = hmr(MessageCaptionSolid, () => MessageCaptionSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageCaptionSolid[HMR].source;
    set(MessageCaptionSolid[HMR].source, module.default[HMR].original);
  });
}
var MessageCaptionSolid_default = MessageCaptionSolid;

// node_modules/flowbite-svelte-icons/dist/MessageDotsOutline.svelte
MessageDotsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageDotsOutline.svelte";
var root_1481 = add_locations(from_svg(`<title> </title>`), MessageDotsOutline[FILENAME], [[43, 4]]);
var root_2481 = add_locations(from_svg(`<desc> </desc>`), MessageDotsOutline[FILENAME], [[46, 4]]);
var root481 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 10.5h.01m-4.01 0h.01M8 10.5h.01M5 5h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-6.6a1 1 0 0 0-.69.275l-2.866 2.723A.5.5 0 0 1 8 18.635V17a1 1 0 0 0-1-1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), MessageDotsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MessageDotsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessageDotsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root481();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1481();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessageDotsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2481();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessageDotsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessageDotsOutline = hmr(MessageDotsOutline, () => MessageDotsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageDotsOutline[HMR].source;
    set(MessageDotsOutline[HMR].source, module.default[HMR].original);
  });
}
var MessageDotsOutline_default = MessageDotsOutline;

// node_modules/flowbite-svelte-icons/dist/MessageDotsSolid.svelte
MessageDotsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageDotsSolid.svelte";
var root_1482 = add_locations(from_svg(`<title> </title>`), MessageDotsSolid[FILENAME], [[41, 4]]);
var root_2482 = add_locations(from_svg(`<desc> </desc>`), MessageDotsSolid[FILENAME], [[44, 4]]);
var root482 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 5.983C3 4.888 3.895 4 5 4h14c1.105 0 2 .888 2 1.983v8.923a1.992 1.992 0 0 1-2 1.983h-6.6l-2.867 2.7c-.955.899-2.533.228-2.533-1.08v-1.62H5c-1.105 0-2-.888-2-1.983V5.983Zm5.706 3.809a1 1 0 1 0-1.412 1.417 1 1 0 1 0 1.412-1.417Zm2.585.002a1 1 0 1 1 .003 1.414 1 1 0 0 1-.003-1.414Zm5.415-.002a1 1 0 1 0-1.412 1.417 1 1 0 1 0 1.412-1.417Z" clip-rule="evenodd"></path></svg>`), MessageDotsSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MessageDotsSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessageDotsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root482();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1482();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessageDotsSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2482();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessageDotsSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessageDotsSolid = hmr(MessageDotsSolid, () => MessageDotsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageDotsSolid[HMR].source;
    set(MessageDotsSolid[HMR].source, module.default[HMR].original);
  });
}
var MessageDotsSolid_default = MessageDotsSolid;

// node_modules/flowbite-svelte-icons/dist/MessagesOutline.svelte
MessagesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessagesOutline.svelte";
var root_1483 = add_locations(from_svg(`<title> </title>`), MessagesOutline[FILENAME], [[43, 4]]);
var root_2483 = add_locations(from_svg(`<desc> </desc>`), MessagesOutline[FILENAME], [[46, 4]]);
var root483 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 17h6l3 3v-3h2V9h-2M4 4h11v8H9l-3 3v-3H4V4Z"></path></svg>`), MessagesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MessagesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessagesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root483();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1483();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessagesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2483();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessagesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessagesOutline = hmr(MessagesOutline, () => MessagesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessagesOutline[HMR].source;
    set(MessagesOutline[HMR].source, module.default[HMR].original);
  });
}
var MessagesOutline_default = MessagesOutline;

// node_modules/flowbite-svelte-icons/dist/MessagesSolid.svelte
MessagesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessagesSolid.svelte";
var root_1484 = add_locations(from_svg(`<title> </title>`), MessagesSolid[FILENAME], [[41, 4]]);
var root_2484 = add_locations(from_svg(`<desc> </desc>`), MessagesSolid[FILENAME], [[44, 4]]);
var root484 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h1v2a1 1 0 0 0 1.707.707L9.414 13H15a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M8.023 17.215c.033-.03.066-.062.098-.094L10.243 15H15a3 3 0 0 0 3-3V8h2a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1h-1v2a1 1 0 0 1-1.707.707L14.586 18H9a1 1 0 0 1-.977-.785Z" clip-rule="evenodd"></path></svg>`), MessagesSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function MessagesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MessagesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root484();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1484();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MessagesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2484();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MessagesSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MessagesSolid = hmr(MessagesSolid, () => MessagesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessagesSolid[HMR].source;
    set(MessagesSolid[HMR].source, module.default[HMR].original);
  });
}
var MessagesSolid_default = MessagesSolid;

// node_modules/flowbite-svelte-icons/dist/MicrophoneOutline.svelte
MicrophoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneOutline.svelte";
var root_1485 = add_locations(from_svg(`<title> </title>`), MicrophoneOutline[FILENAME], [[43, 4]]);
var root_2485 = add_locations(from_svg(`<desc> </desc>`), MicrophoneOutline[FILENAME], [[46, 4]]);
var root485 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 9v3a5.006 5.006 0 0 1-5 5h-4a5.006 5.006 0 0 1-5-5V9m7 9v3m-3 0h6M11 3h2a3 3 0 0 1 3 3v5a3 3 0 0 1-3 3h-2a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3Z"></path></svg>`), MicrophoneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MicrophoneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicrophoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root485();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1485();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicrophoneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2485();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicrophoneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicrophoneOutline = hmr(MicrophoneOutline, () => MicrophoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneOutline[HMR].source;
    set(MicrophoneOutline[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneOutline_default = MicrophoneOutline;

// node_modules/flowbite-svelte-icons/dist/MicrophoneSlashOutline.svelte
MicrophoneSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSlashOutline.svelte";
var root_1486 = add_locations(from_svg(`<title> </title>`), MicrophoneSlashOutline[FILENAME], [[42, 4]]);
var root_2486 = add_locations(from_svg(`<desc> </desc>`), MicrophoneSlashOutline[FILENAME], [[45, 4]]);
var root486 = add_locations(from_svg(`<svg><!><!><path d="M19.97 9.012a1 1 0 1 0-2 0h2Zm-1 2.988 1 .001V12h-1Zm-8.962 4.98-.001 1h.001v-1Zm-3.52-1.46.708-.708-.707.707ZM5.029 12h-1v.001l1-.001Zm3.984 7.963a1 1 0 1 0 0 2v-2Zm5.975 2a1 1 0 0 0 0-2v2ZM7.017 8.017a1 1 0 1 0 2 0h-2Zm6.641 4.862a1 1 0 1 0 .667 1.886l-.667-1.886Zm-7.63-2.87a1 1 0 1 0-2 0h2Zm9.953 5.435a1 1 0 1 0 1 1.731l-1-1.731ZM12 16.979h1a1 1 0 0 0-1-1v1ZM5.736 4.322a1 1 0 0 0-1.414 1.414l1.414-1.414Zm12.528 15.356a1 1 0 0 0 1.414-1.414l-1.414 1.414ZM17.97 9.012V12h2V9.012h-2Zm0 2.987a3.985 3.985 0 0 1-1.168 2.813l1.415 1.414a5.985 5.985 0 0 0 1.753-4.225l-2-.002Zm-7.962 3.98a3.985 3.985 0 0 1-2.813-1.167l-1.414 1.414a5.985 5.985 0 0 0 4.225 1.753l.002-2Zm-2.813-1.167a3.985 3.985 0 0 1-1.167-2.813l-2 .002a5.985 5.985 0 0 0 1.753 4.225l1.414-1.414Zm3.808-10.775h1.992v-2h-1.992v2Zm1.992 0c1.097 0 1.987.89 1.987 1.988h2a3.988 3.988 0 0 0-3.987-3.988v2Zm1.987 1.988v4.98h2v-4.98h-2Zm-5.967 0c0-1.098.89-1.988 1.988-1.988v-2a3.988 3.988 0 0 0-3.988 3.988h2Zm-.004 15.938H12v-2H9.012v2Zm2.988 0h2.987v-2H12v2ZM9.016 8.017V6.025h-2v1.992h2Zm5.967 2.987a1.99 1.99 0 0 1-1.325 1.875l.667 1.886a3.989 3.989 0 0 0 2.658-3.76h-2ZM6.03 12v-1.992h-2V12h2Zm10.774 2.812a3.92 3.92 0 0 1-.823.632l1.002 1.731a5.982 5.982 0 0 0 1.236-.949l-1.415-1.414ZM4.322 5.736l13.942 13.942 1.414-1.414L5.736 4.322 4.322 5.736ZM12 15.98h-1.992v2H12v-2Zm-1 1v3.984h2V16.98h-2Z"></path></svg>`), MicrophoneSlashOutline[FILENAME], [[30, 0, [[47, 2]]]]);
function MicrophoneSlashOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicrophoneSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root486();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1486();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicrophoneSlashOutline,
      41,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2486();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicrophoneSlashOutline,
      44,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicrophoneSlashOutline = hmr(MicrophoneSlashOutline, () => MicrophoneSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSlashOutline[HMR].source;
    set(MicrophoneSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSlashOutline_default = MicrophoneSlashOutline;

// node_modules/flowbite-svelte-icons/dist/MicrophoneSlashSolid.svelte
MicrophoneSlashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSlashSolid.svelte";
var root_1487 = add_locations(from_svg(`<title> </title>`), MicrophoneSlashSolid[FILENAME], [[41, 4]]);
var root_2487 = add_locations(from_svg(`<desc> </desc>`), MicrophoneSlashSolid[FILENAME], [[44, 4]]);
var root487 = add_locations(from_svg(`<svg><!><!><path d="m15.506 14.097.994.995A3.989 3.989 0 0 0 17.975 12V9.011a.996.996 0 0 1 1.992 0v2.99a5.981 5.981 0 0 1-2.054 4.503l1.762 1.762a.996.996 0 1 1-1.408 1.408L4.325 5.733a.996.996 0 0 1 1.408-1.408L7.04 5.632a3.984 3.984 0 0 1 3.964-3.59h1.992c2.2 0 3.983 1.783 3.983 3.983v4.98a3.975 3.975 0 0 1-1.473 3.092ZM4.033 10.008a.996.996 0 1 1 1.992 0V12a3.99 3.99 0 0 0 3.984 3.984H12c.55 0 .996.446.996.996v2.988h1.992a.996.996 0 0 1 0 1.992H9.012a.996.996 0 0 1 0-1.992h1.992v-1.992h-.997a5.981 5.981 0 0 1-5.974-5.974v-1.993Z"></path></svg>`), MicrophoneSlashSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MicrophoneSlashSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicrophoneSlashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root487();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1487();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicrophoneSlashSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2487();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicrophoneSlashSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicrophoneSlashSolid = hmr(MicrophoneSlashSolid, () => MicrophoneSlashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSlashSolid[HMR].source;
    set(MicrophoneSlashSolid[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSlashSolid_default = MicrophoneSlashSolid;

// node_modules/flowbite-svelte-icons/dist/MicrophoneSolid.svelte
MicrophoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSolid.svelte";
var root_1488 = add_locations(from_svg(`<title> </title>`), MicrophoneSolid[FILENAME], [[41, 4]]);
var root_2488 = add_locations(from_svg(`<desc> </desc>`), MicrophoneSolid[FILENAME], [[44, 4]]);
var root488 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 8a1 1 0 0 1 1 1v3a4.006 4.006 0 0 0 4 4h4a4.006 4.006 0 0 0 4-4V9a1 1 0 1 1 2 0v3.001A6.006 6.006 0 0 1 14.001 18H13v2h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2v-2H9.999A6.006 6.006 0 0 1 4 12.001V9a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M7 6a4 4 0 0 1 4-4h2a4 4 0 0 1 4 4v5a4 4 0 0 1-4 4h-2a4 4 0 0 1-4-4V6Z"></path></svg>`), MicrophoneSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function MicrophoneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicrophoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root488();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1488();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicrophoneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2488();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicrophoneSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicrophoneSolid = hmr(MicrophoneSolid, () => MicrophoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSolid[HMR].source;
    set(MicrophoneSolid[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSolid_default = MicrophoneSolid;

// node_modules/flowbite-svelte-icons/dist/MicroscopeOutline.svelte
MicroscopeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicroscopeOutline.svelte";
var root_1489 = add_locations(from_svg(`<title> </title>`), MicroscopeOutline[FILENAME], [[43, 4]]);
var root_2489 = add_locations(from_svg(`<desc> </desc>`), MicroscopeOutline[FILENAME], [[46, 4]]);
var root489 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.6427 21h14M16.2928 9c.8398.95515 1.3499 2.213 1.3499 3.5912 0 2.9872-2.3962 5.4088-5.3521 5.4088-1.9895 0-3.72545-1.097-4.6479-2.7251m-2-.2749h6m.4369-4.4369L10.6427 12m5.8092-5.76698 2.1554-2.15534M17.5296 3l2.1553 2.15534M10.6427 18v3m4-3v3m.7315-15.84464-4.3107 4.31068 2.1554 2.15536 4.3107-4.3107-2.1554-2.15534Z"></path></svg>`), MicroscopeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MicroscopeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicroscopeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root489();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1489();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicroscopeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2489();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicroscopeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicroscopeOutline = hmr(MicroscopeOutline, () => MicroscopeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicroscopeOutline[HMR].source;
    set(MicroscopeOutline[HMR].source, module.default[HMR].original);
  });
}
var MicroscopeOutline_default = MicroscopeOutline;

// node_modules/flowbite-svelte-icons/dist/MicroscopeSolid.svelte
MicroscopeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicroscopeSolid.svelte";
var root_1490 = add_locations(from_svg(`<title> </title>`), MicroscopeSolid[FILENAME], [[41, 4]]);
var root_2490 = add_locations(from_svg(`<desc> </desc>`), MicroscopeSolid[FILENAME], [[44, 4]]);
var root490 = add_locations(from_svg(`<svg><!><!><path d="m17.9646 5.49185.3705.37054c.3906.39052 1.0237.39052 1.4142 0 .3906-.39053.3906-1.02369 0-1.41422L17.594 2.29283c-.3905-.39052-1.0237-.39052-1.4142 0-.3905.39053-.3905 1.02369 0 1.41422l.3706.37059-.7412.74118-.3706-.37059c-.3905-.39053-1.0237-.39053-1.4142 0L9.71372 8.75891c-.39053.39053-.39053 1.02369 0 1.41419l.34948.3495-.77031.7703c-.39053.3905-.39053 1.0237 0 1.4142.39052.3905 1.02371.3905 1.41421 0l.7703-.7703.3917.3917c.3905.3905 1.0236.3905 1.4142 0l2.0628-2.0629c.4145.6745.6539 1.4706.6539 2.3256 0 2.4448-1.9584 4.4087-4.3521 4.4087-1.0458 0-2.00787-.3737-2.76051-.9999H11c.5523 0 1-.4477 1-1s-.4477-1-1-1H5c-.55228 0-1 .4477-1 1s.44772 1 1 1h1.26803C6.92225 17.0489 7.8715 17.8952 9 18.4182V20H5c-.55228 0-1 .4477-1 1s.44772 1 1 1h14c.5523 0 1-.4477 1-1s-.4477-1-1-1h-4v-1.9637c1.8034-1.1328 3-3.1517 3-5.4451 0-1.4061-.4498-2.70897-1.2126-3.76687l.8066-.80655c.3905-.39052.3905-1.02369 0-1.41421l-.3706-.37054.7412-.74118Z"></path></svg>`), MicroscopeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MicroscopeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MicroscopeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root490();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1490();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MicroscopeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2490();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MicroscopeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MicroscopeSolid = hmr(MicroscopeSolid, () => MicroscopeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicroscopeSolid[HMR].source;
    set(MicroscopeSolid[HMR].source, module.default[HMR].original);
  });
}
var MicroscopeSolid_default = MicroscopeSolid;

// node_modules/flowbite-svelte-icons/dist/MinimizeOutline.svelte
MinimizeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MinimizeOutline.svelte";
var root_1491 = add_locations(from_svg(`<title> </title>`), MinimizeOutline[FILENAME], [[43, 4]]);
var root_2491 = add_locations(from_svg(`<desc> </desc>`), MinimizeOutline[FILENAME], [[46, 4]]);
var root491 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 9h4m0 0V5m0 4L4 4m15 5h-4m0 0V5m0 4 5-5M5 15h4m0 0v4m0-4-5 5m15-5h-4m0 0v4m0-4 5 5"></path></svg>`), MinimizeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MinimizeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MinimizeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root491();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1491();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MinimizeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2491();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MinimizeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MinimizeOutline = hmr(MinimizeOutline, () => MinimizeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MinimizeOutline[HMR].source;
    set(MinimizeOutline[HMR].source, module.default[HMR].original);
  });
}
var MinimizeOutline_default = MinimizeOutline;

// node_modules/flowbite-svelte-icons/dist/MinusOutline.svelte
MinusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MinusOutline.svelte";
var root_1492 = add_locations(from_svg(`<title> </title>`), MinusOutline[FILENAME], [[43, 4]]);
var root_2492 = add_locations(from_svg(`<desc> </desc>`), MinusOutline[FILENAME], [[46, 4]]);
var root492 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14"></path></svg>`), MinusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MinusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MinusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root492();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1492();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MinusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2492();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MinusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MinusOutline = hmr(MinusOutline, () => MinusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MinusOutline[HMR].source;
    set(MinusOutline[HMR].source, module.default[HMR].original);
  });
}
var MinusOutline_default = MinusOutline;

// node_modules/flowbite-svelte-icons/dist/MissedCallOutline.svelte
MissedCallOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MissedCallOutline.svelte";
var root_1493 = add_locations(from_svg(`<title> </title>`), MissedCallOutline[FILENAME], [[43, 4]]);
var root_2493 = add_locations(from_svg(`<desc> </desc>`), MissedCallOutline[FILENAME], [[46, 4]]);
var root493 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17.0896 13.371 1.1431 1.1439c.1745.1461.3148.3287.4111.5349.0962.2063.1461.4312.1461.6588 0 .2276-.0499.4525-.1461.6587-.0963.2063-.4729.6251-.6473.7712-3.1173 3.1211-6.7739 1.706-9.90477-1.4254-3.13087-3.1313-4.54323-6.7896-1.41066-9.90139.62706-.61925 1.71351-1.14182 2.61843-.23626l1.1911 1.19193c1.1911 1.19194.3562 1.93533-.4926 2.80371-.92477.92481-.65643 1.72741 0 2.38391l1.8713 1.8725c.3159.3161.7443.4936 1.191.4936.4468 0 .8752-.1775 1.1911-.4936.8624-.8261 1.6952-1.6004 2.8382-.4565Zm-2.2152-4.39103 2.1348-2.13485m0 0 2.1597-1.90738m-2.1597 1.90738 2.1597 2.15076m-2.1597-2.15076-2.1348-1.90738"></path></svg>`), MissedCallOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MissedCallOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MissedCallOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root493();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1493();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MissedCallOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2493();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MissedCallOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MissedCallOutline = hmr(MissedCallOutline, () => MissedCallOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MissedCallOutline[HMR].source;
    set(MissedCallOutline[HMR].source, module.default[HMR].original);
  });
}
var MissedCallOutline_default = MissedCallOutline;

// node_modules/flowbite-svelte-icons/dist/MissedCallSolid.svelte
MissedCallSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MissedCallSolid.svelte";
var root_1494 = add_locations(from_svg(`<title> </title>`), MissedCallSolid[FILENAME], [[41, 4]]);
var root_2494 = add_locations(from_svg(`<desc> </desc>`), MissedCallSolid[FILENAME], [[44, 4]]);
var root494 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14.1673 10.687c-.3905-.3905-.3905-1.02367 0-1.41419l1.3869-1.38683-1.346-1.20257c-.4119-.36796-.4474-1.00013-.0795-1.41198.368-.41184 1.0002-.44742 1.412-.07945l1.4724 1.31553 1.4939-1.31935c.414-.36559 1.0459-.32639 1.4115.08757.3656.41395.3264 1.0459-.0876 1.4115l-1.3605 1.2016 1.4042 1.39843c.3913.38971.3927 1.02284.0029 1.41424-.3897.3913-1.0228.3926-1.4142.0029l-1.4525-1.44658-1.4293 1.42918c-.3905.3905-1.0236.3905-1.4142 0Z" clip-rule="evenodd"></path><path d="M7.97825 5.00001c-.3729 0-.74128.08169-1.07926.23933-.32394.1511-.61243.36846-.84696.63787-1.81892 1.82188-2.35302 3.87423-1.89899 5.93669.43916 1.9949 1.77747 3.8929 3.45642 5.572 1.67897 1.6791 3.57614 3.0177 5.57034 3.4591 2.0612.4563 4.1141-.0726 5.9396-1.8853.2705-.2348.4888-.524.6405-.8489.1581-.3387.2401-.708.2401-1.0819 0-.3739-.082-.7432-.2401-1.0819-.1516-.3247-.3696-.6136-.6398-.8483l-1.2098-1.2106c-.5043-.504-1.1879-.7872-1.9007-.7872-.7128 0-1.3968.2835-1.9011.7876l-.6178.6182c-.1512.1512-.3563.2362-.5701.2362-.2138 0-.4189-.085-.5701-.2363l-1.8534-1.8545c-.1511-.1513-.2361-.3565-.2361-.5704 0-.214.085-.4192.2362-.5705l.6181-.6185c.5037-.5046.7867-1.18867.7867-1.9019 0-.71324-.2833-1.39767-.7871-1.90229L9.90499 5.87782c-.23462-.2697-.5233-.48727-.84749-.63848-.33798-.15764-.70636-.23933-1.07925-.23933Z"></path></svg>`), MissedCallSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function MissedCallSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MissedCallSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root494();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1494();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MissedCallSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2494();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MissedCallSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MissedCallSolid = hmr(MissedCallSolid, () => MissedCallSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MissedCallSolid[HMR].source;
    set(MissedCallSolid[HMR].source, module.default[HMR].original);
  });
}
var MissedCallSolid_default = MissedCallSolid;

// node_modules/flowbite-svelte-icons/dist/MobilePhoneOutline.svelte
MobilePhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MobilePhoneOutline.svelte";
var root_1495 = add_locations(from_svg(`<title> </title>`), MobilePhoneOutline[FILENAME], [[43, 4]]);
var root_2495 = add_locations(from_svg(`<desc> </desc>`), MobilePhoneOutline[FILENAME], [[46, 4]]);
var root495 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 15h12M6 6h12m-6 12h.01M7 21h10a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1Z"></path></svg>`), MobilePhoneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MobilePhoneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MobilePhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root495();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1495();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MobilePhoneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2495();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MobilePhoneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MobilePhoneOutline = hmr(MobilePhoneOutline, () => MobilePhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MobilePhoneOutline[HMR].source;
    set(MobilePhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var MobilePhoneOutline_default = MobilePhoneOutline;

// node_modules/flowbite-svelte-icons/dist/MobilePhoneSolid.svelte
MobilePhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MobilePhoneSolid.svelte";
var root_1496 = add_locations(from_svg(`<title> </title>`), MobilePhoneSolid[FILENAME], [[41, 4]]);
var root_2496 = add_locations(from_svg(`<desc> </desc>`), MobilePhoneSolid[FILENAME], [[44, 4]]);
var root496 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4Zm12 12V5H7v11h10Zm-5 1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), MobilePhoneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MobilePhoneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MobilePhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root496();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1496();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MobilePhoneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2496();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MobilePhoneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MobilePhoneSolid = hmr(MobilePhoneSolid, () => MobilePhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MobilePhoneSolid[HMR].source;
    set(MobilePhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var MobilePhoneSolid_default = MobilePhoneSolid;

// node_modules/flowbite-svelte-icons/dist/MongoDbSolid.svelte
MongoDbSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MongoDbSolid.svelte";
var root_1497 = add_locations(from_svg(`<title> </title>`), MongoDbSolid[FILENAME], [[41, 4]]);
var root_2497 = add_locations(from_svg(`<desc> </desc>`), MongoDbSolid[FILENAME], [[44, 4]]);
var root497 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7.29395 11.8039c0-3.96638 2.13959-6.41723 3.53335-8.01378.6733-.7712 1.1725-1.34306 1.1725-1.79012 0 .44706.4993 1.01892 1.1725 1.79013 1.3938 1.59654 3.5334 4.04739 3.5334 8.01377 0 4.3266-2.7501 6.9507-4.0764 7.7654L12.3701 22h-.7071l-.2906-2.4295c-1.3255-.8132-4.07845-3.4378-4.07845-7.7666Zm4.06395 6.7007.6419-9.44578.649 9.44578-.649.7503-.6419-.7503Z" clip-rule="evenodd"></path></svg>`), MongoDbSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MongoDbSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MongoDbSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root497();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1497();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MongoDbSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2497();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MongoDbSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MongoDbSolid = hmr(MongoDbSolid, () => MongoDbSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MongoDbSolid[HMR].source;
    set(MongoDbSolid[HMR].source, module.default[HMR].original);
  });
}
var MongoDbSolid_default = MongoDbSolid;

// node_modules/flowbite-svelte-icons/dist/MoonOutline.svelte
MoonOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonOutline.svelte";
var root_1498 = add_locations(from_svg(`<title> </title>`), MoonOutline[FILENAME], [[43, 4]]);
var root_2498 = add_locations(from_svg(`<desc> </desc>`), MoonOutline[FILENAME], [[46, 4]]);
var root498 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 0 1-.5-17.986V3c-.354.966-.5 1.911-.5 3a9 9 0 0 0 9 9c.239 0 .254.018.488 0A9.004 9.004 0 0 1 12 21Z"></path></svg>`), MoonOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MoonOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MoonOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root498();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1498();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MoonOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2498();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MoonOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MoonOutline = hmr(MoonOutline, () => MoonOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonOutline[HMR].source;
    set(MoonOutline[HMR].source, module.default[HMR].original);
  });
}
var MoonOutline_default = MoonOutline;

// node_modules/flowbite-svelte-icons/dist/MoonPlusOutline.svelte
MoonPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonPlusOutline.svelte";
var root_1499 = add_locations(from_svg(`<title> </title>`), MoonPlusOutline[FILENAME], [[43, 4]]);
var root_2499 = add_locations(from_svg(`<desc> </desc>`), MoonPlusOutline[FILENAME], [[46, 4]]);
var root499 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 5v3m0 0v3m0-3h-3m3 0h3m-3.3556 7.0913c-1.6389 0-2.58-.2487-3.7085-.9576-1.1285-.709-2.0191-1.7196-2.5631-2.9086-.54402-1.1891-.71806-2.50523-.5009-3.78809.2172-1.28287.8161-2.47705 1.724-3.43701-1.3427.20491-2.60689.74436-3.66765 1.56511-1.06077.82074-1.88149 1.8944-2.38113 3.11496-.49965 1.22056-.66094 2.54583-.46795 3.84493.19298 1.2992.73357 2.5273 1.56839 3.563.83482 1.0358 1.93501 1.8435 3.19194 2.3433 1.2569.4999 2.6272.6745 3.9754.5068 1.3482-.1676 2.6279-.6719 3.7125-1.463 1.0847-.7911 1.937-1.8416 2.4726-3.0478-1.0063.5199-1.9323.664-3.3556.664Z"></path></svg>`), MoonPlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MoonPlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MoonPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root499();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1499();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MoonPlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2499();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MoonPlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MoonPlusOutline = hmr(MoonPlusOutline, () => MoonPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonPlusOutline[HMR].source;
    set(MoonPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var MoonPlusOutline_default = MoonPlusOutline;

// node_modules/flowbite-svelte-icons/dist/MoonPlusSolid.svelte
MoonPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonPlusSolid.svelte";
var root_1500 = add_locations(from_svg(`<title> </title>`), MoonPlusSolid[FILENAME], [[41, 4]]);
var root_2500 = add_locations(from_svg(`<desc> </desc>`), MoonPlusSolid[FILENAME], [[44, 4]]);
var root500 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17 4c.5523 0 1 .44772 1 1v2h2c.5523 0 1 .44771 1 1 0 .55228-.4477 1-1 1h-2v2c0 .5523-.4477 1-1 1s-1-.4477-1-1V9h-2c-.5523 0-1-.44772-1-1s.4477-1 1-1h2V5c0-.55228.4477-1 1-1Z" clip-rule="evenodd"></path><path d="M12.3224 4.68708c.2935-.31028.3575-.77266.1594-1.15098-.1981-.37832-.6146-.5891-1.0368-.52467-1.50847.2302-2.93175.83665-4.12869 1.76276-1.19717.92628-2.12732 2.1411-2.69465 3.52702-.56744 1.38618-.75115 2.89299-.53164 4.37079.2195 1.4776.83393 2.8711 1.77895 4.0436.9448 1.1722 2.18683 2.0826 3.60103 2.6449 1.414.5623 2.9539.7584 4.4683.57 1.5145-.1884 2.9549-.7551 4.1784-1.6475 1.2237-.8924 2.1892-2.0806 2.7972-3.4499.1723-.3879.0809-.8423-.2279-1.1335-.3089-.2911-.7679-.3556-1.145-.1608-.8631.4459-1.8291.6799-2.8118.6791h-.0018c-1.1598.0013-2.2925-.3234-3.2596-.931-.9667-.6074-1.7244-1.4697-2.1856-2.4779-.4611-1.00776-.6079-2.1209-.4243-3.20511.1835-1.08442.6905-2.09837 1.4645-2.91681Z"></path></svg>`), MoonPlusSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function MoonPlusSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MoonPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root500();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1500();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MoonPlusSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2500();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MoonPlusSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MoonPlusSolid = hmr(MoonPlusSolid, () => MoonPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonPlusSolid[HMR].source;
    set(MoonPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var MoonPlusSolid_default = MoonPlusSolid;

// node_modules/flowbite-svelte-icons/dist/MoonSolid.svelte
MoonSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonSolid.svelte";
var root_1501 = add_locations(from_svg(`<title> </title>`), MoonSolid[FILENAME], [[41, 4]]);
var root_2501 = add_locations(from_svg(`<desc> </desc>`), MoonSolid[FILENAME], [[44, 4]]);
var root501 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.675 2.015a.998.998 0 0 0-.403.011C6.09 2.4 2 6.722 2 12c0 5.523 4.477 10 10 10 4.356 0 8.058-2.784 9.43-6.667a1 1 0 0 0-1.02-1.33c-.08.006-.105.005-.127.005h-.001l-.028-.002A5.227 5.227 0 0 0 20 14a8 8 0 0 1-8-8c0-.952.121-1.752.404-2.558a.996.996 0 0 0 .096-.428V3a1 1 0 0 0-.825-.985Z" clip-rule="evenodd"></path></svg>`), MoonSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MoonSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MoonSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root501();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1501();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MoonSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2501();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MoonSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MoonSolid = hmr(MoonSolid, () => MoonSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonSolid[HMR].source;
    set(MoonSolid[HMR].source, module.default[HMR].original);
  });
}
var MoonSolid_default = MoonSolid;

// node_modules/flowbite-svelte-icons/dist/MugHotOutline.svelte
MugHotOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MugHotOutline.svelte";
var root_1502 = add_locations(from_svg(`<title> </title>`), MugHotOutline[FILENAME], [[43, 4]]);
var root_2502 = add_locations(from_svg(`<desc> </desc>`), MugHotOutline[FILENAME], [[46, 4]]);
var root502 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 13h2c1.1046 0 2 .8954 2 2s-.8954 2-2 2h-2.5M10 3c0 2.4-3 1.6-3 4m8-4c0 2.4-3 1.6-3 4m-7 4 .6398 6.398C5.84428 19.4428 7.56494 21 9.61995 21H10.38c2.0551 0 3.7757-1.5572 3.9802-3.602L15 11H5Z"></path></svg>`), MugHotOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MugHotOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MugHotOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root502();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1502();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MugHotOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2502();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MugHotOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MugHotOutline = hmr(MugHotOutline, () => MugHotOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MugHotOutline[HMR].source;
    set(MugHotOutline[HMR].source, module.default[HMR].original);
  });
}
var MugHotOutline_default = MugHotOutline;

// node_modules/flowbite-svelte-icons/dist/MugHotSolid.svelte
MugHotSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MugHotSolid.svelte";
var root_1503 = add_locations(from_svg(`<title> </title>`), MugHotSolid[FILENAME], [[41, 4]]);
var root_2503 = add_locations(from_svg(`<desc> </desc>`), MugHotSolid[FILENAME], [[44, 4]]);
var root503 = add_locations(from_svg(`<svg><!><!><path d="M11 3c0-.55228-.4477-1-1-1-.55228 0-1 .44772-1 1 0 .35778-.09872.50986-.19828.61606-.14832.15821-.36754.28572-.7723.50159l-.04537.02415c-.34513.18363-.84839.45139-1.24483.87426C6.27628 5.50986 6 6.15778 6 7c0 .55228.44772 1 1 1 .55229 0 1-.44772 1-1 0-.35778.09873-.50986.19829-.61606.14832-.15821.36754-.28572.7723-.50159l.04536-.02415c.34514-.18363.8484-.45139 1.24485-.87426C10.7237 4.49014 11 3.84222 11 3Zm5 0c0-.55228-.4477-1-1-1s-1 .44772-1 1c0 .35778-.0987.50986-.1983.61606-.1483.15821-.3675.28572-.7723.50159l-.0453.02415c-.3452.18363-.8484.45139-1.2449.87426C11.2763 5.50986 11 6.15778 11 7c0 .55228.4477 1 1 1s1-.44772 1-1c0-.35778.0987-.50986.1983-.61606.1483-.15821.3675-.28572.7723-.50159l.0454-.02415c.3451-.18363.8484-.45139 1.2448-.87426C15.7237 4.49014 16 3.84222 16 3Z"></path><path fill-rule="evenodd" d="M5 10c-.28252 0-.55187.1195-.74145.329-.18958.2095-.2817.4894-.25358.7705l.6398 6.398C4.90037 20.0535 7.0512 22 9.61995 22h.76015c2.3975 0 4.431-1.6957 4.8992-4H17c1.6569 0 3-1.3431 3-3s-1.3431-3-3-3h-1.095l.09-.9005c.0282-.2811-.064-.561-.2535-.7705-.1896-.2095-.459-.329-.7415-.329H5Zm12 6h-1.495l.2-2H17c.5523 0 1 .4477 1 1s-.4477 1-1 1Z" clip-rule="evenodd"></path></svg>`), MugHotSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function MugHotSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MugHotSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root503();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1503();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MugHotSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2503();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MugHotSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MugHotSolid = hmr(MugHotSolid, () => MugHotSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MugHotSolid[HMR].source;
    set(MugHotSolid[HMR].source, module.default[HMR].original);
  });
}
var MugHotSolid_default = MugHotSolid;

// node_modules/flowbite-svelte-icons/dist/MugSaucerOutline.svelte
MugSaucerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MugSaucerOutline.svelte";
var root_1504 = add_locations(from_svg(`<title> </title>`), MugSaucerOutline[FILENAME], [[43, 4]]);
var root_2504 = add_locations(from_svg(`<desc> </desc>`), MugSaucerOutline[FILENAME], [[46, 4]]);
var root504 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 8h2c1.1046 0 2 .89543 2 2 0 1.1046-.8954 2-2 2h-2.5M5 19h11M5 6l.6398 6.398C5.84428 14.4428 7.56494 16 9.61995 16H10.38c2.0551 0 3.7757-1.5572 3.9802-3.602L15 6H5Z"></path></svg>`), MugSaucerOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MugSaucerOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MugSaucerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root504();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1504();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MugSaucerOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2504();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MugSaucerOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MugSaucerOutline = hmr(MugSaucerOutline, () => MugSaucerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MugSaucerOutline[HMR].source;
    set(MugSaucerOutline[HMR].source, module.default[HMR].original);
  });
}
var MugSaucerOutline_default = MugSaucerOutline;

// node_modules/flowbite-svelte-icons/dist/MugSaucerSolid.svelte
MugSaucerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MugSaucerSolid.svelte";
var root_1505 = add_locations(from_svg(`<title> </title>`), MugSaucerSolid[FILENAME], [[41, 4]]);
var root_2505 = add_locations(from_svg(`<desc> </desc>`), MugSaucerSolid[FILENAME], [[44, 4]]);
var root505 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 5c-.28252 0-.55187.11951-.74145.32899-.18958.20949-.2817.48939-.25358.77051l.6398 6.398C4.90037 15.0535 7.0512 17 9.61995 17h.76015c2.3975 0 4.431-1.6957 4.8992-4H17c1.6569 0 3-1.3431 3-3 0-1.65685-1.3431-3-3-3h-1.095l.09-.9005c.0282-.28112-.064-.56102-.2535-.77051C15.5519 5.11951 15.2825 5 15 5H5Zm12 6h-1.495l.2-2H17c.5523 0 1 .44772 1 1 0 .5523-.4477 1-1 1Z" clip-rule="evenodd"></path><path d="M5 18c-.55228 0-1 .4477-1 1s.44772 1 1 1h11c.5523 0 1-.4477 1-1s-.4477-1-1-1H5Z"></path></svg>`), MugSaucerSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function MugSaucerSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MugSaucerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root505();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1505();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MugSaucerSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2505();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MugSaucerSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MugSaucerSolid = hmr(MugSaucerSolid, () => MugSaucerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MugSaucerSolid[HMR].source;
    set(MugSaucerSolid[HMR].source, module.default[HMR].original);
  });
}
var MugSaucerSolid_default = MugSaucerSolid;

// node_modules/flowbite-svelte-icons/dist/MusicAltOutline.svelte
MusicAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MusicAltOutline.svelte";
var root_1506 = add_locations(from_svg(`<title> </title>`), MusicAltOutline[FILENAME], [[43, 4]]);
var root_2506 = add_locations(from_svg(`<desc> </desc>`), MusicAltOutline[FILENAME], [[46, 4]]);
var root506 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 16.5c0 1.3807-1.1193 2.5-2.5 2.5C8.11929 19 7 17.8807 7 16.5S8.11929 14 9.5 14c1.3807 0 2.5 1.1193 2.5 2.5Zm0 0V5c2.5 0 6 2.5 4.5 7"></path></svg>`), MusicAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MusicAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MusicAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root506();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1506();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MusicAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2506();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MusicAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MusicAltOutline = hmr(MusicAltOutline, () => MusicAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MusicAltOutline[HMR].source;
    set(MusicAltOutline[HMR].source, module.default[HMR].original);
  });
}
var MusicAltOutline_default = MusicAltOutline;

// node_modules/flowbite-svelte-icons/dist/MusicAltSolid.svelte
MusicAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MusicAltSolid.svelte";
var root_1507 = add_locations(from_svg(`<title> </title>`), MusicAltSolid[FILENAME], [[41, 4]]);
var root_2507 = add_locations(from_svg(`<desc> </desc>`), MusicAltSolid[FILENAME], [[44, 4]]);
var root507 = add_locations(from_svg(`<svg><!><!><path d="M9.5 13C7.567 13 6 14.567 6 16.5S7.567 20 9.5 20s3.5-1.567 3.5-3.5S11.433 13 9.5 13Z"></path><path fill-rule="evenodd" d="M11 5c0-.55228.4477-1 1-1 1.5438 0 3.3242.75435 4.5149 2.16836 1.2348 1.46632 1.7886 3.5834.9338 6.14784-.1747.524-.741.8071-1.2649.6325-.524-.1747-.8071-.741-.6325-1.2649.6452-1.93556.199-3.31848-.5662-4.22716C14.4407 6.8102 13.7107 6.37433 13 6.15825V16.5c0 .5523-.4477 1-1 1s-1-.4477-1-1V5Z" clip-rule="evenodd"></path></svg>`), MusicAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function MusicAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MusicAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root507();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1507();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MusicAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2507();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MusicAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MusicAltSolid = hmr(MusicAltSolid, () => MusicAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MusicAltSolid[HMR].source;
    set(MusicAltSolid[HMR].source, module.default[HMR].original);
  });
}
var MusicAltSolid_default = MusicAltSolid;

// node_modules/flowbite-svelte-icons/dist/MusicOutline.svelte
MusicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MusicOutline.svelte";
var root_1508 = add_locations(from_svg(`<title> </title>`), MusicOutline[FILENAME], [[43, 4]]);
var root_2508 = add_locations(from_svg(`<desc> </desc>`), MusicOutline[FILENAME], [[46, 4]]);
var root508 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 18c0 1.1046-.89543 2-2 2s-2-.8954-2-2 .89543-2 2-2 2 .8954 2 2Zm0 0V6.33333L18 4v11.6667M8 10.3333 18 8m0 8c0 1.1046-.8954 2-2 2s-2-.8954-2-2 .8954-2 2-2 2 .8954 2 2Z"></path></svg>`), MusicOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function MusicOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MusicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root508();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1508();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MusicOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2508();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MusicOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MusicOutline = hmr(MusicOutline, () => MusicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MusicOutline[HMR].source;
    set(MusicOutline[HMR].source, module.default[HMR].original);
  });
}
var MusicOutline_default = MusicOutline;

// node_modules/flowbite-svelte-icons/dist/MusicSolid.svelte
MusicSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MusicSolid.svelte";
var root_1509 = add_locations(from_svg(`<title> </title>`), MusicSolid[FILENAME], [[41, 4]]);
var root_2509 = add_locations(from_svg(`<desc> </desc>`), MusicSolid[FILENAME], [[44, 4]]);
var root509 = add_locations(from_svg(`<svg><!><!><path d="M18.6216 3.21667c.2391.1897.3784.47817.3784.78334V15.6667c0 .0412-.0025.0818-.0073.1218.0048.0698.0073.1404.0073.2115 0 1.6569-1.3431 3-3 3s-3-1.3431-3-3 1.3431-3 3-3c.3506 0 .6872.0602 1 .1707V9.2602l-8 1.8667V18l-.00001.0032C8.99824 19.6586 7.65577 21 6 21c-1.65685 0-3-1.3431-3-3s1.34315-3 3-3c.35064 0 .68722.0602 1 .1707V6.33334c0-.46474.32018-.86823.77277-.97384l9.99953-2.33321c.1486-.03477.3012-.03465.4467-.00201.1427.03202.2783.09532.3964.18752.0021.00162.0041.00324.0062.00487Z"></path></svg>`), MusicSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function MusicSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, MusicSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root509();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1509();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      MusicSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2509();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      MusicSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  MusicSolid = hmr(MusicSolid, () => MusicSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MusicSolid[HMR].source;
    set(MusicSolid[HMR].source, module.default[HMR].original);
  });
}
var MusicSolid_default = MusicSolid;

// node_modules/flowbite-svelte-icons/dist/NewspaperOutline.svelte
NewspaperOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NewspaperOutline.svelte";
var root_1510 = add_locations(from_svg(`<title> </title>`), NewspaperOutline[FILENAME], [[43, 4]]);
var root_2510 = add_locations(from_svg(`<desc> </desc>`), NewspaperOutline[FILENAME], [[46, 4]]);
var root510 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 7h1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h11.5M7 14h6m-6 3h6m0-10h.5m-.5 3h.5M7 7h3v3H7V7Z"></path></svg>`), NewspaperOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function NewspaperOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, NewspaperOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root510();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1510();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      NewspaperOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2510();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      NewspaperOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  NewspaperOutline = hmr(NewspaperOutline, () => NewspaperOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NewspaperOutline[HMR].source;
    set(NewspaperOutline[HMR].source, module.default[HMR].original);
  });
}
var NewspaperOutline_default = NewspaperOutline;

// node_modules/flowbite-svelte-icons/dist/NewspaperSolid.svelte
NewspaperSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NewspaperSolid.svelte";
var root_1511 = add_locations(from_svg(`<title> </title>`), NewspaperSolid[FILENAME], [[41, 4]]);
var root_2511 = add_locations(from_svg(`<desc> </desc>`), NewspaperSolid[FILENAME], [[44, 4]]);
var root511 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11.5c.07 0 .14-.007.207-.021.095.014.193.021.293.021h2a2 2 0 0 0 2-2V7a1 1 0 0 0-1-1h-1a1 1 0 1 0 0 2v11h-2V5a2 2 0 0 0-2-2H5Zm7 4a1 1 0 0 1 1-1h.5a1 1 0 1 1 0 2H13a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h.5a1 1 0 1 1 0 2H13a1 1 0 0 1-1-1Zm-6 4a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1ZM7 6a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H7Zm1 3V8h1v1H8Z" clip-rule="evenodd"></path></svg>`), NewspaperSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function NewspaperSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, NewspaperSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root511();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1511();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      NewspaperSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2511();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      NewspaperSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  NewspaperSolid = hmr(NewspaperSolid, () => NewspaperSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NewspaperSolid[HMR].source;
    set(NewspaperSolid[HMR].source, module.default[HMR].original);
  });
}
var NewspaperSolid_default = NewspaperSolid;

// node_modules/flowbite-svelte-icons/dist/NpmSolid.svelte
NpmSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NpmSolid.svelte";
var root_1512 = add_locations(from_svg(`<title> </title>`), NpmSolid[FILENAME], [[42, 4]]);
var root_2512 = add_locations(from_svg(`<desc> </desc>`), NpmSolid[FILENAME], [[45, 4]]);
var root512 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 3.87H4v16h8v-13h5v13h3v-16h-8Z"></path></svg>`), NpmSolid[FILENAME], [[31, 0, [[47, 2]]]]);
function NpmSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, NpmSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root512();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1512();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      NpmSolid,
      41,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2512();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      NpmSolid,
      44,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  NpmSolid = hmr(NpmSolid, () => NpmSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NpmSolid[HMR].source;
    set(NpmSolid[HMR].source, module.default[HMR].original);
  });
}
var NpmSolid_default = NpmSolid;

// node_modules/flowbite-svelte-icons/dist/ObjectsColumnOutline.svelte
ObjectsColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ObjectsColumnOutline.svelte";
var root_1513 = add_locations(from_svg(`<title> </title>`), ObjectsColumnOutline[FILENAME], [[43, 4]]);
var root_2513 = add_locations(from_svg(`<desc> </desc>`), ObjectsColumnOutline[FILENAME], [[46, 4]]);
var root513 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5Zm16 14a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2ZM4 13a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-6Zm16-2a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v6Z"></path></svg>`), ObjectsColumnOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ObjectsColumnOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ObjectsColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root513();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1513();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ObjectsColumnOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2513();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ObjectsColumnOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ObjectsColumnOutline = hmr(ObjectsColumnOutline, () => ObjectsColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ObjectsColumnOutline[HMR].source;
    set(ObjectsColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ObjectsColumnOutline_default = ObjectsColumnOutline;

// node_modules/flowbite-svelte-icons/dist/ObjectsColumnSolid.svelte
ObjectsColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ObjectsColumnSolid.svelte";
var root_1514 = add_locations(from_svg(`<title> </title>`), ObjectsColumnSolid[FILENAME], [[41, 4]]);
var root_2514 = add_locations(from_svg(`<desc> </desc>`), ObjectsColumnSolid[FILENAME], [[44, 4]]);
var root514 = add_locations(from_svg(`<svg><!><!><path d="M5 3a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5Zm14 18a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4ZM5 11a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2H5Zm14 2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h4Z"></path></svg>`), ObjectsColumnSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ObjectsColumnSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ObjectsColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root514();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1514();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ObjectsColumnSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2514();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ObjectsColumnSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ObjectsColumnSolid = hmr(ObjectsColumnSolid, () => ObjectsColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ObjectsColumnSolid[HMR].source;
    set(ObjectsColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var ObjectsColumnSolid_default = ObjectsColumnSolid;

// node_modules/flowbite-svelte-icons/dist/OpenDoorOutline.svelte
OpenDoorOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenDoorOutline.svelte";
var root_1515 = add_locations(from_svg(`<title> </title>`), OpenDoorOutline[FILENAME], [[43, 4]]);
var root_2515 = add_locations(from_svg(`<desc> </desc>`), OpenDoorOutline[FILENAME], [[46, 4]]);
var root515 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 18V6h-5v12h5Zm0 0h2M4 18h2.5m3.5-5.5V12M6 6l7-2v16l-7-2V6Z"></path></svg>`), OpenDoorOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OpenDoorOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenDoorOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root515();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1515();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenDoorOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2515();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenDoorOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenDoorOutline = hmr(OpenDoorOutline, () => OpenDoorOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenDoorOutline[HMR].source;
    set(OpenDoorOutline[HMR].source, module.default[HMR].original);
  });
}
var OpenDoorOutline_default = OpenDoorOutline;

// node_modules/flowbite-svelte-icons/dist/OpenDoorSolid.svelte
OpenDoorSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenDoorSolid.svelte";
var root_1516 = add_locations(from_svg(`<title> </title>`), OpenDoorSolid[FILENAME], [[41, 4]]);
var root_2516 = add_locations(from_svg(`<desc> </desc>`), OpenDoorSolid[FILENAME], [[44, 4]]);
var root516 = add_locations(from_svg(`<svg><!><!><path d="M14 19V5h4a1 1 0 0 1 1 1v11h1a1 1 0 0 1 0 2h-6Z"></path><path fill-rule="evenodd" d="M12 4.571a1 1 0 0 0-1.275-.961l-5 1.428A1 1 0 0 0 5 6v11H4a1 1 0 0 0 0 2h1.86l4.865 1.39A1 1 0 0 0 12 19.43V4.57ZM10 11a1 1 0 0 1 1 1v.5a1 1 0 0 1-2 0V12a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), OpenDoorSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function OpenDoorSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenDoorSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root516();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1516();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenDoorSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2516();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenDoorSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenDoorSolid = hmr(OpenDoorSolid, () => OpenDoorSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenDoorSolid[HMR].source;
    set(OpenDoorSolid[HMR].source, module.default[HMR].original);
  });
}
var OpenDoorSolid_default = OpenDoorSolid;

// node_modules/flowbite-svelte-icons/dist/OpenSidebarAltOutline.svelte
OpenSidebarAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenSidebarAltOutline.svelte";
var root_1517 = add_locations(from_svg(`<title> </title>`), OpenSidebarAltOutline[FILENAME], [[43, 4]]);
var root_2517 = add_locations(from_svg(`<desc> </desc>`), OpenSidebarAltOutline[FILENAME], [[46, 4]]);
var root517 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7 10 1.99994 1.9999-1.99994 2M12 5v14M5 4h14c.5523 0 1 .44772 1 1v14c0 .5523-.4477 1-1 1H5c-.55228 0-1-.4477-1-1V5c0-.55228.44772-1 1-1Z"></path></svg>`), OpenSidebarAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OpenSidebarAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenSidebarAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root517();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1517();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenSidebarAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2517();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenSidebarAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenSidebarAltOutline = hmr(OpenSidebarAltOutline, () => OpenSidebarAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenSidebarAltOutline[HMR].source;
    set(OpenSidebarAltOutline[HMR].source, module.default[HMR].original);
  });
}
var OpenSidebarAltOutline_default = OpenSidebarAltOutline;

// node_modules/flowbite-svelte-icons/dist/OpenSidebarAltSolid.svelte
OpenSidebarAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenSidebarAltSolid.svelte";
var root_1518 = add_locations(from_svg(`<title> </title>`), OpenSidebarAltSolid[FILENAME], [[41, 4]]);
var root_2518 = add_locations(from_svg(`<desc> </desc>`), OpenSidebarAltSolid[FILENAME], [[44, 4]]);
var root518 = add_locations(from_svg(`<svg><!><!><path d="M13 21h6c1.1046 0 2-.8954 2-2V5c0-1.10457-.8954-2-2-2h-6v18Z"></path><path fill-rule="evenodd" d="M11 3H5c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h6V3Zm-5.70711 7.7071c-.39052-.3905-.39052-1.02368 0-1.41421.39053-.39052 1.02369-.39052 1.41422 0l1.99994 1.99991c.39052.3906.39052 1.0237 0 1.4142l-1.99994 2c-.39053.3905-1.02369.3905-1.41422 0-.39052-.3905-.39052-1.0237 0-1.4142l1.29284-1.2929-1.29284-1.2928Z" clip-rule="evenodd"></path></svg>`), OpenSidebarAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function OpenSidebarAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenSidebarAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root518();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1518();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenSidebarAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2518();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenSidebarAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenSidebarAltSolid = hmr(OpenSidebarAltSolid, () => OpenSidebarAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenSidebarAltSolid[HMR].source;
    set(OpenSidebarAltSolid[HMR].source, module.default[HMR].original);
  });
}
var OpenSidebarAltSolid_default = OpenSidebarAltSolid;

// node_modules/flowbite-svelte-icons/dist/OpenSidebarOutline.svelte
OpenSidebarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenSidebarOutline.svelte";
var root_1519 = add_locations(from_svg(`<title> </title>`), OpenSidebarOutline[FILENAME], [[43, 4]]);
var root_2519 = add_locations(from_svg(`<desc> </desc>`), OpenSidebarOutline[FILENAME], [[46, 4]]);
var root519 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m6 10 1.99994 1.9999-1.99994 2M11 5v14m-7 0h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Z"></path></svg>`), OpenSidebarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OpenSidebarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenSidebarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root519();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1519();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenSidebarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2519();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenSidebarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenSidebarOutline = hmr(OpenSidebarOutline, () => OpenSidebarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenSidebarOutline[HMR].source;
    set(OpenSidebarOutline[HMR].source, module.default[HMR].original);
  });
}
var OpenSidebarOutline_default = OpenSidebarOutline;

// node_modules/flowbite-svelte-icons/dist/OpenSidebarSolid.svelte
OpenSidebarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenSidebarSolid.svelte";
var root_1520 = add_locations(from_svg(`<title> </title>`), OpenSidebarSolid[FILENAME], [[41, 4]]);
var root_2520 = add_locations(from_svg(`<desc> </desc>`), OpenSidebarSolid[FILENAME], [[44, 4]]);
var root520 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10 4H4c-1.10457 0-2 .89543-2 2v12c0 1.1046.89543 2 2 2h6V4ZM4.37868 9.29289c-.39052.39053-.39052 1.02371 0 1.41421l1.29283 1.2928-1.29283 1.2929c-.39052.3905-.39052 1.0237 0 1.4142.39052.3905 1.02369.3905 1.41421 0l1.99994-2c.39053-.3905.39053-1.0236 0-1.4142L5.79289 9.29289c-.39052-.39052-1.02369-.39052-1.41421 0Z" clip-rule="evenodd"></path><path d="M12 20h8c1.1046 0 2-.8954 2-2V6c0-1.10457-.8954-2-2-2h-8v16Z"></path></svg>`), OpenSidebarSolid[FILENAME], [[30, 0, [[46, 2], [50, 5]]]]);
function OpenSidebarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OpenSidebarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root520();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1520();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OpenSidebarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2520();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OpenSidebarSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OpenSidebarSolid = hmr(OpenSidebarSolid, () => OpenSidebarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenSidebarSolid[HMR].source;
    set(OpenSidebarSolid[HMR].source, module.default[HMR].original);
  });
}
var OpenSidebarSolid_default = OpenSidebarSolid;

// node_modules/flowbite-svelte-icons/dist/OrderedListOutline.svelte
OrderedListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OrderedListOutline.svelte";
var root_1521 = add_locations(from_svg(`<title> </title>`), OrderedListOutline[FILENAME], [[43, 4]]);
var root_2521 = add_locations(from_svg(`<desc> </desc>`), OrderedListOutline[FILENAME], [[46, 4]]);
var root521 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6h8m-8 6h8m-8 6h8M4 16a2 2 0 1 1 3.321 1.5L4 20h5M4 5l2-1v6m-2 0h4"></path></svg>`), OrderedListOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OrderedListOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OrderedListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root521();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1521();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OrderedListOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2521();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OrderedListOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OrderedListOutline = hmr(OrderedListOutline, () => OrderedListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OrderedListOutline[HMR].source;
    set(OrderedListOutline[HMR].source, module.default[HMR].original);
  });
}
var OrderedListOutline_default = OrderedListOutline;

// node_modules/flowbite-svelte-icons/dist/OutdentOutline.svelte
OutdentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutdentOutline.svelte";
var root_1522 = add_locations(from_svg(`<title> </title>`), OutdentOutline[FILENAME], [[43, 4]]);
var root_2522 = add_locations(from_svg(`<desc> </desc>`), OutdentOutline[FILENAME], [[46, 4]]);
var root522 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h12M6 18h12m-5-8h5m-5 4h5M9.5 9v6L6 12l3.5-3Z"></path></svg>`), OutdentOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OutdentOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OutdentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root522();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1522();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OutdentOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2522();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OutdentOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OutdentOutline = hmr(OutdentOutline, () => OutdentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutdentOutline[HMR].source;
    set(OutdentOutline[HMR].source, module.default[HMR].original);
  });
}
var OutdentOutline_default = OutdentOutline;

// node_modules/flowbite-svelte-icons/dist/OutdentSolid.svelte
OutdentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutdentSolid.svelte";
var root_1523 = add_locations(from_svg(`<title> </title>`), OutdentSolid[FILENAME], [[41, 4]]);
var root_2523 = add_locations(from_svg(`<desc> </desc>`), OutdentSolid[FILENAME], [[44, 4]]);
var root523 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 6a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm0 12a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm3.85-9.76A1 1 0 0 1 10.5 9v6a1 1 0 0 1-1.65.76l-3.5-3a1 1 0 0 1 0-1.52l3.5-3ZM12 10a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Zm0 4a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), OutdentSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function OutdentSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OutdentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root523();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1523();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OutdentSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2523();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OutdentSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OutdentSolid = hmr(OutdentSolid, () => OutdentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutdentSolid[HMR].source;
    set(OutdentSolid[HMR].source, module.default[HMR].original);
  });
}
var OutdentSolid_default = OutdentSolid;

// node_modules/flowbite-svelte-icons/dist/OutgoingCallOutline.svelte
OutgoingCallOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutgoingCallOutline.svelte";
var root_1524 = add_locations(from_svg(`<title> </title>`), OutgoingCallOutline[FILENAME], [[43, 4]]);
var root_2524 = add_locations(from_svg(`<desc> </desc>`), OutgoingCallOutline[FILENAME], [[46, 4]]);
var root524 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17.0896 13.371 1.1431 1.1439c.1745.1461.3148.3287.4111.5349.0962.2063.1461.4312.1461.6588 0 .2276-.0499.4525-.1461.6587-.0963.2063-.4729.6251-.6473.7712-3.1173 3.1211-6.7739 1.706-9.90477-1.4254-3.13087-3.1313-4.54323-6.7896-1.41066-9.90139.62706-.61925 1.71351-1.14182 2.61843-.23626l1.1911 1.19193c1.1911 1.19194.3562 1.93533-.4926 2.80371-.92477.92481-.65643 1.72741 0 2.38391l1.8713 1.8725c.3159.3161.7443.4936 1.191.4936.4468 0 .8752-.1775 1.1911-.4936.8624-.8261 1.6952-1.6004 2.8382-.4565ZM14 8.98134l5.0225-4.98132m0 0L15.9926 4m3.0299.00002v2.98135"></path></svg>`), OutgoingCallOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function OutgoingCallOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OutgoingCallOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root524();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1524();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OutgoingCallOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2524();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OutgoingCallOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OutgoingCallOutline = hmr(OutgoingCallOutline, () => OutgoingCallOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutgoingCallOutline[HMR].source;
    set(OutgoingCallOutline[HMR].source, module.default[HMR].original);
  });
}
var OutgoingCallOutline_default = OutgoingCallOutline;

// node_modules/flowbite-svelte-icons/dist/OutgoingCallSolid.svelte
OutgoingCallSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutgoingCallSolid.svelte";
var root_1525 = add_locations(from_svg(`<title> </title>`), OutgoingCallSolid[FILENAME], [[41, 4]]);
var root_2525 = add_locations(from_svg(`<desc> </desc>`), OutgoingCallSolid[FILENAME], [[44, 4]]);
var root525 = add_locations(from_svg(`<svg><!><!><path d="M6.97825 3.99999c-.3729 0-.74128.08169-1.07926.23933-.32394.1511-.61243.36846-.84696.63787-1.81892 1.82189-2.35302 3.87423-1.89899 5.93671.43916 1.9949 1.77747 3.8929 3.45642 5.572 1.67897 1.6791 3.57614 3.0176 5.57034 3.4591 2.0612.4563 4.1141-.0726 5.9396-1.8853.2705-.2348.4888-.524.6405-.8489.1581-.3387.2401-.7081.2401-1.0819 0-.3739-.082-.7432-.2401-1.0819-.1516-.3247-.3696-.6137-.6398-.8483l-1.2098-1.2106c-.5043-.5041-1.1879-.7872-1.9007-.7872-.7128 0-1.3968.2835-1.9011.7876l-.6178.6181c-.1512.1513-.3563.2363-.5701.2363-.2138 0-.4189-.085-.5701-.2363l-1.85336-1.8545c-.15117-.1513-.23609-.3565-.23609-.5704 0-.214.08493-.4192.23613-.5705l.61812-.61851c.5037-.50461.7867-1.18868.7867-1.90191s-.2833-1.39767-.7871-1.90228L8.90499 4.8778c-.23462-.26969-.5233-.48727-.84749-.63848-.33798-.15764-.70636-.23933-1.07925-.23933Z"></path><path fill-rule="evenodd" d="M14.9925 3.99996c0-.55228.4477-.99999 1-.99999l3.03.00002c.5523 0 1 .44772 1 1v2.98135c0 .55228-.4478 1-1 1-.5523 0-1-.44772-1-1v-.58113l-3.3184 3.29112c-.3921.38887-1.0253.38627-1.4142-.00583-.3889-.39213-.3863-1.02529.0059-1.4142l3.2983-3.27133h-.6016c-.5523 0-1-.44772-1-1.00001Z" clip-rule="evenodd"></path></svg>`), OutgoingCallSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function OutgoingCallSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, OutgoingCallSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root525();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1525();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      OutgoingCallSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2525();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      OutgoingCallSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  OutgoingCallSolid = hmr(OutgoingCallSolid, () => OutgoingCallSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutgoingCallSolid[HMR].source;
    set(OutgoingCallSolid[HMR].source, module.default[HMR].original);
  });
}
var OutgoingCallSolid_default = OutgoingCallSolid;

// node_modules/flowbite-svelte-icons/dist/PaletteOutline.svelte
PaletteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaletteOutline.svelte";
var root_1526 = add_locations(from_svg(`<title> </title>`), PaletteOutline[FILENAME], [[43, 4]]);
var root_2526 = add_locations(from_svg(`<desc> </desc>`), PaletteOutline[FILENAME], [[46, 4]]);
var root526 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 7h.01m3.486 1.513h.01m-6.978 0h.01M6.99 12H7m9 4h2.706a1.957 1.957 0 0 0 1.883-1.325A9 9 0 1 0 3.043 12.89 9.1 9.1 0 0 0 8.2 20.1a8.62 8.62 0 0 0 3.769.9 2.013 2.013 0 0 0 2.03-2v-.857A2.036 2.036 0 0 1 16 16Z"></path></svg>`), PaletteOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PaletteOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PaletteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root526();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1526();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PaletteOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2526();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PaletteOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PaletteOutline = hmr(PaletteOutline, () => PaletteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaletteOutline[HMR].source;
    set(PaletteOutline[HMR].source, module.default[HMR].original);
  });
}
var PaletteOutline_default = PaletteOutline;

// node_modules/flowbite-svelte-icons/dist/PaletteSolid.svelte
PaletteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaletteSolid.svelte";
var root_1527 = add_locations(from_svg(`<title> </title>`), PaletteSolid[FILENAME], [[41, 4]]);
var root_2527 = add_locations(from_svg(`<desc> </desc>`), PaletteSolid[FILENAME], [[44, 4]]);
var root527 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.649 2.577A10.004 10.004 0 0 1 20.344 6.49a9.995 9.995 0 0 1 1.2 8.486l-.004.01-.005.015a2.958 2.958 0 0 1-2.836 2.001h-2.69a1.037 1.037 0 0 0-.95.68c-.047.13-.068.27-.06.409v.916A3.01 3.01 0 0 1 11.96 22a9.626 9.626 0 0 1-4.195-1l.009.005-.018-.009.01.004a10.1 10.1 0 0 1-5.716-7.996l-.001-.012a9.992 9.992 0 0 1 6.6-10.415Zm3.35 3.429a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12ZM8.53 7.518a1 1 0 0 0 0 2h.01a1 1 0 1 0 0-2h-.01Zm6.968 0a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM6.99 11.004a1 1 0 1 0 0 2H7a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), PaletteSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PaletteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PaletteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root527();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1527();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PaletteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2527();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PaletteSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PaletteSolid = hmr(PaletteSolid, () => PaletteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaletteSolid[HMR].source;
    set(PaletteSolid[HMR].source, module.default[HMR].original);
  });
}
var PaletteSolid_default = PaletteSolid;

// node_modules/flowbite-svelte-icons/dist/PaperClipOutline.svelte
PaperClipOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperClipOutline.svelte";
var root_1528 = add_locations(from_svg(`<title> </title>`), PaperClipOutline[FILENAME], [[43, 4]]);
var root_2528 = add_locations(from_svg(`<desc> </desc>`), PaperClipOutline[FILENAME], [[46, 4]]);
var root528 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 8v8a5 5 0 1 0 10 0V6.5a3.5 3.5 0 1 0-7 0V15a2 2 0 0 0 4 0V8"></path></svg>`), PaperClipOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PaperClipOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PaperClipOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root528();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1528();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PaperClipOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2528();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PaperClipOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PaperClipOutline = hmr(PaperClipOutline, () => PaperClipOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperClipOutline[HMR].source;
    set(PaperClipOutline[HMR].source, module.default[HMR].original);
  });
}
var PaperClipOutline_default = PaperClipOutline;

// node_modules/flowbite-svelte-icons/dist/PaperPlaneOutline.svelte
PaperPlaneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperPlaneOutline.svelte";
var root_1529 = add_locations(from_svg(`<title> </title>`), PaperPlaneOutline[FILENAME], [[43, 4]]);
var root_2529 = add_locations(from_svg(`<desc> </desc>`), PaperPlaneOutline[FILENAME], [[46, 4]]);
var root529 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m12 18-7 3 7-18 7 18-7-3Zm0 0v-5"></path></svg>`), PaperPlaneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PaperPlaneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PaperPlaneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root529();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1529();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PaperPlaneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2529();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PaperPlaneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PaperPlaneOutline = hmr(PaperPlaneOutline, () => PaperPlaneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperPlaneOutline[HMR].source;
    set(PaperPlaneOutline[HMR].source, module.default[HMR].original);
  });
}
var PaperPlaneOutline_default = PaperPlaneOutline;

// node_modules/flowbite-svelte-icons/dist/PaperPlaneSolid.svelte
PaperPlaneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperPlaneSolid.svelte";
var root_1530 = add_locations(from_svg(`<title> </title>`), PaperPlaneSolid[FILENAME], [[41, 4]]);
var root_2530 = add_locations(from_svg(`<desc> </desc>`), PaperPlaneSolid[FILENAME], [[44, 4]]);
var root530 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2a1 1 0 0 1 .932.638l7 18a1 1 0 0 1-1.326 1.281L13 19.517V13a1 1 0 1 0-2 0v6.517l-5.606 2.402a1 1 0 0 1-1.326-1.281l7-18A1 1 0 0 1 12 2Z" clip-rule="evenodd"></path></svg>`), PaperPlaneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PaperPlaneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PaperPlaneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root530();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1530();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PaperPlaneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2530();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PaperPlaneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PaperPlaneSolid = hmr(PaperPlaneSolid, () => PaperPlaneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperPlaneSolid[HMR].source;
    set(PaperPlaneSolid[HMR].source, module.default[HMR].original);
  });
}
var PaperPlaneSolid_default = PaperPlaneSolid;

// node_modules/flowbite-svelte-icons/dist/ParagraphOutline.svelte
ParagraphOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ParagraphOutline.svelte";
var root_1531 = add_locations(from_svg(`<title> </title>`), ParagraphOutline[FILENAME], [[43, 4]]);
var root_2531 = add_locations(from_svg(`<desc> </desc>`), ParagraphOutline[FILENAME], [[46, 4]]);
var root531 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5v7m0 7v-7m4-7v14m3-14H8.5A3.5 3.5 0 0 0 5 8.5v0A3.5 3.5 0 0 0 8.5 12H12"></path></svg>`), ParagraphOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ParagraphOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ParagraphOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root531();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1531();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ParagraphOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2531();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ParagraphOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ParagraphOutline = hmr(ParagraphOutline, () => ParagraphOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ParagraphOutline[HMR].source;
    set(ParagraphOutline[HMR].source, module.default[HMR].original);
  });
}
var ParagraphOutline_default = ParagraphOutline;

// node_modules/flowbite-svelte-icons/dist/ParagraphSolid.svelte
ParagraphSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ParagraphSolid.svelte";
var root_1532 = add_locations(from_svg(`<title> </title>`), ParagraphSolid[FILENAME], [[41, 4]]);
var root_2532 = add_locations(from_svg(`<desc> </desc>`), ParagraphSolid[FILENAME], [[44, 4]]);
var root532 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.5 4a4.5 4.5 0 0 0 0 9H11v6a1 1 0 1 0 2 0V6h2v13a1 1 0 1 0 2 0V6h2a1 1 0 1 0 0-2H8.5Z" clip-rule="evenodd"></path></svg>`), ParagraphSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ParagraphSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ParagraphSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root532();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1532();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ParagraphSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2532();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ParagraphSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ParagraphSolid = hmr(ParagraphSolid, () => ParagraphSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ParagraphSolid[HMR].source;
    set(ParagraphSolid[HMR].source, module.default[HMR].original);
  });
}
var ParagraphSolid_default = ParagraphSolid;

// node_modules/flowbite-svelte-icons/dist/PauseOutline.svelte
PauseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PauseOutline.svelte";
var root_1533 = add_locations(from_svg(`<title> </title>`), PauseOutline[FILENAME], [[43, 4]]);
var root_2533 = add_locations(from_svg(`<desc> </desc>`), PauseOutline[FILENAME], [[46, 4]]);
var root533 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 6H8a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm7 0h-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Z"></path></svg>`), PauseOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PauseOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PauseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root533();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1533();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PauseOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2533();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PauseOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PauseOutline = hmr(PauseOutline, () => PauseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PauseOutline[HMR].source;
    set(PauseOutline[HMR].source, module.default[HMR].original);
  });
}
var PauseOutline_default = PauseOutline;

// node_modules/flowbite-svelte-icons/dist/PauseSolid.svelte
PauseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PauseSolid.svelte";
var root_1534 = add_locations(from_svg(`<title> </title>`), PauseSolid[FILENAME], [[41, 4]]);
var root_2534 = add_locations(from_svg(`<desc> </desc>`), PauseSolid[FILENAME], [[44, 4]]);
var root534 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H8Zm7 0a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-1Z" clip-rule="evenodd"></path></svg>`), PauseSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PauseSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PauseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root534();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1534();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PauseSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2534();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PauseSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PauseSolid = hmr(PauseSolid, () => PauseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PauseSolid[HMR].source;
    set(PauseSolid[HMR].source, module.default[HMR].original);
  });
}
var PauseSolid_default = PauseSolid;

// node_modules/flowbite-svelte-icons/dist/PenNibOutline.svelte
PenNibOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenNibOutline.svelte";
var root_1535 = add_locations(from_svg(`<title> </title>`), PenNibOutline[FILENAME], [[43, 4]]);
var root_2535 = add_locations(from_svg(`<desc> </desc>`), PenNibOutline[FILENAME], [[46, 4]]);
var root535 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4.988 19.012 5.41-5.41m2.366-6.424 4.058 4.058-2.03 5.41L5.3 20 4 18.701l3.355-9.494 5.41-2.029Zm4.626 4.625L12.197 6.61 14.807 4 20 9.194l-2.61 2.61Z"></path></svg>`), PenNibOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PenNibOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PenNibOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root535();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1535();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PenNibOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2535();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PenNibOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PenNibOutline = hmr(PenNibOutline, () => PenNibOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenNibOutline[HMR].source;
    set(PenNibOutline[HMR].source, module.default[HMR].original);
  });
}
var PenNibOutline_default = PenNibOutline;

// node_modules/flowbite-svelte-icons/dist/PenNibSolid.svelte
PenNibSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenNibSolid.svelte";
var root_1536 = add_locations(from_svg(`<title> </title>`), PenNibSolid[FILENAME], [[41, 4]]);
var root_2536 = add_locations(from_svg(`<desc> </desc>`), PenNibSolid[FILENAME], [[44, 4]]);
var root536 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15.514 3.293a1 1 0 0 0-1.415 0L12.151 5.24a.93.93 0 0 1 .056.052l6.5 6.5a.97.97 0 0 1 .052.056L20.707 9.9a1 1 0 0 0 0-1.415l-5.193-5.193ZM7.004 8.27l3.892-1.46 6.293 6.293-1.46 3.893a1 1 0 0 1-.603.591l-9.494 3.355a1 1 0 0 1-.98-.18l6.452-6.453a1 1 0 0 0-1.414-1.414l-6.453 6.452a1 1 0 0 1-.18-.98l3.355-9.494a1 1 0 0 1 .591-.603Z" clip-rule="evenodd"></path></svg>`), PenNibSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PenNibSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PenNibSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root536();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1536();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PenNibSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2536();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PenNibSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PenNibSolid = hmr(PenNibSolid, () => PenNibSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenNibSolid[HMR].source;
    set(PenNibSolid[HMR].source, module.default[HMR].original);
  });
}
var PenNibSolid_default = PenNibSolid;

// node_modules/flowbite-svelte-icons/dist/PenOutline.svelte
PenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenOutline.svelte";
var root_1537 = add_locations(from_svg(`<title> </title>`), PenOutline[FILENAME], [[43, 4]]);
var root_2537 = add_locations(from_svg(`<desc> </desc>`), PenOutline[FILENAME], [[46, 4]]);
var root537 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.779 17.779 4.36 19.918 6.5 13.5m4.279 4.279 8.364-8.643a3.027 3.027 0 0 0-2.14-5.165 3.03 3.03 0 0 0-2.14.886L6.5 13.5m4.279 4.279L6.499 13.5m2.14 2.14 6.213-6.504M12.75 7.04 17 11.28"></path></svg>`), PenOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PenOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root537();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1537();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PenOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2537();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PenOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PenOutline = hmr(PenOutline, () => PenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenOutline[HMR].source;
    set(PenOutline[HMR].source, module.default[HMR].original);
  });
}
var PenOutline_default = PenOutline;

// node_modules/flowbite-svelte-icons/dist/PenSolid.svelte
PenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenSolid.svelte";
var root_1538 = add_locations(from_svg(`<title> </title>`), PenSolid[FILENAME], [[41, 4]]);
var root_2538 = add_locations(from_svg(`<desc> </desc>`), PenSolid[FILENAME], [[44, 4]]);
var root538 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14 4.182A4.136 4.136 0 0 1 16.9 3c1.087 0 2.13.425 2.899 1.182A4.01 4.01 0 0 1 21 7.037c0 1.068-.43 2.092-1.194 2.849L18.5 11.214l-5.8-5.71 1.287-1.31.012-.012Zm-2.717 2.763L6.186 12.13l2.175 2.141 5.063-5.218-2.141-2.108Zm-6.25 6.886-1.98 5.849a.992.992 0 0 0 .245 1.026 1.03 1.03 0 0 0 1.043.242L10.282 19l-5.25-5.168Zm6.954 4.01 5.096-5.186-2.218-2.183-5.063 5.218 2.185 2.15Z" clip-rule="evenodd"></path></svg>`), PenSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PenSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root538();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1538();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PenSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2538();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PenSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PenSolid = hmr(PenSolid, () => PenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenSolid[HMR].source;
    set(PenSolid[HMR].source, module.default[HMR].original);
  });
}
var PenSolid_default = PenSolid;

// node_modules/flowbite-svelte-icons/dist/PepperHotOutline.svelte
PepperHotOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PepperHotOutline.svelte";
var root_1539 = add_locations(from_svg(`<title> </title>`), PepperHotOutline[FILENAME], [[43, 4]]);
var root_2539 = add_locations(from_svg(`<desc> </desc>`), PepperHotOutline[FILENAME], [[46, 4]]);
var root539 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 11c1.4996-3.03293 3.1022-3.84719 4.5-3.50002 1.3978.34717 2.2863.9906 2.6776 2.60672.4633 2.1164-1.7429 4.9773-5.8373 8.2081-1.2064.9132-3.49445 2.0175-5.05111 2.6995-.69706.2941-1.59437.0537-2.09791-.6308-.50355-.6845-.3913-1.6162.24626-2.201.39377-.444.75319-.7599 1.11261-1.0758C8.1847 15.6213 9.50034 14.033 11 11Zm0 0h3v2h3m.1576-5.48485 1.2592-2.13563c.4624-.70043.1558-1.60694-.5447-2.0694-.7004-.46246-1.6069-.1558-2.0694.54463l-.0812.04692"></path></svg>`), PepperHotOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PepperHotOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PepperHotOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root539();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1539();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PepperHotOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2539();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PepperHotOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PepperHotOutline = hmr(PepperHotOutline, () => PepperHotOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PepperHotOutline[HMR].source;
    set(PepperHotOutline[HMR].source, module.default[HMR].original);
  });
}
var PepperHotOutline_default = PepperHotOutline;

// node_modules/flowbite-svelte-icons/dist/PepperHotSolid.svelte
PepperHotSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PepperHotSolid.svelte";
var root_1540 = add_locations(from_svg(`<title> </title>`), PepperHotSolid[FILENAME], [[41, 4]]);
var root_2540 = add_locations(from_svg(`<desc> </desc>`), PepperHotSolid[FILENAME], [[44, 4]]);
var root540 = add_locations(from_svg(`<svg><!><!><path d="M15.1076 3.02722c.7328-.91889 2.119-1.42653 3.3155-.63652 1.0296.67976 1.6636 2.15898.8437 3.43103l-1.1345 1.92424c.49.5379.8177 1.21684 1.0172 2.04053l.0026.01069.0023.01075c.1578.72086.0871 1.45746-.1496 2.19206H14.5v-2c0-.55228-.4477-1-1-1h-2.5594c.5551-.83927 1.1449-1.47688 1.7703-1.91901.9836-.6954 2.0299-.88485 3.0301-.63643.241.05985.4787.12994.7103.21464l1.104-1.87249c.0086-.01459.0176-.02895.0269-.04309.0543-.0822.0714-.17722.0369-.29792-.0378-.13197-.1376-.28012-.298-.38598-.0822-.05428-.1772-.07137-.2979-.03684-.132.03775-.2801.13762-.386.29795-.0855.12955-.2.23741-.3345.31504l-.0812.04692c-.4783.27614-1.0899.11227-1.3661-.36603-.2529-.43808-.1367-.98799.2522-1.28954ZM9.83662 11c-1.33245 2.5771-2.51227 3.9661-3.95291 5.2762l-.00417.0037c-.34799.3058-.73582.6466-1.15874 1.119-.95621.9127-1.14739 2.388-.33504 3.4923.76302 1.0372 2.14652 1.4429 3.29215.9596l.01259-.0054c1.55-.6791 3.9409-1.8247 5.2534-2.8182l.008-.0061.0079-.0062c2.0804-1.6416 3.7352-3.23 4.8173-4.7191.0713-.0982.1408-.1968.2082-.2958H13.5c-.5523 0-1-.4477-1-1v-2H9.83662Z"></path></svg>`), PepperHotSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PepperHotSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PepperHotSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root540();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1540();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PepperHotSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2540();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PepperHotSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PepperHotSolid = hmr(PepperHotSolid, () => PepperHotSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PepperHotSolid[HMR].source;
    set(PepperHotSolid[HMR].source, module.default[HMR].original);
  });
}
var PepperHotSolid_default = PepperHotSolid;

// node_modules/flowbite-svelte-icons/dist/PersonChalkboardOutline.svelte
PersonChalkboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PersonChalkboardOutline.svelte";
var root_1541 = add_locations(from_svg(`<title> </title>`), PersonChalkboardOutline[FILENAME], [[43, 4]]);
var root_2541 = add_locations(from_svg(`<desc> </desc>`), PersonChalkboardOutline[FILENAME], [[46, 4]]);
var root541 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5713 5h7v9h-7m-6.00001-4-3 4.5m3-4.5v5m0-5h3.00001m0 0h5m-5 0v5m-3.00001 0h3.00001m-3.00001 0v5m3.00001-5v5m6-6 2.5 6m-3-6-2.5 6m-3-14.5c0 .82843-.67158 1.5-1.50001 1.5-.82843 0-1.5-.67157-1.5-1.5s.67157-1.5 1.5-1.5 1.50001.67157 1.50001 1.5Z"></path></svg>`), PersonChalkboardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PersonChalkboardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PersonChalkboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root541();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1541();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PersonChalkboardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2541();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PersonChalkboardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PersonChalkboardOutline = hmr(PersonChalkboardOutline, () => PersonChalkboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PersonChalkboardOutline[HMR].source;
    set(PersonChalkboardOutline[HMR].source, module.default[HMR].original);
  });
}
var PersonChalkboardOutline_default = PersonChalkboardOutline;

// node_modules/flowbite-svelte-icons/dist/PersonChalkboardSolid.svelte
PersonChalkboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PersonChalkboardSolid.svelte";
var root_1542 = add_locations(from_svg(`<title> </title>`), PersonChalkboardSolid[FILENAME], [[41, 4]]);
var root_2542 = add_locations(from_svg(`<desc> </desc>`), PersonChalkboardSolid[FILENAME], [[44, 4]]);
var root542 = add_locations(from_svg(`<svg><!><!><path d="M16 10c0-.55228-.4477-1-1-1h-3v2h3c.5523 0 1-.4477 1-1Z"></path><path d="M13 15v-2h2c1.6569 0 3-1.3431 3-3 0-1.65685-1.3431-3-3-3h-2.256c.1658-.46917.256-.97405.256-1.5 0-.51464-.0864-1.0091-.2454-1.46967C12.8331 4.01052 12.9153 4 13 4h7c.5523 0 1 .44772 1 1v9c0 .5523-.4477 1-1 1h-2.5l1.9231 4.6154c.2124.5098-.0287 1.0953-.5385 1.3077-.5098.2124-1.0953-.0287-1.3077-.5385L15.75 16l-1.827 4.3846c-.1825.438-.6403.6776-1.0889.6018.1075-.3089.1659-.6408.1659-.9864v-2.6002L14 15h-1ZM6 5.5C6 4.11929 7.11929 3 8.5 3S11 4.11929 11 5.5 9.88071 8 8.5 8 6 6.88071 6 5.5Z"></path><path d="M15 11h-4v9c0 .5523-.4477 1-1 1-.55228 0-1-.4477-1-1v-4H8v4c0 .5523-.44772 1-1 1s-1-.4477-1-1v-6.6973l-1.16797 1.752c-.30635.4595-.92722.5837-1.38675.2773-.45952-.3063-.5837-.9272-.27735-1.3867l2.99228-4.48843c.09402-.14507.2246-.26423.37869-.34445.11427-.05949.24148-.09755.3763-.10887.03364-.00289.06747-.00408.10134-.00355H15c.5523 0 1 .44772 1 1 0 .5523-.4477 1-1 1Z"></path></svg>`), PersonChalkboardSolid[FILENAME], [[30, 0, [[46, 2], [47, 2], [50, 2]]]]);
function PersonChalkboardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PersonChalkboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root542();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1542();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PersonChalkboardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2542();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PersonChalkboardSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PersonChalkboardSolid = hmr(PersonChalkboardSolid, () => PersonChalkboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PersonChalkboardSolid[HMR].source;
    set(PersonChalkboardSolid[HMR].source, module.default[HMR].original);
  });
}
var PersonChalkboardSolid_default = PersonChalkboardSolid;

// node_modules/flowbite-svelte-icons/dist/PhoneHangupOutline.svelte
PhoneHangupOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneHangupOutline.svelte";
var root_1543 = add_locations(from_svg(`<title> </title>`), PhoneHangupOutline[FILENAME], [[43, 4]]);
var root_2543 = add_locations(from_svg(`<desc> </desc>`), PhoneHangupOutline[FILENAME], [[46, 4]]);
var root543 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.693 16.013H7.31a1.685 1.685 0 0 0 1.685-1.684v-.645A1.684 1.684 0 0 1 10.679 12h2.647a1.686 1.686 0 0 1 1.686 1.686v.646c0 .446.178.875.494 1.19.316.317.693.495 1.14.495h1.685a1.556 1.556 0 0 0 1.597-1.016c.078-.214.107-.776.088-1.002.014-4.415-3.571-6.003-8-6.004-4.427 0-8.014 1.585-8.01 5.996-.02.227.009.79.087 1.003a1.558 1.558 0 0 0 1.6 1.02Z"></path></svg>`), PhoneHangupOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PhoneHangupOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PhoneHangupOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root543();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1543();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PhoneHangupOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2543();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PhoneHangupOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PhoneHangupOutline = hmr(PhoneHangupOutline, () => PhoneHangupOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneHangupOutline[HMR].source;
    set(PhoneHangupOutline[HMR].source, module.default[HMR].original);
  });
}
var PhoneHangupOutline_default = PhoneHangupOutline;

// node_modules/flowbite-svelte-icons/dist/PhoneHangupSolid.svelte
PhoneHangupSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneHangupSolid.svelte";
var root_1544 = add_locations(from_svg(`<title> </title>`), PhoneHangupSolid[FILENAME], [[41, 4]]);
var root_2544 = add_locations(from_svg(`<desc> </desc>`), PhoneHangupSolid[FILENAME], [[44, 4]]);
var root544 = add_locations(from_svg(`<svg><!><!><path d="M12.017 6.995c-2.306 0-4.534.408-6.215 1.507-1.737 1.135-2.788 2.944-2.797 5.451a4.8 4.8 0 0 0 .01.62c.015.193.047.512.138.763a2.557 2.557 0 0 0 2.579 1.677H7.31a2.685 2.685 0 0 0 2.685-2.684v-.645a.684.684 0 0 1 .684-.684h2.647a.686.686 0 0 1 .686.687v.645c0 .712.284 1.395.787 1.898.478.478 1.101.787 1.847.787h1.647a2.555 2.555 0 0 0 2.575-1.674c.09-.25.123-.57.137-.763.015-.2.022-.433.01-.617-.002-2.508-1.049-4.32-2.785-5.458-1.68-1.1-3.907-1.51-6.213-1.51Z"></path></svg>`), PhoneHangupSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PhoneHangupSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PhoneHangupSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root544();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1544();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PhoneHangupSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2544();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PhoneHangupSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PhoneHangupSolid = hmr(PhoneHangupSolid, () => PhoneHangupSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneHangupSolid[HMR].source;
    set(PhoneHangupSolid[HMR].source, module.default[HMR].original);
  });
}
var PhoneHangupSolid_default = PhoneHangupSolid;

// node_modules/flowbite-svelte-icons/dist/PhoneOutline.svelte
PhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneOutline.svelte";
var root_1545 = add_locations(from_svg(`<title> </title>`), PhoneOutline[FILENAME], [[43, 4]]);
var root_2545 = add_locations(from_svg(`<desc> </desc>`), PhoneOutline[FILENAME], [[46, 4]]);
var root545 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.427 14.768 17.2 13.542a1.733 1.733 0 0 0-2.45 0l-.613.613a1.732 1.732 0 0 1-2.45 0l-1.838-1.84a1.735 1.735 0 0 1 0-2.452l.612-.613a1.735 1.735 0 0 0 0-2.452L9.237 5.572a1.6 1.6 0 0 0-2.45 0c-3.223 3.2-1.702 6.896 1.519 10.117 3.22 3.221 6.914 4.745 10.12 1.535a1.601 1.601 0 0 0 0-2.456Z"></path></svg>`), PhoneOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PhoneOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root545();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1545();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PhoneOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2545();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PhoneOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PhoneOutline = hmr(PhoneOutline, () => PhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneOutline[HMR].source;
    set(PhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var PhoneOutline_default = PhoneOutline;

// node_modules/flowbite-svelte-icons/dist/PhoneSolid.svelte
PhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneSolid.svelte";
var root_1546 = add_locations(from_svg(`<title> </title>`), PhoneSolid[FILENAME], [[41, 4]]);
var root_2546 = add_locations(from_svg(`<desc> </desc>`), PhoneSolid[FILENAME], [[44, 4]]);
var root546 = add_locations(from_svg(`<svg><!><!><path d="M7.978 4a2.553 2.553 0 0 0-1.926.877C4.233 6.7 3.699 8.751 4.153 10.814c.44 1.995 1.778 3.893 3.456 5.572 1.68 1.679 3.577 3.018 5.57 3.459 2.062.456 4.115-.073 5.94-1.885a2.556 2.556 0 0 0 .001-3.861l-1.21-1.21a2.689 2.689 0 0 0-3.802 0l-.617.618a.806.806 0 0 1-1.14 0l-1.854-1.855a.807.807 0 0 1 0-1.14l.618-.62a2.692 2.692 0 0 0 0-3.803l-1.21-1.211A2.555 2.555 0 0 0 7.978 4Z"></path></svg>`), PhoneSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PhoneSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root546();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1546();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PhoneSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2546();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PhoneSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PhoneSolid = hmr(PhoneSolid, () => PhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneSolid[HMR].source;
    set(PhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var PhoneSolid_default = PhoneSolid;

// node_modules/flowbite-svelte-icons/dist/PizzaSliceOutline.svelte
PizzaSliceOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PizzaSliceOutline.svelte";
var root_1547 = add_locations(from_svg(`<title> </title>`), PizzaSliceOutline[FILENAME], [[43, 4]]);
var root_2547 = add_locations(from_svg(`<desc> </desc>`), PizzaSliceOutline[FILENAME], [[46, 4]]);
var root547 = add_locations(from_svg(`<svg><!><!><g clip-path="url(#a)"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.4149 10.7623.0005.0109m3.0868 3.0764.0005.0108M8.91554 15.349l.00046.0108m-.8276-8.44549L4.39857 19.9133l12.95163-3.7371m-.8271-8.43475c2.0971 2.09707 3.269 4.77055 3.5172 7.51635.067.7413-.4619 1.3752-1.1869 1.5293-1.0146.2158-1.9613-.5811-2.0926-1.615-.2412-1.9-.9437-3.5721-2.52-5.1484-1.5779-1.57793-3.3173-2.3457-5.25302-2.61955-1.02139-.1445-1.79555-1.1099-1.5387-2.10314.17236-.66653.76818-1.14208 1.45754-1.08543 2.78088.22851 5.49388 1.40332 7.61648 3.52587Z"></path></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h24v24H0z"></path></clipPath></defs></svg>`), PizzaSliceOutline[FILENAME], [
  [31, 0, [[48, 2, [[49, 4]]], [56, 7, [[56, 14, [[56, 32]]]]]]]
]);
function PizzaSliceOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PizzaSliceOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root547();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1547();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PizzaSliceOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2547();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PizzaSliceOutline,
      45,
      2
    );
  }
  var g = sibling(node_1);
  var path = child(g);
  reset(g);
  next();
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PizzaSliceOutline = hmr(PizzaSliceOutline, () => PizzaSliceOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PizzaSliceOutline[HMR].source;
    set(PizzaSliceOutline[HMR].source, module.default[HMR].original);
  });
}
var PizzaSliceOutline_default = PizzaSliceOutline;

// node_modules/flowbite-svelte-icons/dist/PizzaSliceSolid.svelte
PizzaSliceSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PizzaSliceSolid.svelte";
var root_1548 = add_locations(from_svg(`<title> </title>`), PizzaSliceSolid[FILENAME], [[41, 4]]);
var root_2548 = add_locations(from_svg(`<desc> </desc>`), PizzaSliceSolid[FILENAME], [[44, 4]]);
var root548 = add_locations(from_svg(`<svg><!><!><path d="M8.9884 3.21891c3.0076.24714 5.945 1.51873 8.2417 3.8154 2.269 2.26907 3.5376 5.16369 3.806 8.13349.1181 1.3063-.817 2.3512-1.9748 2.5974-.3781.0805-.7426.0766-1.0826.0053-.0526-.9449-.1322-1.9863-.2259-2.7243-.2666-2.0994-1.0578-3.9824-2.805-5.72956-1.7428-1.74283-3.6864-2.60074-5.82006-2.9026-.44367-.06276-1.6162-.18893-2.69208-.26801-.06233-.34562-.05329-.7147.04516-1.0954.2799-1.0824 1.27852-1.93272 2.50758-1.83172Z"></path><path fill-rule="evenodd" d="M15.7687 15.2981c.0789.6213.1481 1.4924.1977 2.3181L4.6757 20.8741c-.34909.1007-.72534.0042-.98281-.2521-.25747-.2564-.35564-.6322-.25642-.9817L6.69176 8.17203c.89043.07337 1.79027.17058 2.15583.2223 1.73781.24585 3.27301.92348 4.68601 2.33657 1.4054 1.4054 2.0192 2.8665 2.2351 4.5672Zm-4.3548-4.5789c-.0238-.5518-.4904-.97977-1.0422-.95597-.55178.02381-.97978.49037-.95598 1.04217l.00047.0108c.0238.5518.4904.9798 1.04221.956.5517-.0238.9797-.4904.9559-1.0422l-.0004-.0108Zm3.0873 3.0873c-.0238-.5518-.4904-.9798-1.0422-.956-.5518.0238-.9798.4904-.956 1.0422l.0005.0108c.0238.5518.4903.9798 1.0421.956.5518-.0238.9798-.4904.956-1.0421l-.0004-.0109Zm-4.58671 1.4994c-.02377-.5517-.49034-.9798-1.04211-.956-.55177.0238-.9798.4903-.95603 1.0421l.00046.0108c.02377.5518.49034.9798 1.04211.9561.55178-.0238.97981-.4904.95604-1.0421l-.00047-.0109Z" clip-rule="evenodd"></path></svg>`), PizzaSliceSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function PizzaSliceSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PizzaSliceSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root548();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1548();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PizzaSliceSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2548();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PizzaSliceSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PizzaSliceSolid = hmr(PizzaSliceSolid, () => PizzaSliceSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PizzaSliceSolid[HMR].source;
    set(PizzaSliceSolid[HMR].source, module.default[HMR].original);
  });
}
var PizzaSliceSolid_default = PizzaSliceSolid;

// node_modules/flowbite-svelte-icons/dist/PlateWheatOutline.svelte
PlateWheatOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlateWheatOutline.svelte";
var root_1549 = add_locations(from_svg(`<title> </title>`), PlateWheatOutline[FILENAME], [[43, 4]]);
var root_2549 = add_locations(from_svg(`<desc> </desc>`), PlateWheatOutline[FILENAME], [[46, 4]]);
var root549 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 5.00003h1M5 11h1M3 8.00003h4m8.5 0c-.1016.11084-1.5385-1.15738-1.7964-1.482-.3299-.41512-.7812-1.43054-.6974-1.50634.0838-.0758 1.1161.68119 1.3741 1.00581.258.32462 1.2213 1.87169 1.1197 1.98253Zm0 0c-.1016-.11084-1.5385 1.15738-1.7964 1.482-.3299.41512-.7812 1.43057-.6974 1.50637.0838.0758 1.1161-.6812 1.3741-1.00584.258-.32462 1.2213-1.87169 1.1197-1.98253Zm4 0c-.1016.11084-1.5385-1.15738-1.7964-1.482-.3299-.41512-.7812-1.43054-.6974-1.50634.0838-.0758 1.1161.68119 1.3741 1.00581.258.32462 1.2213 1.87169 1.1197 1.98253Zm0 0c-.1016-.11084-1.5385 1.15738-1.7964 1.482-.3299.41512-.7812 1.43057-.6974 1.50637.0838.0758 1.1161-.6812 1.3741-1.00584.258-.32462 1.2213-1.87169 1.1197-1.98253Zm-8.5 0h10m-9.9943-.00001c-.1016.11084-1.53849-1.15738-1.79646-1.48201-.32987-.41511-.7812-1.43053-.69738-1.50633.08383-.0758 1.11614.68118 1.3741 1.00581.25794.32462 1.22124 1.87168 1.11974 1.98253Zm0 0c-.1016-.11085-1.53849 1.1574-1.79646 1.48203-.32987.41511-.7812 1.43055-.69738 1.50635.08383.0758 1.11614-.6812 1.3741-1.00582.25794-.32463 1.22124-1.87172 1.11974-1.98256ZM8.59868 18.0116V19h6.80262v-.9884C18.39 17.3447 20.5872 15.8251 21 14H3c.41284 1.8251 2.60995 3.3447 5.59868 4.0116Z"></path></svg>`), PlateWheatOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PlateWheatOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PlateWheatOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root549();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1549();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PlateWheatOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2549();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PlateWheatOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PlateWheatOutline = hmr(PlateWheatOutline, () => PlateWheatOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlateWheatOutline[HMR].source;
    set(PlateWheatOutline[HMR].source, module.default[HMR].original);
  });
}
var PlateWheatOutline_default = PlateWheatOutline;

// node_modules/flowbite-svelte-icons/dist/PlateWheatSolid.svelte
PlateWheatSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlateWheatSolid.svelte";
var root_1550 = add_locations(from_svg(`<title> </title>`), PlateWheatSolid[FILENAME], [[41, 4]]);
var root_2550 = add_locations(from_svg(`<desc> </desc>`), PlateWheatSolid[FILENAME], [[44, 4]]);
var root550 = add_locations(from_svg(`<svg><!><!><path d="M5.00001 4.00003c-.55229 0-1 .44772-1 1 0 .55229.44771 1 1 1h1c.55228 0 1-.44771 1-1 0-.55228-.44772-1-1-1h-1Zm5.66889 1.39531c-.2216-.27879-.645-.61839-.94433-.83763-.16499-.12086-.34155-.24116-.49677-.33129-.072-.04181-.17435-.09779-.28569-.14043-.05091-.0195-.15457-.05642-.2853-.07202-.07757-.00926-.47279-.05405-.81565.25599-.28283.25575-.32408.57239-.33352.663-.01301.12501-.0017.22937.00606.28539.0164.11839.04792.22824.0723.30499.05229.16466.12863.35151.20939.5288.15481.33984.39005.78485.63096 1.08802.16417.20658.53268.55501.87921.85987-.34653.30486-.71505.65329-.87921.85988-.24091.30316-.47615.74817-.63096 1.08801-.08076.17728-.1571.36418-.20939.52878-.02438.0768-.0559.1866-.0723.305-.00776.056-.01907.1604-.00606.2854.00944.0906.05069.4072.33352.663.34286.31.73807.2653.81565.256.13073-.0156.23439-.0525.2853-.072.11134-.0427.21369-.0986.28569-.1405.15522-.0901.33178-.2104.49677-.3313.29933-.2192.72273-.5588.94433-.8376.1753-.2206.5103-.74026.773-1.18533.082-.13908.1641-.28267.2378-.41934h1.1367c-.2032.28993-.3943.65733-.5267.94787-.0807.1773-.1571.3642-.2094.5288-.0243.0768-.0559.1866-.0723.305-.0077.056-.019.1604-.006.2854.0094.0906.0507.4072.3335.663.3429.31.7381.2652.8156.256.1308-.0156.2344-.0525.2853-.072.1114-.0427.2137-.0987.2857-.1405.1552-.0901.3318-.2104.4968-.3313.2993-.2192.7228-.5588.9443-.8376.1754-.2207.5103-.74026.773-1.18532.0821-.13908.1641-.28267.2378-.41935h.6424c-.2032.28993-.3943.65733-.5267.94787-.0807.1773-.1571.3642-.2094.5288-.0243.0768-.0559.1866-.0723.305-.0077.056-.019.1604-.006.2854.0094.0906.0507.4072.3335.663.3429.31.7381.2652.8156.256.1308-.0156.2344-.0525.2853-.072.1114-.0427.2137-.0987.2857-.1405.1552-.0901.3318-.2104.4968-.3313.2993-.2192.7228-.5588.9443-.8376.1754-.2207.5103-.74026.773-1.18532.0821-.13908.1641-.28267.2378-.41935h.8261c.5522 0 1-.44772 1-1s-.4478-1-1-1h-.8261c-.0737-.13668-.1557-.28027-.2378-.41935-.2627-.44506-.5976-.96467-.773-1.18532-.2215-.27879-.645-.61839-.9443-.83763-.165-.12086-.3416-.24117-.4968-.33129-.072-.04182-.1743-.09779-.2857-.14044-.0509-.0195-.1545-.05642-.2853-.07202-.0775-.00926-.4727-.05404-.8156.25599-.2828.25575-.3241.57239-.3335.66301-.013.125-.0017.22936.006.28538.0164.1184.048.22824.0723.30499.0523.16466.1287.35151.2094.52881.1324.29054.3235.65794.5267.94787h-.6424c-.0737-.13667-.1557-.28026-.2378-.41935-.2627-.44506-.5976-.96467-.773-1.18532-.2215-.27879-.645-.61839-.9443-.83763-.165-.12086-.3416-.24117-.4968-.33129-.072-.04182-.1743-.09779-.2857-.14044-.0509-.0195-.1545-.05642-.2853-.07202-.0775-.00926-.4727-.05404-.8156.25599-.2828.25576-.3241.57239-.3335.66301-.013.125-.0017.22936.006.28538.0164.1184.048.22824.0723.305.0523.16465.1287.3515.2094.5288.1324.29054.3235.65795.5267.94787h-1.1367c-.0737-.13668-.1558-.28027-.2378-.41936-.2627-.44506-.5977-.96467-.773-1.18533Z"></path><path d="M3.00001 7.00003c-.55229 0-1 .44772-1 1 0 .55229.44771 1 1 1h4c.55228 0 1-.44771 1-1 0-.55228-.44772-1-1-1h-4Zm2 2.99997c-.55229 0-1 .4477-1 1s.44771 1 1 1h1c.55228 0 1-.4477 1-1s-.44772-1-1-1h-1Zm-2 3c-.30399 0-.59147.1383-.78123.3758-.18976.2375-.2612.5484-.19413.8449.27848 1.231 1.1312 2.2553 2.23009 3.035.92161.6539 2.06605 1.1737 3.34395 1.5346V19c0 .5523.44772 1 1 1h6.80261c.5523 0 1-.4477 1-1v-.2097c1.2779-.3609 2.4224-.8807 3.344-1.5346 1.0989-.7797 1.9516-1.804 2.2301-3.035.067-.2965-.0044-.6074-.1942-.8449C21.5915 13.1383 21.304 13 21 13H3.00001Z"></path></svg>`), PlateWheatSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function PlateWheatSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PlateWheatSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root550();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1550();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PlateWheatSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2550();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PlateWheatSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PlateWheatSolid = hmr(PlateWheatSolid, () => PlateWheatSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlateWheatSolid[HMR].source;
    set(PlateWheatSolid[HMR].source, module.default[HMR].original);
  });
}
var PlateWheatSolid_default = PlateWheatSolid;

// node_modules/flowbite-svelte-icons/dist/PlayOutline.svelte
PlayOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlayOutline.svelte";
var root_1551 = add_locations(from_svg(`<title> </title>`), PlayOutline[FILENAME], [[43, 4]]);
var root_2551 = add_locations(from_svg(`<desc> </desc>`), PlayOutline[FILENAME], [[46, 4]]);
var root551 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 18V6l8 6-8 6Z"></path></svg>`), PlayOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PlayOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PlayOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root551();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1551();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PlayOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2551();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PlayOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PlayOutline = hmr(PlayOutline, () => PlayOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlayOutline[HMR].source;
    set(PlayOutline[HMR].source, module.default[HMR].original);
  });
}
var PlayOutline_default = PlayOutline;

// node_modules/flowbite-svelte-icons/dist/PlaySolid.svelte
PlaySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlaySolid.svelte";
var root_1552 = add_locations(from_svg(`<title> </title>`), PlaySolid[FILENAME], [[41, 4]]);
var root_2552 = add_locations(from_svg(`<desc> </desc>`), PlaySolid[FILENAME], [[44, 4]]);
var root552 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.6 5.2A1 1 0 0 0 7 6v12a1 1 0 0 0 1.6.8l8-6a1 1 0 0 0 0-1.6l-8-6Z" clip-rule="evenodd"></path></svg>`), PlaySolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PlaySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PlaySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root552();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1552();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PlaySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2552();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PlaySolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PlaySolid = hmr(PlaySolid, () => PlaySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlaySolid[HMR].source;
    set(PlaySolid[HMR].source, module.default[HMR].original);
  });
}
var PlaySolid_default = PlaySolid;

// node_modules/flowbite-svelte-icons/dist/PlusOutline.svelte
PlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlusOutline.svelte";
var root_1553 = add_locations(from_svg(`<title> </title>`), PlusOutline[FILENAME], [[43, 4]]);
var root_2553 = add_locations(from_svg(`<desc> </desc>`), PlusOutline[FILENAME], [[46, 4]]);
var root553 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14m-7 7V5"></path></svg>`), PlusOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PlusOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root553();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1553();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PlusOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2553();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PlusOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PlusOutline = hmr(PlusOutline, () => PlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlusOutline[HMR].source;
    set(PlusOutline[HMR].source, module.default[HMR].original);
  });
}
var PlusOutline_default = PlusOutline;

// node_modules/flowbite-svelte-icons/dist/PrinterOutline.svelte
PrinterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PrinterOutline.svelte";
var root_1554 = add_locations(from_svg(`<title> </title>`), PrinterOutline[FILENAME], [[43, 4]]);
var root_2554 = add_locations(from_svg(`<desc> </desc>`), PrinterOutline[FILENAME], [[46, 4]]);
var root554 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M16.444 18H19a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h2.556M17 11V5a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6h10ZM7 15h10v4a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-4Z"></path></svg>`), PrinterOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function PrinterOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PrinterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root554();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1554();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PrinterOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2554();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PrinterOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PrinterOutline = hmr(PrinterOutline, () => PrinterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PrinterOutline[HMR].source;
    set(PrinterOutline[HMR].source, module.default[HMR].original);
  });
}
var PrinterOutline_default = PrinterOutline;

// node_modules/flowbite-svelte-icons/dist/PrinterSolid.svelte
PrinterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PrinterSolid.svelte";
var root_1555 = add_locations(from_svg(`<title> </title>`), PrinterSolid[FILENAME], [[41, 4]]);
var root_2555 = add_locations(from_svg(`<desc> </desc>`), PrinterSolid[FILENAME], [[44, 4]]);
var root555 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 3a2 2 0 0 0-2 2v3h12V5a2 2 0 0 0-2-2H8Zm-3 7a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h1v-4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v4h1a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H5Zm4 11a1 1 0 0 1-1-1v-4h8v4a1 1 0 0 1-1 1H9Z" clip-rule="evenodd"></path></svg>`), PrinterSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function PrinterSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, PrinterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root555();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1555();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      PrinterSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2555();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      PrinterSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  PrinterSolid = hmr(PrinterSolid, () => PrinterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PrinterSolid[HMR].source;
    set(PrinterSolid[HMR].source, module.default[HMR].original);
  });
}
var PrinterSolid_default = PrinterSolid;

// node_modules/flowbite-svelte-icons/dist/ProfileCardOutline.svelte
ProfileCardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ProfileCardOutline.svelte";
var root_1556 = add_locations(from_svg(`<title> </title>`), ProfileCardOutline[FILENAME], [[43, 4]]);
var root_2556 = add_locations(from_svg(`<desc> </desc>`), ProfileCardOutline[FILENAME], [[46, 4]]);
var root556 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 9h3m-3 3h3m-3 3h3m-6 1c-.306-.613-.933-1-1.618-1H7.618c-.685 0-1.312.387-1.618 1M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Zm7 5a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), ProfileCardOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ProfileCardOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ProfileCardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root556();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1556();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ProfileCardOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2556();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ProfileCardOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ProfileCardOutline = hmr(ProfileCardOutline, () => ProfileCardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProfileCardOutline[HMR].source;
    set(ProfileCardOutline[HMR].source, module.default[HMR].original);
  });
}
var ProfileCardOutline_default = ProfileCardOutline;

// node_modules/flowbite-svelte-icons/dist/ProfileCardSolid.svelte
ProfileCardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ProfileCardSolid.svelte";
var root_1557 = add_locations(from_svg(`<title> </title>`), ProfileCardSolid[FILENAME], [[41, 4]]);
var root_2557 = add_locations(from_svg(`<desc> </desc>`), ProfileCardSolid[FILENAME], [[44, 4]]);
var root557 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm10 5a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-8-5a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm1.942 4a3 3 0 0 0-2.847 2.051l-.044.133-.004.012c-.042.126-.055.167-.042.195.006.013.02.023.038.039.032.025.08.064.146.155A1 1 0 0 0 6 17h6a1 1 0 0 0 .811-.415.713.713 0 0 1 .146-.155c.019-.016.031-.026.038-.04.014-.027 0-.068-.042-.194l-.004-.012-.044-.133A3 3 0 0 0 10.059 14H7.942Z" clip-rule="evenodd"></path></svg>`), ProfileCardSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ProfileCardSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ProfileCardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root557();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1557();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ProfileCardSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2557();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ProfileCardSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ProfileCardSolid = hmr(ProfileCardSolid, () => ProfileCardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProfileCardSolid[HMR].source;
    set(ProfileCardSolid[HMR].source, module.default[HMR].original);
  });
}
var ProfileCardSolid_default = ProfileCardSolid;

// node_modules/flowbite-svelte-icons/dist/QrCodeOutline.svelte
QrCodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QrCodeOutline.svelte";
var root_1558 = add_locations(from_svg(`<title> </title>`), QrCodeOutline[FILENAME], [[43, 4]]);
var root_2558 = add_locations(from_svg(`<desc> </desc>`), QrCodeOutline[FILENAME], [[46, 4]]);
var root558 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 4h6v6H4V4Zm10 10h6v6h-6v-6Zm0-10h6v6h-6V4Zm-4 10h.01v.01H10V14Zm0 4h.01v.01H10V18Zm-3 2h.01v.01H7V20Zm0-4h.01v.01H7V16Zm-3 2h.01v.01H4V18Zm0-4h.01v.01H4V14Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M7 7h.01v.01H7V7Zm10 10h.01v.01H17V17Z"></path></svg>`), QrCodeOutline[FILENAME], [[31, 0, [[48, 2], [54, 2]]]]);
function QrCodeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, QrCodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root558();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1558();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      QrCodeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2558();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      QrCodeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  QrCodeOutline = hmr(QrCodeOutline, () => QrCodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QrCodeOutline[HMR].source;
    set(QrCodeOutline[HMR].source, module.default[HMR].original);
  });
}
var QrCodeOutline_default = QrCodeOutline;

// node_modules/flowbite-svelte-icons/dist/QuestionCircleOutline.svelte
QuestionCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuestionCircleOutline.svelte";
var root_1559 = add_locations(from_svg(`<title> </title>`), QuestionCircleOutline[FILENAME], [[43, 4]]);
var root_2559 = add_locations(from_svg(`<desc> </desc>`), QuestionCircleOutline[FILENAME], [[46, 4]]);
var root559 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.529 9.988a2.502 2.502 0 1 1 5 .191A2.441 2.441 0 0 1 12 12.582V14m-.01 3.008H12M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), QuestionCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function QuestionCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, QuestionCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root559();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1559();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      QuestionCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2559();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      QuestionCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  QuestionCircleOutline = hmr(QuestionCircleOutline, () => QuestionCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuestionCircleOutline[HMR].source;
    set(QuestionCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var QuestionCircleOutline_default = QuestionCircleOutline;

// node_modules/flowbite-svelte-icons/dist/QuestionCircleSolid.svelte
QuestionCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuestionCircleSolid.svelte";
var root_1560 = add_locations(from_svg(`<title> </title>`), QuestionCircleSolid[FILENAME], [[41, 4]]);
var root_2560 = add_locations(from_svg(`<desc> </desc>`), QuestionCircleSolid[FILENAME], [[44, 4]]);
var root560 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.008-3.018a1.502 1.502 0 0 1 2.522 1.159v.024a1.44 1.44 0 0 1-1.493 1.418 1 1 0 0 0-1.037.999V14a1 1 0 1 0 2 0v-.539a3.44 3.44 0 0 0 2.529-3.256 3.502 3.502 0 0 0-7-.255 1 1 0 0 0 2 .076c.014-.398.187-.774.48-1.044Zm.982 7.026a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), QuestionCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function QuestionCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, QuestionCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root560();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1560();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      QuestionCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2560();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      QuestionCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  QuestionCircleSolid = hmr(QuestionCircleSolid, () => QuestionCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuestionCircleSolid[HMR].source;
    set(QuestionCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var QuestionCircleSolid_default = QuestionCircleSolid;

// node_modules/flowbite-svelte-icons/dist/QuoteOutline.svelte
QuoteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuoteOutline.svelte";
var root_1561 = add_locations(from_svg(`<title> </title>`), QuoteOutline[FILENAME], [[43, 4]]);
var root_2561 = add_locations(from_svg(`<desc> </desc>`), QuoteOutline[FILENAME], [[46, 4]]);
var root561 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 11V8a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1Zm0 0v2a4 4 0 0 1-4 4H5m14-6V8a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1Zm0 0v2a4 4 0 0 1-4 4h-1"></path></svg>`), QuoteOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function QuoteOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, QuoteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root561();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1561();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      QuoteOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2561();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      QuoteOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  QuoteOutline = hmr(QuoteOutline, () => QuoteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuoteOutline[HMR].source;
    set(QuoteOutline[HMR].source, module.default[HMR].original);
  });
}
var QuoteOutline_default = QuoteOutline;

// node_modules/flowbite-svelte-icons/dist/QuoteSolid.svelte
QuoteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuoteSolid.svelte";
var root_1562 = add_locations(from_svg(`<title> </title>`), QuoteSolid[FILENAME], [[41, 4]]);
var root_2562 = add_locations(from_svg(`<desc> </desc>`), QuoteSolid[FILENAME], [[44, 4]]);
var root562 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 6a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a3 3 0 0 1-3 3H5a1 1 0 1 0 0 2h1a5 5 0 0 0 5-5V8a2 2 0 0 0-2-2H6Zm9 0a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1a5 5 0 0 0 5-5V8a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), QuoteSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function QuoteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, QuoteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root562();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1562();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      QuoteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2562();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      QuoteSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  QuoteSolid = hmr(QuoteSolid, () => QuoteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuoteSolid[HMR].source;
    set(QuoteSolid[HMR].source, module.default[HMR].original);
  });
}
var QuoteSolid_default = QuoteSolid;

// node_modules/flowbite-svelte-icons/dist/ReactSolid.svelte
ReactSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReactSolid.svelte";
var root_1563 = add_locations(from_svg(`<title> </title>`), ReactSolid[FILENAME], [[41, 4]]);
var root_2563 = add_locations(from_svg(`<desc> </desc>`), ReactSolid[FILENAME], [[44, 4]]);
var root563 = add_locations(from_svg(`<svg><!><!><path d="M21.718 12c0-1.429-1.339-2.681-3.467-3.5.029-.18.077-.37.1-.545.217-2.058-.273-3.543-1.379-4.182-1.235-.714-2.983-.186-4.751 1.239C10.45 3.589 8.7 3.061 7.468 3.773c-1.107.639-1.6 2.124-1.379 4.182.018.175.067.365.095.545-2.127.819-3.466 2.071-3.466 3.5 0 1.429 1.339 2.681 3.466 3.5-.028.18-.077.37-.095.545-.218 2.058.272 3.543 1.379 4.182.376.213.803.322 1.235.316a5.987 5.987 0 0 0 3.514-1.56 5.992 5.992 0 0 0 3.515 1.56 2.44 2.44 0 0 0 1.236-.316c1.106-.639 1.6-2.124 1.379-4.182-.019-.175-.067-.365-.1-.545 2.132-.819 3.471-2.071 3.471-3.5Zm-6.01-7.548a1.5 1.5 0 0 1 .76.187c.733.424 1.055 1.593.884 3.212-.012.106-.043.222-.058.33-.841-.243-1.7-.418-2.57-.523a16.165 16.165 0 0 0-1.747-1.972 4.9 4.9 0 0 1 2.731-1.234Zm-7.917 8.781c.172.34.335.68.529 1.017.194.337.395.656.6.969a14.09 14.09 0 0 1-1.607-.376 14.38 14.38 0 0 1 .478-1.61Zm-.479-4.076a14.085 14.085 0 0 1 1.607-.376c-.205.313-.405.634-.6.969-.195.335-.357.677-.529 1.017-.19-.527-.35-1.064-.478-1.61ZM8.3 12a19.32 19.32 0 0 1 .888-1.75c.33-.568.69-1.118 1.076-1.65.619-.061 1.27-.1 1.954-.1.684 0 1.333.035 1.952.1a19.63 19.63 0 0 1 1.079 1.654c.325.567.621 1.15.887 1.746a18.869 18.869 0 0 1-1.953 3.403 19.218 19.218 0 0 1-3.931 0 20.169 20.169 0 0 1-1.066-1.653A19.324 19.324 0 0 1 8.3 12Zm7.816 2.25c.2-.337.358-.677.53-1.017.191.527.35 1.065.478 1.611a14.48 14.48 0 0 1-1.607.376c.202-.314.404-.635.597-.97h.002Zm.53-3.483c-.172-.34-.335-.68-.53-1.017a20.214 20.214 0 0 0-.6-.97c.542.095 1.078.22 1.606.376a14.111 14.111 0 0 1-.478 1.611h.002ZM12.217 6.34c.4.375.777.773 1.13 1.193-.37-.02-.746-.033-1.129-.033s-.76.013-1.131.033c.353-.42.73-.817 1.13-1.193Zm-4.249-1.7a1.5 1.5 0 0 1 .76-.187 4.9 4.9 0 0 1 2.729 1.233A16.253 16.253 0 0 0 9.71 7.658c-.87.105-1.728.28-2.569.524-.015-.109-.047-.225-.058-.331-.171-1.619.151-2.787.885-3.211ZM3.718 12c0-.9.974-1.83 2.645-2.506.218.857.504 1.695.856 2.506-.352.811-.638 1.65-.856 2.506C4.692 13.83 3.718 12.9 3.718 12Zm4.25 7.361c-.734-.423-1.056-1.593-.885-3.212.011-.106.043-.222.058-.331.84.243 1.697.418 2.564.524a16.37 16.37 0 0 0 1.757 1.982c-1.421 1.109-2.714 1.488-3.494 1.037Zm3.11-2.895c.374.021.753.034 1.14.034.387 0 .765-.013 1.139-.034a14.4 14.4 0 0 1-1.14 1.215 14.248 14.248 0 0 1-1.139-1.215Zm5.39 2.895c-.782.451-2.075.072-3.5-1.038a16.248 16.248 0 0 0 1.757-1.981 16.41 16.41 0 0 0 2.565-.523c.015.108.046.224.058.33.175 1.619-.148 2.789-.88 3.212Zm1.6-4.854A16.563 16.563 0 0 0 17.216 12c.352-.812.638-1.65.856-2.507 1.671.677 2.646 1.607 2.646 2.507 0 .9-.975 1.83-2.646 2.507h-.004Z"></path><path d="M12.215 13.773a1.792 1.792 0 1 0-1.786-1.8v.006a1.787 1.787 0 0 0 1.786 1.794Z"></path></svg>`), ReactSolid[FILENAME], [[30, 0, [[46, 2], [48, 5]]]]);
function ReactSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReactSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root563();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1563();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReactSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2563();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReactSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReactSolid = hmr(ReactSolid, () => ReactSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReactSolid[HMR].source;
    set(ReactSolid[HMR].source, module.default[HMR].original);
  });
}
var ReactSolid_default = ReactSolid;

// node_modules/flowbite-svelte-icons/dist/ReceiptOutline.svelte
ReceiptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReceiptOutline.svelte";
var root_1564 = add_locations(from_svg(`<title> </title>`), ReceiptOutline[FILENAME], [[43, 4]]);
var root_2564 = add_locations(from_svg(`<desc> </desc>`), ReceiptOutline[FILENAME], [[46, 4]]);
var root564 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 8h6m-6 4h6m-6 4h6M6 3v18l2-2 2 2 2-2 2 2 2-2 2 2V3l-2 2-2-2-2 2-2-2-2 2-2-2Z"></path></svg>`), ReceiptOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ReceiptOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReceiptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root564();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1564();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReceiptOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2564();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReceiptOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReceiptOutline = hmr(ReceiptOutline, () => ReceiptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReceiptOutline[HMR].source;
    set(ReceiptOutline[HMR].source, module.default[HMR].original);
  });
}
var ReceiptOutline_default = ReceiptOutline;

// node_modules/flowbite-svelte-icons/dist/ReceiptSolid.svelte
ReceiptSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReceiptSolid.svelte";
var root_1565 = add_locations(from_svg(`<title> </title>`), ReceiptSolid[FILENAME], [[41, 4]]);
var root_2565 = add_locations(from_svg(`<desc> </desc>`), ReceiptSolid[FILENAME], [[44, 4]]);
var root565 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.617 2.076a1 1 0 0 1 1.09.217L8 3.586l1.293-1.293a1 1 0 0 1 1.414 0L12 3.586l1.293-1.293a1 1 0 0 1 1.414 0L16 3.586l1.293-1.293A1 1 0 0 1 19 3v18a1 1 0 0 1-1.707.707L16 20.414l-1.293 1.293a1 1 0 0 1-1.414 0L12 20.414l-1.293 1.293a1 1 0 0 1-1.414 0L8 20.414l-1.293 1.293A1 1 0 0 1 5 21V3a1 1 0 0 1 .617-.924ZM9 7a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2H9Zm0 4a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Zm0 4a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ReceiptSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ReceiptSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReceiptSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root565();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1565();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReceiptSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2565();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReceiptSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReceiptSolid = hmr(ReceiptSolid, () => ReceiptSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReceiptSolid[HMR].source;
    set(ReceiptSolid[HMR].source, module.default[HMR].original);
  });
}
var ReceiptSolid_default = ReceiptSolid;

// node_modules/flowbite-svelte-icons/dist/RectangleListOutline.svelte
RectangleListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RectangleListOutline.svelte";
var root_1566 = add_locations(from_svg(`<title> </title>`), RectangleListOutline[FILENAME], [[43, 4]]);
var root_2566 = add_locations(from_svg(`<desc> </desc>`), RectangleListOutline[FILENAME], [[46, 4]]);
var root566 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 9h6m-6 3h6m-6 3h6M6.996 9h.01m-.01 3h.01m-.01 3h.01M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), RectangleListOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RectangleListOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RectangleListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root566();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1566();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RectangleListOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2566();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RectangleListOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RectangleListOutline = hmr(RectangleListOutline, () => RectangleListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RectangleListOutline[HMR].source;
    set(RectangleListOutline[HMR].source, module.default[HMR].original);
  });
}
var RectangleListOutline_default = RectangleListOutline;

// node_modules/flowbite-svelte-icons/dist/RectangleListSolid.svelte
RectangleListSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RectangleListSolid.svelte";
var root_1567 = add_locations(from_svg(`<title> </title>`), RectangleListSolid[FILENAME], [[41, 4]]);
var root_2567 = add_locations(from_svg(`<desc> </desc>`), RectangleListSolid[FILENAME], [[44, 4]]);
var root567 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm4.996 2a1 1 0 0 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 8a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Zm-4.004 3a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 11a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Zm-4.004 3a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 14a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z" clip-rule="evenodd"></path></svg>`), RectangleListSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function RectangleListSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RectangleListSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root567();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1567();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RectangleListSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2567();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RectangleListSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RectangleListSolid = hmr(RectangleListSolid, () => RectangleListSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RectangleListSolid[HMR].source;
    set(RectangleListSolid[HMR].source, module.default[HMR].original);
  });
}
var RectangleListSolid_default = RectangleListSolid;

// node_modules/flowbite-svelte-icons/dist/RedditSolid.svelte
RedditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RedditSolid.svelte";
var root_1568 = add_locations(from_svg(`<title> </title>`), RedditSolid[FILENAME], [[41, 4]]);
var root_2568 = add_locations(from_svg(`<desc> </desc>`), RedditSolid[FILENAME], [[44, 4]]);
var root568 = add_locations(from_svg(`<svg><!><!><path d="M12.008 16.521a3.84 3.84 0 0 0 2.47-.77v.04a.281.281 0 0 0 .005-.396.281.281 0 0 0-.395-.005 3.291 3.291 0 0 1-2.09.61 3.266 3.266 0 0 1-2.081-.63.27.27 0 0 0-.38.381 3.84 3.84 0 0 0 2.47.77Z"></path><path fill-rule="evenodd" d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-4.845-1.407A1.463 1.463 0 0 1 18.67 12a1.46 1.46 0 0 1-.808 1.33c.01.146.01.293 0 .44 0 2.242-2.61 4.061-5.829 4.061s-5.83-1.821-5.83-4.061a3.25 3.25 0 0 1 0-.44 1.458 1.458 0 0 1-.457-2.327 1.458 1.458 0 0 1 2.063-.064 7.163 7.163 0 0 1 3.9-1.23l.738-3.47v-.006a.31.31 0 0 1 .37-.236l2.452.49a1 1 0 1 1-.132.611l-2.14-.45-.649 3.12a7.11 7.11 0 0 1 3.85 1.23c.259-.246.6-.393.957-.405Z" clip-rule="evenodd"></path><path d="M15.305 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-4.625 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`), RedditSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [53, 5]]]]);
function RedditSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RedditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root568();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1568();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RedditSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2568();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RedditSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RedditSolid = hmr(RedditSolid, () => RedditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RedditSolid[HMR].source;
    set(RedditSolid[HMR].source, module.default[HMR].original);
  });
}
var RedditSolid_default = RedditSolid;

// node_modules/flowbite-svelte-icons/dist/RedoOutline.svelte
RedoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RedoOutline.svelte";
var root_1569 = add_locations(from_svg(`<title> </title>`), RedoOutline[FILENAME], [[43, 4]]);
var root_2569 = add_locations(from_svg(`<desc> </desc>`), RedoOutline[FILENAME], [[46, 4]]);
var root569 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 9H8a5 5 0 0 0 0 10h9m4-10-4-4m4 4-4 4"></path></svg>`), RedoOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RedoOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RedoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root569();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1569();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RedoOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2569();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RedoOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RedoOutline = hmr(RedoOutline, () => RedoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RedoOutline[HMR].source;
    set(RedoOutline[HMR].source, module.default[HMR].original);
  });
}
var RedoOutline_default = RedoOutline;

// node_modules/flowbite-svelte-icons/dist/RefreshOutline.svelte
RefreshOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RefreshOutline.svelte";
var root_1570 = add_locations(from_svg(`<title> </title>`), RefreshOutline[FILENAME], [[43, 4]]);
var root_2570 = add_locations(from_svg(`<desc> </desc>`), RefreshOutline[FILENAME], [[46, 4]]);
var root570 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4"></path></svg>`), RefreshOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RefreshOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RefreshOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root570();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1570();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RefreshOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2570();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RefreshOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RefreshOutline = hmr(RefreshOutline, () => RefreshOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RefreshOutline[HMR].source;
    set(RefreshOutline[HMR].source, module.default[HMR].original);
  });
}
var RefreshOutline_default = RefreshOutline;

// node_modules/flowbite-svelte-icons/dist/ReplyAllOutline.svelte
ReplyAllOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyAllOutline.svelte";
var root_1571 = add_locations(from_svg(`<title> </title>`), ReplyAllOutline[FILENAME], [[43, 4]]);
var root_2571 = add_locations(from_svg(`<desc> </desc>`), ReplyAllOutline[FILENAME], [[46, 4]]);
var root571 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.757 6 3.24 10.95a1.05 1.05 0 0 0 0 1.549l5.611 5.088m5.73-3.214v1.615a.948.948 0 0 1-1.524.845l-5.108-4.251a1.1 1.1 0 0 1 0-1.646l5.108-4.251a.95.95 0 0 1 1.524.846v1.7c3.312 0 6 2.979 6 6.654v1.329a.7.7 0 0 1-1.345.353 5.174 5.174 0 0 0-4.652-3.191l-.003-.003Z"></path></svg>`), ReplyAllOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ReplyAllOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReplyAllOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root571();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1571();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReplyAllOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2571();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReplyAllOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReplyAllOutline = hmr(ReplyAllOutline, () => ReplyAllOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyAllOutline[HMR].source;
    set(ReplyAllOutline[HMR].source, module.default[HMR].original);
  });
}
var ReplyAllOutline_default = ReplyAllOutline;

// node_modules/flowbite-svelte-icons/dist/ReplyAllSolid.svelte
ReplyAllSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyAllSolid.svelte";
var root_1572 = add_locations(from_svg(`<title> </title>`), ReplyAllSolid[FILENAME], [[41, 4]]);
var root_2572 = add_locations(from_svg(`<desc> </desc>`), ReplyAllSolid[FILENAME], [[44, 4]]);
var root572 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9.484 6.743c.41-.368.443-1 .077-1.41a.99.99 0 0 0-1.405-.078L2.67 10.203l-.007.006A2.048 2.048 0 0 0 2 11.721a2.058 2.058 0 0 0 .662 1.51l5.584 5.09a.99.99 0 0 0 1.405-.07 1.003 1.003 0 0 0-.07-1.412l-5.577-5.082a.05.05 0 0 1 0-.072l5.48-4.942Zm6.543 9.199v-.42a4.168 4.168 0 0 1 2.715 2.415c.154.382.44.695.806.88a1.683 1.683 0 0 0 2.167-.571c.214-.322.312-.707.279-1.092V15.88c0-3.77-2.526-7.039-5.966-7.573V7.57a1.957 1.957 0 0 0-.994-1.838 1.931 1.931 0 0 0-2.153.184L7.8 10.164a.753.753 0 0 0-.012.011l-.011.01a2.098 2.098 0 0 0-.703 1.57 2.108 2.108 0 0 0 .726 1.59l5.08 4.25a1.933 1.933 0 0 0 2.929-.614c.167-.32.242-.68.218-1.04Z" clip-rule="evenodd"></path></svg>`), ReplyAllSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ReplyAllSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReplyAllSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root572();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1572();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReplyAllSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2572();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReplyAllSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReplyAllSolid = hmr(ReplyAllSolid, () => ReplyAllSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyAllSolid[HMR].source;
    set(ReplyAllSolid[HMR].source, module.default[HMR].original);
  });
}
var ReplyAllSolid_default = ReplyAllSolid;

// node_modules/flowbite-svelte-icons/dist/ReplyOutline.svelte
ReplyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyOutline.svelte";
var root_1573 = add_locations(from_svg(`<title> </title>`), ReplyOutline[FILENAME], [[43, 4]]);
var root_2573 = add_locations(from_svg(`<desc> </desc>`), ReplyOutline[FILENAME], [[46, 4]]);
var root573 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.5 8.046H11V6.119c0-.921-.9-1.446-1.524-.894l-5.108 4.49a1.2 1.2 0 0 0 0 1.739l5.108 4.49c.624.556 1.524.027 1.524-.893v-1.928h2a3.023 3.023 0 0 1 3 3.046V19a5.593 5.593 0 0 0-1.5-10.954Z"></path></svg>`), ReplyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ReplyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReplyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root573();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1573();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReplyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2573();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReplyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReplyOutline = hmr(ReplyOutline, () => ReplyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyOutline[HMR].source;
    set(ReplyOutline[HMR].source, module.default[HMR].original);
  });
}
var ReplyOutline_default = ReplyOutline;

// node_modules/flowbite-svelte-icons/dist/ReplySolid.svelte
ReplySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplySolid.svelte";
var root_1574 = add_locations(from_svg(`<title> </title>`), ReplySolid[FILENAME], [[41, 4]]);
var root_2574 = add_locations(from_svg(`<desc> </desc>`), ReplySolid[FILENAME], [[44, 4]]);
var root574 = add_locations(from_svg(`<svg><!><!><path d="M14.502 7.046h-2.5v-.928a2.122 2.122 0 0 0-1.199-1.954 1.827 1.827 0 0 0-1.984.311L3.71 8.965a2.2 2.2 0 0 0 0 3.24L8.82 16.7a1.829 1.829 0 0 0 1.985.31 2.121 2.121 0 0 0 1.199-1.959v-.928h1a2.025 2.025 0 0 1 1.999 2.047V19a1 1 0 0 0 1.275.961 6.59 6.59 0 0 0 4.662-7.22 6.593 6.593 0 0 0-6.437-5.695Z"></path></svg>`), ReplySolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ReplySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ReplySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root574();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1574();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ReplySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2574();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ReplySolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ReplySolid = hmr(ReplySolid, () => ReplySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplySolid[HMR].source;
    set(ReplySolid[HMR].source, module.default[HMR].original);
  });
}
var ReplySolid_default = ReplySolid;

// node_modules/flowbite-svelte-icons/dist/RestoreWindowOutline.svelte
RestoreWindowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RestoreWindowOutline.svelte";
var root_1575 = add_locations(from_svg(`<title> </title>`), RestoreWindowOutline[FILENAME], [[43, 4]]);
var root_2575 = add_locations(from_svg(`<desc> </desc>`), RestoreWindowOutline[FILENAME], [[46, 4]]);
var root575 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 11.5h13m-13 0V18a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-6.5m-13 0V9a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v2.5M9 5h11a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-1"></path></svg>`), RestoreWindowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RestoreWindowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RestoreWindowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root575();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1575();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RestoreWindowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2575();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RestoreWindowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RestoreWindowOutline = hmr(RestoreWindowOutline, () => RestoreWindowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RestoreWindowOutline[HMR].source;
    set(RestoreWindowOutline[HMR].source, module.default[HMR].original);
  });
}
var RestoreWindowOutline_default = RestoreWindowOutline;

// node_modules/flowbite-svelte-icons/dist/RocketOutline.svelte
RocketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RocketOutline.svelte";
var root_1576 = add_locations(from_svg(`<title> </title>`), RocketOutline[FILENAME], [[43, 4]]);
var root_2576 = add_locations(from_svg(`<desc> </desc>`), RocketOutline[FILENAME], [[46, 4]]);
var root576 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.051 8.102-3.778.322-1.994 1.994a.94.94 0 0 0 .533 1.6l2.698.316m8.39 1.617-.322 3.78-1.994 1.994a.94.94 0 0 1-1.595-.533l-.4-2.652m8.166-11.174a1.366 1.366 0 0 0-1.12-1.12c-1.616-.279-4.906-.623-6.38.853-1.671 1.672-5.211 8.015-6.31 10.023a.932.932 0 0 0 .162 1.111l.828.835.833.832a.932.932 0 0 0 1.111.163c2.008-1.102 8.35-4.642 10.021-6.312 1.475-1.478 1.133-4.77.855-6.385Zm-2.961 3.722a1.88 1.88 0 1 1-3.76 0 1.88 1.88 0 0 1 3.76 0Z"></path></svg>`), RocketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RocketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RocketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root576();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1576();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RocketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2576();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RocketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RocketOutline = hmr(RocketOutline, () => RocketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RocketOutline[HMR].source;
    set(RocketOutline[HMR].source, module.default[HMR].original);
  });
}
var RocketOutline_default = RocketOutline;

// node_modules/flowbite-svelte-icons/dist/RocketSolid.svelte
RocketSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RocketSolid.svelte";
var root_1577 = add_locations(from_svg(`<title> </title>`), RocketSolid[FILENAME], [[41, 4]]);
var root_2577 = add_locations(from_svg(`<desc> </desc>`), RocketSolid[FILENAME], [[44, 4]]);
var root577 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M20.337 3.664c.213.212.354.486.404.782.294 1.711.657 5.195-.906 6.76-1.77 1.768-8.485 5.517-10.611 6.683a.987.987 0 0 1-1.176-.173l-.882-.88-.877-.884a.988.988 0 0 1-.173-1.177c1.165-2.126 4.913-8.841 6.682-10.611 1.562-1.563 5.046-1.198 6.757-.904.296.05.57.191.782.404ZM5.407 7.576l4-.341-2.69 4.48-2.857-.334a.996.996 0 0 1-.565-1.694l2.112-2.111Zm11.357 7.02-.34 4-2.111 2.113a.996.996 0 0 1-1.69-.565l-.422-2.807 4.563-2.74Zm.84-6.21a1.99 1.99 0 1 1-3.98 0 1.99 1.99 0 0 1 3.98 0Z" clip-rule="evenodd"></path></svg>`), RocketSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function RocketSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RocketSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root577();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1577();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RocketSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2577();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RocketSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RocketSolid = hmr(RocketSolid, () => RocketSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RocketSolid[HMR].source;
    set(RocketSolid[HMR].source, module.default[HMR].original);
  });
}
var RocketSolid_default = RocketSolid;

// node_modules/flowbite-svelte-icons/dist/RulerCombinedOutline.svelte
RulerCombinedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RulerCombinedOutline.svelte";
var root_1578 = add_locations(from_svg(`<title> </title>`), RulerCombinedOutline[FILENAME], [[43, 4]]);
var root_2578 = add_locations(from_svg(`<desc> </desc>`), RulerCombinedOutline[FILENAME], [[46, 4]]);
var root578 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 7H7m2 3H7m2 3H7m4 2v2m3-2v2m3-2v2M4 5v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1h-9a1 1 0 0 1-1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1Z"></path></svg>`), RulerCombinedOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function RulerCombinedOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RulerCombinedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root578();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1578();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RulerCombinedOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2578();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RulerCombinedOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RulerCombinedOutline = hmr(RulerCombinedOutline, () => RulerCombinedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RulerCombinedOutline[HMR].source;
    set(RulerCombinedOutline[HMR].source, module.default[HMR].original);
  });
}
var RulerCombinedOutline_default = RulerCombinedOutline;

// node_modules/flowbite-svelte-icons/dist/RulerCombinedSolid.svelte
RulerCombinedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RulerCombinedSolid.svelte";
var root_1579 = add_locations(from_svg(`<title> </title>`), RulerCombinedSolid[FILENAME], [[41, 4]]);
var root_2579 = add_locations(from_svg(`<desc> </desc>`), RulerCombinedSolid[FILENAME], [[44, 4]]);
var root579 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2h-1v3a1 1 0 1 1-2 0v-3h-1v3a1 1 0 1 1-2 0v-3h-1v3a1 1 0 1 1-2 0v-3H7a1 1 0 1 1 0-2h3v-1H7a1 1 0 1 1 0-2h3V8H7a1 1 0 0 1 0-2h3V5a2 2 0 0 0-2-2H5Z" clip-rule="evenodd"></path></svg>`), RulerCombinedSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function RulerCombinedSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, RulerCombinedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root579();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1579();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      RulerCombinedSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2579();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      RulerCombinedSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  RulerCombinedSolid = hmr(RulerCombinedSolid, () => RulerCombinedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RulerCombinedSolid[HMR].source;
    set(RulerCombinedSolid[HMR].source, module.default[HMR].original);
  });
}
var RulerCombinedSolid_default = RulerCombinedSolid;

// node_modules/flowbite-svelte-icons/dist/SalePercentOutline.svelte
SalePercentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SalePercentOutline.svelte";
var root_1580 = add_locations(from_svg(`<title> </title>`), SalePercentOutline[FILENAME], [[43, 4]]);
var root_2580 = add_locations(from_svg(`<desc> </desc>`), SalePercentOutline[FILENAME], [[46, 4]]);
var root580 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.891 15.107 15.11 8.89m-5.183-.52h.01m3.089 7.254h.01M14.08 3.902a2.849 2.849 0 0 0 2.176.902 2.845 2.845 0 0 1 2.94 2.94 2.849 2.849 0 0 0 .901 2.176 2.847 2.847 0 0 1 0 4.16 2.848 2.848 0 0 0-.901 2.175 2.843 2.843 0 0 1-2.94 2.94 2.848 2.848 0 0 0-2.176.902 2.847 2.847 0 0 1-4.16 0 2.85 2.85 0 0 0-2.176-.902 2.845 2.845 0 0 1-2.94-2.94 2.848 2.848 0 0 0-.901-2.176 2.848 2.848 0 0 1 0-4.16 2.849 2.849 0 0 0 .901-2.176 2.845 2.845 0 0 1 2.941-2.94 2.849 2.849 0 0 0 2.176-.901 2.847 2.847 0 0 1 4.159 0Z"></path></svg>`), SalePercentOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SalePercentOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SalePercentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root580();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1580();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SalePercentOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2580();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SalePercentOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SalePercentOutline = hmr(SalePercentOutline, () => SalePercentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SalePercentOutline[HMR].source;
    set(SalePercentOutline[HMR].source, module.default[HMR].original);
  });
}
var SalePercentOutline_default = SalePercentOutline;

// node_modules/flowbite-svelte-icons/dist/SalePercentSolid.svelte
SalePercentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SalePercentSolid.svelte";
var root_1581 = add_locations(from_svg(`<title> </title>`), SalePercentSolid[FILENAME], [[41, 4]]);
var root_2581 = add_locations(from_svg(`<desc> </desc>`), SalePercentSolid[FILENAME], [[44, 4]]);
var root581 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M20.29 8.567c.133.323.334.613.59.85v.002a3.536 3.536 0 0 1 0 5.166 2.442 2.442 0 0 0-.776 1.868 3.534 3.534 0 0 1-3.651 3.653 2.483 2.483 0 0 0-1.87.776 3.537 3.537 0 0 1-5.164 0 2.44 2.44 0 0 0-1.87-.776 3.533 3.533 0 0 1-3.653-3.654 2.44 2.44 0 0 0-.775-1.868 3.537 3.537 0 0 1 0-5.166 2.44 2.44 0 0 0 .775-1.87 3.55 3.55 0 0 1 1.033-2.62 3.594 3.594 0 0 1 2.62-1.032 2.401 2.401 0 0 0 1.87-.775 3.535 3.535 0 0 1 5.165 0 2.444 2.444 0 0 0 1.869.775 3.532 3.532 0 0 1 3.652 3.652c-.012.35.051.697.184 1.02ZM9.927 7.371a1 1 0 1 0 0 2h.01a1 1 0 0 0 0-2h-.01Zm5.889 2.226a1 1 0 0 0-1.414-1.415L8.184 14.4a1 1 0 0 0 1.414 1.414l6.218-6.217Zm-2.79 5.028a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), SalePercentSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function SalePercentSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SalePercentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root581();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1581();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SalePercentSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2581();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SalePercentSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SalePercentSolid = hmr(SalePercentSolid, () => SalePercentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SalePercentSolid[HMR].source;
    set(SalePercentSolid[HMR].source, module.default[HMR].original);
  });
}
var SalePercentSolid_default = SalePercentSolid;

// node_modules/flowbite-svelte-icons/dist/ScaleBalancedOutline.svelte
ScaleBalancedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ScaleBalancedOutline.svelte";
var root_1582 = add_locations(from_svg(`<title> </title>`), ScaleBalancedOutline[FILENAME], [[43, 4]]);
var root_2582 = add_locations(from_svg(`<desc> </desc>`), ScaleBalancedOutline[FILENAME], [[46, 4]]);
var root582 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.5 21h13M12 21V7m0 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm2-1.8c3.073.661 2.467 2.8 5 2.8M5 8c3.359 0 2.192-2.115 5.012-2.793M7 9.556V7.75m0 1.806-1.95 4.393a.773.773 0 0 0 .37.962.785.785 0 0 0 .362.089h2.436a.785.785 0 0 0 .643-.335.776.776 0 0 0 .09-.716L7 9.556Zm10 0V7.313m0 2.243-1.95 4.393a.773.773 0 0 0 .37.962.786.786 0 0 0 .362.089h2.436a.785.785 0 0 0 .643-.335.775.775 0 0 0 .09-.716L17 9.556Z"></path></svg>`), ScaleBalancedOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ScaleBalancedOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ScaleBalancedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root582();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1582();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ScaleBalancedOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2582();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ScaleBalancedOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ScaleBalancedOutline = hmr(ScaleBalancedOutline, () => ScaleBalancedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ScaleBalancedOutline[HMR].source;
    set(ScaleBalancedOutline[HMR].source, module.default[HMR].original);
  });
}
var ScaleBalancedOutline_default = ScaleBalancedOutline;

// node_modules/flowbite-svelte-icons/dist/ScaleBalancedSolid.svelte
ScaleBalancedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ScaleBalancedSolid.svelte";
var root_1583 = add_locations(from_svg(`<title> </title>`), ScaleBalancedSolid[FILENAME], [[41, 4]]);
var root_2583 = add_locations(from_svg(`<desc> </desc>`), ScaleBalancedSolid[FILENAME], [[44, 4]]);
var root583 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 4a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-2.952.462c-.483.19-.868.432-1.19.71-.363.315-.638.677-.831.93l-.106.14c-.21.268-.36.418-.574.527C6.125 6.883 5.74 7 5 7a1 1 0 0 0 0 2c.364 0 .696-.022 1-.067v.41l-1.864 4.2a1.774 1.774 0 0 0 .821 2.255c.255.133.538.202.825.202h2.436a1.786 1.786 0 0 0 1.768-1.558 1.774 1.774 0 0 0-.122-.899L8 9.343V8.028c.2-.188.36-.38.495-.553.062-.079.118-.15.168-.217.185-.24.311-.406.503-.571a1.89 1.89 0 0 1 .24-.177A3.01 3.01 0 0 0 11 7.829V20H5.5a1 1 0 1 0 0 2h13a1 1 0 1 0 0-2H13V7.83a3.01 3.01 0 0 0 1.63-1.387c.206.091.373.19.514.29.31.219.532.465.811.78l.025.027.02.023v1.78l-1.864 4.2a1.774 1.774 0 0 0 .821 2.255c.255.133.538.202.825.202h2.436a1.785 1.785 0 0 0 1.768-1.558 1.773 1.773 0 0 0-.122-.899L18 9.343v-.452c.302.072.633.109 1 .109a1 1 0 1 0 0-2c-.48 0-.731-.098-.899-.2-.2-.12-.363-.293-.651-.617l-.024-.026c-.267-.3-.622-.7-1.127-1.057a5.152 5.152 0 0 0-1.355-.678 3.001 3.001 0 0 0-5.896.04Z" clip-rule="evenodd"></path></svg>`), ScaleBalancedSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ScaleBalancedSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ScaleBalancedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root583();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1583();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ScaleBalancedSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2583();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ScaleBalancedSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ScaleBalancedSolid = hmr(ScaleBalancedSolid, () => ScaleBalancedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ScaleBalancedSolid[HMR].source;
    set(ScaleBalancedSolid[HMR].source, module.default[HMR].original);
  });
}
var ScaleBalancedSolid_default = ScaleBalancedSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolAltOutline.svelte
SchoolAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolAltOutline.svelte";
var root_1584 = add_locations(from_svg(`<title> </title>`), SchoolAltOutline[FILENAME], [[43, 4]]);
var root_2584 = add_locations(from_svg(`<desc> </desc>`), SchoolAltOutline[FILENAME], [[46, 4]]);
var root584 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="m7.14284 11 4.99996-6 5 6m-9.99996 0h-3v8H20.1428v-8h-3m-9.99996 0H3.14285l3-4h4.33735l-3.33736 4Zm9.99996 0h4l-3-4h-4.3374l3.3374 4Zm-3 2c0 1.1046-.8954 2-2 2-1.1045 0-2-.8954-2-2s.8955-2 2-2c1.1046 0 2 .8954 2 2Z"></path></svg>`), SchoolAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root584();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1584();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2584();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolAltOutline = hmr(SchoolAltOutline, () => SchoolAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolAltOutline[HMR].source;
    set(SchoolAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolAltOutline_default = SchoolAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolAltSolid.svelte
SchoolAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolAltSolid.svelte";
var root_1585 = add_locations(from_svg(`<title> </title>`), SchoolAltSolid[FILENAME], [[41, 4]]);
var root_2585 = add_locations(from_svg(`<desc> </desc>`), SchoolAltSolid[FILENAME], [[44, 4]]);
var root585 = add_locations(from_svg(`<svg><!><!><path d="M12 12c-.5523 0-1 .4477-1 1s.4477 1 1 1 1-.4477 1-1-.4477-1-1-1Z"></path><path fill-rule="evenodd" d="M6.65111 11.6306 12 5.04736l5.3489 6.58324c.1899.2337.475.3694.7761.3694H21v7c0 .5523-.4477 1-1 1H4c-.55228 0-1-.4477-1-1v-7h2.87499c.30113 0 .58623-.1357.77612-.3694ZM8.99999 13c0-1.6568 1.34311-3 3.00001-3 1.6568 0 3 1.3432 3 3 0 1.6569-1.3432 3-3 3-1.6569 0-3.00001-1.3431-3.00001-3Z" clip-rule="evenodd"></path><path d="m2.5 10 2.7-3.59999c.18885-.2518.48524-.4.8-.4h2.64902L5.39902 10H2.5Zm12.851-3.99999L18.601 10H21.5l-2.7-3.59999c-.1888-.2518-.4852-.4-.8-.4h-2.649Z"></path></svg>`), SchoolAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2], [52, 2]]]]);
function SchoolAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root585();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1585();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2585();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolAltSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolAltSolid = hmr(SchoolAltSolid, () => SchoolAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolAltSolid[HMR].source;
    set(SchoolAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolAltSolid_default = SchoolAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolCheckAltOutline.svelte
SchoolCheckAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolCheckAltOutline.svelte";
var root_1586 = add_locations(from_svg(`<title> </title>`), SchoolCheckAltOutline[FILENAME], [[43, 4]]);
var root_2586 = add_locations(from_svg(`<desc> </desc>`), SchoolCheckAltOutline[FILENAME], [[46, 4]]);
var root586 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7.28567 11 5.00003-6 5 6M7.28567 11h-3v8h8.00003m-5.00003-8H3.28568l3-4h4.33742l-3.33743 4Zm10.00003 0h3v1m-3-1h4l-3-4h-4.3374l3.3374 4Zm-2 6 2 2 4-4m-7-2c0 1.1046-.8955 2-2 2-1.1046 0-2-.8954-2-2s.8954-2 2-2c1.1045 0 2 .8954 2 2Z"></path></svg>`), SchoolCheckAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolCheckAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolCheckAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root586();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1586();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolCheckAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2586();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolCheckAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolCheckAltOutline = hmr(SchoolCheckAltOutline, () => SchoolCheckAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolCheckAltOutline[HMR].source;
    set(SchoolCheckAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolCheckAltOutline_default = SchoolCheckAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolCheckAltSolid.svelte
SchoolCheckAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolCheckAltSolid.svelte";
var root_1587 = add_locations(from_svg(`<title> </title>`), SchoolCheckAltSolid[FILENAME], [[41, 4]]);
var root_2587 = add_locations(from_svg(`<desc> </desc>`), SchoolCheckAltSolid[FILENAME], [[44, 4]]);
var root587 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M21.7071 14.2929c.3905.3905.3905 1.0237 0 1.4142l-4 4c-.3905.3905-1.0237.3905-1.4142 0l-2-2c-.3905-.3905-.3905-1.0237 0-1.4142.3905-.3905 1.0237-.3905 1.4142 0L17 17.5858l3.2929-3.2929c.3905-.3905 1.0237-.3905 1.4142 0Z" clip-rule="evenodd"></path><path d="M6.65111 11.6306 12 5.04736l5.3489 6.58324c.1899.2337.475.3694.7761.3694h2.8655c-.7646.0024-1.5284.2953-2.1118.8787l-1.8821 1.8821c-.6135-.548-1.3982-.8-2.1691-.7559C14.9392 13.6908 15 13.3525 15 13c0-1.6568-1.3432-3-3-3-1.6569 0-3.00001 1.3432-3.00001 3 0 1.6569 1.34311 3 3.00001 3 .0579 0 .1154-.0016.1726-.0049-.3747 1.0565-.1393 2.2808.7061 3.1262l.8787.8787H4c-.55228 0-1-.4477-1-1v-7h2.87499c.30113 0 .58623-.1357.77612-.3694Z"></path><path d="M12 12c-.5523 0-1 .4477-1 1s.4477 1 1 1 1-.4477 1-1-.4477-1-1-1Zm-9.5-2 2.7-3.59999c.18885-.2518.48524-.4.8-.4h2.64902L5.39902 10H2.5Zm12.851-3.99999L18.601 10H21.5l-2.7-3.59999c-.1888-.2518-.4852-.4-.8-.4h-2.649Z"></path></svg>`), SchoolCheckAltSolid[FILENAME], [[30, 0, [[46, 2], [51, 2], [54, 2]]]]);
function SchoolCheckAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolCheckAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root587();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1587();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolCheckAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2587();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolCheckAltSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolCheckAltSolid = hmr(SchoolCheckAltSolid, () => SchoolCheckAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolCheckAltSolid[HMR].source;
    set(SchoolCheckAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolCheckAltSolid_default = SchoolCheckAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolCheckOutline.svelte
SchoolCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolCheckOutline.svelte";
var root_1588 = add_locations(from_svg(`<title> </title>`), SchoolCheckOutline[FILENAME], [[43, 4]]);
var root_2588 = add_locations(from_svg(`<desc> </desc>`), SchoolCheckOutline[FILENAME], [[46, 4]]);
var root588 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.14294 20v-9l-4 1.125V20h4Zm0 0V6.66667m0 13.33333h2.99996m5-9V6.66667m0 4.33333 4 1.125V13m-4-2v3m2-6-6-4-5.99996 4m4.99996 1h2m-2 3h2m1 6 2 2 4-4"></path></svg>`), SchoolCheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolCheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root588();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1588();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolCheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2588();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolCheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolCheckOutline = hmr(SchoolCheckOutline, () => SchoolCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolCheckOutline[HMR].source;
    set(SchoolCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolCheckOutline_default = SchoolCheckOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolCheckSolid.svelte
SchoolCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolCheckSolid.svelte";
var root_1589 = add_locations(from_svg(`<title> </title>`), SchoolCheckSolid[FILENAME], [[41, 4]]);
var root_2589 = add_locations(from_svg(`<desc> </desc>`), SchoolCheckSolid[FILENAME], [[44, 4]]);
var root589 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.4453 3.16795c.3359-.22393.7735-.22393 1.1094 0l6 4c.4595.30635.5837.92722.2773 1.38675-.1925.28877-.5092.44511-.832.44541-.1748.00016-.3515-.04546-.5112-.1406-.0146-.00873-.0292-.01789-.0435-.02746L16 7.86853v8.59597l-.2322-.2323c-.9763-.9763-2.5593-.9763-3.5356 0-.9763.9763-.9763 2.5593 0 3.5356L13.4645 21H8V7.86853l-1.44532.96352c-.45952.30635-1.08039.18218-1.38675-.27735-.30635-.45953-.18217-1.0804.27735-1.38675l6.00002-4ZM11 11c-.5523 0-1 .4477-1 1s.4477 1 1 1h2c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2Zm-1-2c0-.55228.4477-1 1-1h2c.5523 0 1 .44772 1 1s-.4477 1-1 1h-2c-.5523 0-1-.44772-1-1Z" clip-rule="evenodd"></path><path d="M21 13.708v-1.583c0-.448-.298-.8414-.7293-.9627L18 10.5237v3.9408l.2322-.2323c.7484-.7483 1.853-.923 2.7678-.5242ZM6 10.5237l-2.27075.6386C3.29797 11.2836 3 11.677 3 12.125V20c0 .5523.44772 1 1 1h2V10.5237Z"></path><path fill-rule="evenodd" d="M20.7071 15.2929c.3905.3905.3905 1.0237 0 1.4142l-4 4c-.3905.3905-1.0237.3905-1.4142 0l-2-2c-.3905-.3905-.3905-1.0237 0-1.4142.3905-.3905 1.0237-.3905 1.4142 0L16 18.5858l3.2929-3.2929c.3905-.3905 1.0237-.3905 1.4142 0Z" clip-rule="evenodd"></path></svg>`), SchoolCheckSolid[FILENAME], [[30, 0, [[46, 2], [51, 2], [54, 2]]]]);
function SchoolCheckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root589();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1589();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolCheckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2589();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolCheckSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolCheckSolid = hmr(SchoolCheckSolid, () => SchoolCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolCheckSolid[HMR].source;
    set(SchoolCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolCheckSolid_default = SchoolCheckSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolExclamationAltOutline.svelte
SchoolExclamationAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolExclamationAltOutline.svelte";
var root_1590 = add_locations(from_svg(`<title> </title>`), SchoolExclamationAltOutline[FILENAME], [[43, 4]]);
var root_2590 = add_locations(from_svg(`<desc> </desc>`), SchoolExclamationAltOutline[FILENAME], [[46, 4]]);
var root590 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.4999 19H4.49988v-8h3m0 0 5.00002-6 5 6M7.49988 11H3.49989l3-4h4.33741l-3.33742 4Zm13.00002 8h.01m-.01-3v-3m-6.3374-6h4.3374l2 2.5m-6 3.5c0 1.1046-.8955 2-2 2-1.1046 0-2-.8954-2-2s.8954-2 2-2c1.1045 0 2 .8954 2 2Z"></path></svg>`), SchoolExclamationAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolExclamationAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolExclamationAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root590();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1590();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolExclamationAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2590();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolExclamationAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolExclamationAltOutline = hmr(SchoolExclamationAltOutline, () => SchoolExclamationAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolExclamationAltOutline[HMR].source;
    set(SchoolExclamationAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolExclamationAltOutline_default = SchoolExclamationAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolExclamationAltSolid.svelte
SchoolExclamationAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolExclamationAltSolid.svelte";
var root_1591 = add_locations(from_svg(`<title> </title>`), SchoolExclamationAltSolid[FILENAME], [[41, 4]]);
var root_2591 = add_locations(from_svg(`<desc> </desc>`), SchoolExclamationAltSolid[FILENAME], [[44, 4]]);
var root591 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M19 19c0-.5523.4477-1 1-1h.01c.5523 0 1 .4477 1 1s-.4477 1-1 1H20c-.5523 0-1-.4477-1-1Zm1-7c.5523 0 1 .4477 1 1v3c0 .5523-.4477 1-1 1s-1-.4477-1-1v-3c0-.5523.4477-1 1-1Z" clip-rule="evenodd"></path><path d="M11 13c0-.5523.4477-1 1-1s1 .4477 1 1-.4477 1-1 1-1-.4477-1-1Z"></path><path fill-rule="evenodd" d="M12 5.04736 6.65111 11.6306c-.18989.2337-.47499.3694-.77612.3694H3v7c0 .5523.44772 1 1 1h13.1707c-.1105-.3128-.1707-.6494-.1707-1 0-.5464.1461-1.0587.4013-1.5C17.1461 17.0587 17 16.5464 17 16v-3c0-.499.1218-.9696.3374-1.3835L12 5.04736ZM12 10c-1.6569 0-3.00001 1.3432-3.00001 3 0 1.6569 1.34311 3 3.00001 3 1.6568 0 3-1.3431 3-3 0-1.6568-1.3432-3-3-3Z" clip-rule="evenodd"></path><path d="M20.0095 10H18.601l-3.25-3.99999H18c.3148 0 .6112.1482.8.4L21.5 10h-1.4905Zm-.015 2c-.5498.003-.9945.4495-.9945 1v3c0 .0565.0047.1119.0137.1659.079.4733.4905.8341.9863.8341h.01c.4924-.0049.8997-.3656.9768-.8374.0087-.0529.0132-.1072.0132-.1626v-3c0-.5505-.4447-.997-.9945-1h-.011ZM21 18.8581c-.0013-.0092-.0027-.0183-.0043-.0273-.0803-.4717-.4911-.8308-.9857-.8308H20c-.4958 0-.9073.3608-.9863.8341-.009.054-.0137.1094-.0137.1659 0 .5523.4477 1 1 1h.0056c.5497-.003.9944-.4496.9944-1v-.1419ZM2.5 10l2.7-3.59999c.18885-.2518.48524-.4.8-.4h2.64902L5.39902 10H2.5Z"></path></svg>`), SchoolExclamationAltSolid[FILENAME], [[30, 0, [[46, 2], [50, 5], [51, 2], [56, 2]]]]);
function SchoolExclamationAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolExclamationAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root591();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1591();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolExclamationAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2591();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolExclamationAltSolid,
      43,
      2
    );
  }
  next(4);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolExclamationAltSolid = hmr(SchoolExclamationAltSolid, () => SchoolExclamationAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolExclamationAltSolid[HMR].source;
    set(SchoolExclamationAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolExclamationAltSolid_default = SchoolExclamationAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolExclamationOutline.svelte
SchoolExclamationOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolExclamationOutline.svelte";
var root_1592 = add_locations(from_svg(`<title> </title>`), SchoolExclamationOutline[FILENAME], [[43, 4]]);
var root_2592 = add_locations(from_svg(`<desc> </desc>`), SchoolExclamationOutline[FILENAME], [[46, 4]]);
var root592 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.07144 20v-9l-4 1.125V20h4Zm0 0h7.99996m-7.99996 0V6.66667M16.0714 20v-9l1.5.4219M16.0714 20h1m-1 0V6.66667m2 1.33333-6-4-5.99996 4m4.99996 1h2m-2 3h2m7 8h.01m-.01-3v-4"></path></svg>`), SchoolExclamationOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolExclamationOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolExclamationOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root592();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1592();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolExclamationOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2592();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolExclamationOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolExclamationOutline = hmr(SchoolExclamationOutline, () => SchoolExclamationOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolExclamationOutline[HMR].source;
    set(SchoolExclamationOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolExclamationOutline_default = SchoolExclamationOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolExclamationSolid.svelte
SchoolExclamationSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolExclamationSolid.svelte";
var root_1593 = add_locations(from_svg(`<title> </title>`), SchoolExclamationSolid[FILENAME], [[41, 4]]);
var root_2593 = add_locations(from_svg(`<desc> </desc>`), SchoolExclamationSolid[FILENAME], [[44, 4]]);
var root593 = add_locations(from_svg(`<svg><!><!><path d="m6 10.5237-2.27075.6386C3.29797 11.2836 3 11.677 3 12.125V20c0 .5523.44772 1 1 1h2V10.5237Z"></path><path fill-rule="evenodd" d="M12.5547 3.16795c-.3359-.22393-.7735-.22393-1.1094 0l-6.00002 4c-.45952.30635-.5837.92722-.27735 1.38675.30636.45953.92723.5837 1.38675.27735L8 7.86853V21h8V7.86853l1.4453.96352c.0143.00957.0289.01873.0435.02746.1597.09514.3364.14076.5112.1406.3228-.0003.6395-.15664.832-.44541.3064-.45953.1822-1.0804-.2773-1.38675l-6-4ZM10 12c0-.5523.4477-1 1-1h2c.5523 0 1 .4477 1 1s-.4477 1-1 1h-2c-.5523 0-1-.4477-1-1Zm1-4c-.5523 0-1 .44772-1 1s.4477 1 1 1h2c.5523 0 1-.44772 1-1s-.4477-1-1-1h-2Zm8 12c0-.5523.4477-1 1-1h.01c.5523 0 1 .4477 1 1s-.4477 1-1 1H20c-.5523 0-1-.4477-1-1Zm1-8c.5523 0 1 .4477 1 1v4c0 .5523-.4477 1-1 1s-1-.4477-1-1v-4c0-.5523.4477-1 1-1Z" clip-rule="evenodd"></path></svg>`), SchoolExclamationSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function SchoolExclamationSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolExclamationSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root593();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1593();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolExclamationSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2593();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolExclamationSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolExclamationSolid = hmr(SchoolExclamationSolid, () => SchoolExclamationSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolExclamationSolid[HMR].source;
    set(SchoolExclamationSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolExclamationSolid_default = SchoolExclamationSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolFlagAltOutline.svelte
SchoolFlagAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolFlagAltOutline.svelte";
var root_1594 = add_locations(from_svg(`<title> </title>`), SchoolFlagAltOutline[FILENAME], [[43, 4]]);
var root_2594 = add_locations(from_svg(`<desc> </desc>`), SchoolFlagAltOutline[FILENAME], [[46, 4]]);
var root594 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7.4285 11 5-6 5 6m-10 0h-3v8h16v-8h-3m-10 0H3.42851l3-4h4.33739l-3.3374 4Zm10 0V7.5m-3 5.5c0 1.1046-.8954 2-2 2s-2-.8954-2-2 .8954-2 2-2 2 .8954 2 2Zm3-8v3h4V5h-4Z"></path></svg>`), SchoolFlagAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolFlagAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolFlagAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root594();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1594();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolFlagAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2594();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolFlagAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolFlagAltOutline = hmr(SchoolFlagAltOutline, () => SchoolFlagAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolFlagAltOutline[HMR].source;
    set(SchoolFlagAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolFlagAltOutline_default = SchoolFlagAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolFlagAltSolid.svelte
SchoolFlagAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolFlagAltSolid.svelte";
var root_1595 = add_locations(from_svg(`<title> </title>`), SchoolFlagAltSolid[FILENAME], [[41, 4]]);
var root_2595 = add_locations(from_svg(`<desc> </desc>`), SchoolFlagAltSolid[FILENAME], [[44, 4]]);
var root595 = add_locations(from_svg(`<svg><!><!><path d="M12 12c-.5523 0-1 .4477-1 1s.4477 1 1 1 1-.4477 1-1-.4477-1-1-1Z"></path><path fill-rule="evenodd" d="M17 4c-.5523 0-1 .44772-1 1v4.97045l-4-4.92309-5.34889 6.58324c-.18989.2337-.47499.3694-.77612.3694H3v7c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-7h-2.875c-.0421 0-.0838-.0026-.125-.0078V9h3c.5523 0 1-.44772 1-1V5c0-.55228-.4477-1-1-1h-4Zm-8.00001 9c0-1.6568 1.34311-3 3.00001-3 1.6568 0 3 1.3432 3 3 0 1.6569-1.3432 3-3 3-1.6569 0-3.00001-1.3431-3.00001-3Z" clip-rule="evenodd"></path><path d="M5.2 6.40001 2.5 10h2.89902l3.25-3.99999H6c-.31476 0-.61115.1482-.8.4Z"></path></svg>`), SchoolFlagAltSolid[FILENAME], [[30, 0, [[46, 2], [47, 2], [51, 5]]]]);
function SchoolFlagAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolFlagAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root595();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1595();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolFlagAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2595();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolFlagAltSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolFlagAltSolid = hmr(SchoolFlagAltSolid, () => SchoolFlagAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolFlagAltSolid[HMR].source;
    set(SchoolFlagAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolFlagAltSolid_default = SchoolFlagAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolFlagOutline.svelte
SchoolFlagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolFlagOutline.svelte";
var root_1596 = add_locations(from_svg(`<title> </title>`), SchoolFlagOutline[FILENAME], [[43, 4]]);
var root_2596 = add_locations(from_svg(`<desc> </desc>`), SchoolFlagOutline[FILENAME], [[46, 4]]);
var root596 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20v-9l-4 1.125V20h4Zm0 0h8m-8 0V6.66667M16 20v-9l4 1.125V20h-4Zm0 0V7m0 0V4h4v3h-4ZM6 8l6-4 4 2.66667M11 9h2m-2 3h2"></path></svg>`), SchoolFlagOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolFlagOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolFlagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root596();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1596();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolFlagOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2596();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolFlagOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolFlagOutline = hmr(SchoolFlagOutline, () => SchoolFlagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolFlagOutline[HMR].source;
    set(SchoolFlagOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolFlagOutline_default = SchoolFlagOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolFlagSolid.svelte
SchoolFlagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolFlagSolid.svelte";
var root_1597 = add_locations(from_svg(`<title> </title>`), SchoolFlagSolid[FILENAME], [[41, 4]]);
var root_2597 = add_locations(from_svg(`<desc> </desc>`), SchoolFlagSolid[FILENAME], [[44, 4]]);
var root597 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15 4c0-.55228.4477-1 1-1h4c.5523 0 1 .44772 1 1v3c0 .55228-.4477 1-1 1h-4v13H8V7.86853l-1.44532.96352c-.45952.30635-1.08039.18218-1.38675-.27735-.30635-.45953-.18217-1.0804.27735-1.38675l6.00002-4c.3359-.22393.7735-.22393 1.1094 0L15 4.79816V4Zm-5 8c0-.5523.4477-1 1-1h2c.5523 0 1 .4477 1 1s-.4477 1-1 1h-2c-.5523 0-1-.4477-1-1Zm1-4c-.5523 0-1 .44772-1 1s.4477 1 1 1h2c.5523 0 1-.44772 1-1s-.4477-1-1-1h-2Z" clip-rule="evenodd"></path><path d="M18 9.00011 17.9843 9h.0296L18 9.00011ZM6 10.5237l-2.27075.6386C3.29797 11.2836 3 11.677 3 12.125V20c0 .5523.44772 1 1 1h2V10.5237Zm14.2707.6386L18 10.5237V21h2c.5523 0 1-.4477 1-1v-7.875c0-.448-.298-.8414-.7293-.9627Z"></path></svg>`), SchoolFlagSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function SchoolFlagSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolFlagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root597();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1597();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolFlagSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2597();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolFlagSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolFlagSolid = hmr(SchoolFlagSolid, () => SchoolFlagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolFlagSolid[HMR].source;
    set(SchoolFlagSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolFlagSolid_default = SchoolFlagSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolLockAltOutline.svelte
SchoolLockAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolLockAltOutline.svelte";
var root_1598 = add_locations(from_svg(`<title> </title>`), SchoolLockAltOutline[FILENAME], [[43, 4]]);
var root_2598 = add_locations(from_svg(`<desc> </desc>`), SchoolLockAltOutline[FILENAME], [[46, 4]]);
var root598 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7.35709 11 5.00001-6 3.3333 4m-8.33331 2h-3v8h7.00001m-4.00001-8H3.3571l3-4h4.3374l-3.33741 4Zm8.33131-2-1.6687-2h4.3374l1.5 2m-8.3237 5.8976c-1.0239-.4146-1.5178-1.5806-1.1032-2.6044.4146-1.0239 1.5806-1.5178 2.6044-1.1032M16.3571 15v-2.5c0-.8284.6716-1.5 1.5-1.5s1.5.6716 1.5 1.5V15m-4 0h5c.5523 0 1 .4477 1 1v2c0 .5523-.4477 1-1 1h-5c-.5523 0-1-.4477-1-1v-2c0-.5523.4477-1 1-1Z"></path></svg>`), SchoolLockAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolLockAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolLockAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root598();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1598();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolLockAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2598();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolLockAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolLockAltOutline = hmr(SchoolLockAltOutline, () => SchoolLockAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolLockAltOutline[HMR].source;
    set(SchoolLockAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolLockAltOutline_default = SchoolLockAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolLockAltSolid.svelte
SchoolLockAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolLockAltSolid.svelte";
var root_1599 = add_locations(from_svg(`<title> </title>`), SchoolLockAltSolid[FILENAME], [[41, 4]]);
var root_2599 = add_locations(from_svg(`<desc> </desc>`), SchoolLockAltSolid[FILENAME], [[44, 4]]);
var root599 = add_locations(from_svg(`<svg><!><!><path d="M6.65111 11.6306 12 5.04736l3.0095 3.70405c-.627.41739-1.1433.9879-1.4955 1.65809C13.0696 10.1492 12.5522 10 12 10c-1.6569 0-3.00001 1.3432-3.00001 3 0 1.3076.8365 2.4197 2.00351 2.8306-.0023.0561-.0035.1126-.0035.1694v2c0 .7286.1948 1.4117.5351 2H4c-.55228 0-1-.4477-1-1v-7h2.87499c.30113 0 .58623-.1357.77612-.3694Z"></path><path fill-rule="evenodd" d="M16.1022 10.427C15.4372 10.8762 15 11.6371 15 12.5V14c-.0584 0-.1162.0025-.1733.0074-.9663.083-1.7363.853-1.8193 1.8193l-.0006.0067c-.0045.055-.0068.1105-.0068.1666v2c0 1.1046.8954 2 2 2h5.0079C21.1088 19.9957 22 19.1019 22 18v-2c0-.7403-.4022-1.3866-1-1.7324-.0154-.009-.031-.0177-.0467-.0262C20.6699 14.0874 20.3452 14 20 14v-1.5c0-.1712-.0172-.3384-.05-.5-.2316-1.1411-1.2405-2-2.45-2-.4425 0-.8581.115-1.2187.3167-.0613.0343-.1211.0711-.1791.1103ZM17.5 12c-.2761 0-.5.2239-.5.5V14h1v-1.5c0-.2761-.2239-.5-.5-.5Z" clip-rule="evenodd"></path><path d="M21.2422 10c-.8072-1.20598-2.182-2-3.7422-2-.1695 0-.3369.00938-.5016.02764L15.351 6.00001H18c.3148 0 .6112.1482.8.4L21.5 10h-.2578Zm-8.3308 2.5879C12.7544 12.2412 12.4054 12 12 12c-.5523 0-1 .4477-1 1 0 .4054.2412.7544.5879.9114.3304-.5386.7848-.9931 1.3235-1.3235ZM5.2 6.40001 2.5 10h2.89902l3.25-3.99999H6c-.31476 0-.61115.1482-.8.4Z"></path></svg>`), SchoolLockAltSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [54, 2]]]]);
function SchoolLockAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolLockAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root599();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1599();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolLockAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2599();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolLockAltSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolLockAltSolid = hmr(SchoolLockAltSolid, () => SchoolLockAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolLockAltSolid[HMR].source;
    set(SchoolLockAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolLockAltSolid_default = SchoolLockAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolLockOutline.svelte
SchoolLockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolLockOutline.svelte";
var root_1600 = add_locations(from_svg(`<title> </title>`), SchoolLockOutline[FILENAME], [[43, 4]]);
var root_2600 = add_locations(from_svg(`<desc> </desc>`), SchoolLockOutline[FILENAME], [[46, 4]]);
var root600 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.21448 20v-9l-4 1.125V20h4Zm0 0V6.66667m0 13.33333h2.00002m6-11V6.66667m2 1.33333-6-4-6.00002 4m5.00002 1h2m-2 3h1m3 4v-2.5c0-.8284.6716-1.5 1.5-1.5s1.5.6716 1.5 1.5V16m-4 0h5c.5523 0 1 .4477 1 1v2c0 .5523-.4477 1-1 1h-5c-.5523 0-1-.4477-1-1v-2c0-.5523.4477-1 1-1Z"></path></svg>`), SchoolLockOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolLockOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolLockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root600();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1600();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolLockOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2600();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolLockOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolLockOutline = hmr(SchoolLockOutline, () => SchoolLockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolLockOutline[HMR].source;
    set(SchoolLockOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolLockOutline_default = SchoolLockOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolLockSolid.svelte
SchoolLockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolLockSolid.svelte";
var root_1601 = add_locations(from_svg(`<title> </title>`), SchoolLockSolid[FILENAME], [[41, 4]]);
var root_2601 = add_locations(from_svg(`<desc> </desc>`), SchoolLockSolid[FILENAME], [[44, 4]]);
var root601 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.4453 3.16795c.3359-.22393.7735-.22393 1.1094 0l6 4c.4595.30635.5837.92722.2773 1.38675-.1925.28877-.5092.44511-.832.44541-.1748.00016-.3515-.04546-.5112-.1406-.0146-.00873-.0292-.01789-.0435-.02746L16 7.86853v1.66242c-1.0832.13507-2.0319.70325-2.6673 1.52575C13.2286 11.02 13.1166 11 13 11h-2c-.5523 0-1 .4477-1 1s.4477 1 1 1h1.5309c-.0204.1638-.0309.3307-.0309.5v.3368c-1.1825.5617-2 1.767-2 3.1632v2c0 .7436.2319 1.4331.6273 2H8V7.86853l-1.44532.96352c-.45952.30635-1.08039.18218-1.38675-.27735-.30635-.45953-.18217-1.0804.27735-1.38675l6.00002-4ZM10 9c0-.55228.4477-1 1-1h2c.5523 0 1 .44772 1 1s-.4477 1-1 1h-2c-.5523 0-1-.44772-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M16.5 11c.5628 0 1.0822.186 1.5.4998.0306.023.0607.0467.0902.0711.5557.4585.9098 1.1524.9098 1.9291V15c1.1046 0 2 .8954 2 2v2c0 1.1016-.8907 1.9952-1.9912 2H14c-1.1046 0-2-.8954-2-2v-2c0-1.1046.8954-2 2-2v-1.5c0-1.2081.857-2.2161 1.9962-2.4492L16 11.05c.1616-.0328.3288-.05.5-.05Zm0 2c-.2761 0-.5.2239-.5.5V15h1v-1.5c0-.2761-.2239-.5-.5-.5Z" clip-rule="evenodd"></path><path d="M3.72925 11.1623 6 10.5237V21H4c-.55228 0-1-.4477-1-1v-7.875c0-.448.29797-.8414.72925-.9627Z"></path></svg>`), SchoolLockSolid[FILENAME], [[30, 0, [[46, 2], [51, 2], [56, 2]]]]);
function SchoolLockSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolLockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root601();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1601();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolLockSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2601();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolLockSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolLockSolid = hmr(SchoolLockSolid, () => SchoolLockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolLockSolid[HMR].source;
    set(SchoolLockSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolLockSolid_default = SchoolLockSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolOutline.svelte
SchoolOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolOutline.svelte";
var root_1602 = add_locations(from_svg(`<title> </title>`), SchoolOutline[FILENAME], [[43, 4]]);
var root_2602 = add_locations(from_svg(`<desc> </desc>`), SchoolOutline[FILENAME], [[46, 4]]);
var root602 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20v-9l-4 1.125V20h4Zm0 0h8m-8 0V6.66667M16 20v-9l4 1.125V20h-4Zm0 0V6.66667M18 8l-6-4-6 4m5 1h2m-2 3h2"></path></svg>`), SchoolOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root602();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1602();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2602();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolOutline = hmr(SchoolOutline, () => SchoolOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolOutline[HMR].source;
    set(SchoolOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolOutline_default = SchoolOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolSolid.svelte
SchoolSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolSolid.svelte";
var root_1603 = add_locations(from_svg(`<title> </title>`), SchoolSolid[FILENAME], [[41, 4]]);
var root_2603 = add_locations(from_svg(`<desc> </desc>`), SchoolSolid[FILENAME], [[44, 4]]);
var root603 = add_locations(from_svg(`<svg><!><!><path d="m6 10.5237-2.27075.6386C3.29797 11.2836 3 11.677 3 12.125V20c0 .5523.44772 1 1 1h2V10.5237Zm12 0 2.2707.6386c.4313.1213.7293.5147.7293.9627V20c0 .5523-.4477 1-1 1h-2V10.5237Z"></path><path fill-rule="evenodd" d="M12.5547 3.16795c-.3359-.22393-.7735-.22393-1.1094 0l-6.00002 4c-.45952.30635-.5837.92722-.27735 1.38675.30636.45953.92723.5837 1.38675.27735L8 7.86853V21h8V7.86853l1.4453.96352c.0143.00957.0289.01873.0435.02746.1597.09514.3364.14076.5112.1406.3228-.0003.6395-.15664.832-.44541.3064-.45953.1822-1.0804-.2773-1.38675l-6-4ZM10 12c0-.5523.4477-1 1-1h2c.5523 0 1 .4477 1 1s-.4477 1-1 1h-2c-.5523 0-1-.4477-1-1Zm1-4c-.5523 0-1 .44772-1 1s.4477 1 1 1h2c.5523 0 1-.44772 1-1s-.4477-1-1-1h-2Z" clip-rule="evenodd"></path></svg>`), SchoolSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function SchoolSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root603();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1603();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2603();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolSolid = hmr(SchoolSolid, () => SchoolSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolSolid[HMR].source;
    set(SchoolSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolSolid_default = SchoolSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolXmarkAltOutline.svelte
SchoolXmarkAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolXmarkAltOutline.svelte";
var root_1604 = add_locations(from_svg(`<title> </title>`), SchoolXmarkAltOutline[FILENAME], [[43, 4]]);
var root_2604 = add_locations(from_svg(`<desc> </desc>`), SchoolXmarkAltOutline[FILENAME], [[46, 4]]);
var root604 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16.9757 15.4642 1.7677 1.7678m0 0 1.7678 1.7678m-1.7678-1.7678-1.7677 1.7678m1.7677-1.7678 1.7678-1.7678M7.21425 11l5.00005-6 5 6M7.21425 11h-3v8H13.294m-6.07975-8H3.21426l3-4h4.33744l-3.33745 4Zm10.00005 0h3v1.5574m-3-1.5574h3.9999l-3-4h-4.3373l3.3374 4Zm-3 2c0 1.1046-.8955 2-2 2-1.1046 0-2-.8954-2-2s.8954-2 2-2c1.1045 0 2 .8954 2 2Z"></path></svg>`), SchoolXmarkAltOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolXmarkAltOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolXmarkAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root604();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1604();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolXmarkAltOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2604();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolXmarkAltOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolXmarkAltOutline = hmr(SchoolXmarkAltOutline, () => SchoolXmarkAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolXmarkAltOutline[HMR].source;
    set(SchoolXmarkAltOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolXmarkAltOutline_default = SchoolXmarkAltOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolXmarkAltSolid.svelte
SchoolXmarkAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolXmarkAltSolid.svelte";
var root_1605 = add_locations(from_svg(`<title> </title>`), SchoolXmarkAltSolid[FILENAME], [[41, 4]]);
var root_2605 = add_locations(from_svg(`<desc> </desc>`), SchoolXmarkAltSolid[FILENAME], [[44, 4]]);
var root605 = add_locations(from_svg(`<svg><!><!><path d="M6.65111 11.6306 12 5.04736l5.3489 6.58324c.1899.2337.475.3694.7761.3694H21v1.0646c-.8482-.2477-1.8019-.0371-2.4708.6319-.9763-.9764-2.5592-.9763-3.5355 0-.0357.0356-.0701.0721-.1032.1094.0714-.2564.1095-.5267.1095-.8059 0-1.6568-1.3432-3-3-3-1.6569 0-3.00001 1.3432-3.00001 3 0 1.6569 1.34311 3 3.00001 3 .9389 0 1.777-.4313 2.3271-1.1066-.19.8138.0322 1.7042.6666 2.3386-.7484.7484-.9231 1.8532-.5242 2.768H4c-.55228 0-1-.4477-1-1v-7h2.87499c.30113 0 .58623-.1357.77612-.3694Z"></path><path d="M17.4685 14.7571c-.3905-.3905-1.0237-.3905-1.4142 0-.3905.3905-.3905 1.0237 0 1.4142l1.0607 1.0607-1.0607 1.0607c-.3905.3905-.3905 1.0236 0 1.4142.3905.3905 1.0237.3905 1.4142 0l1.0607-1.0607 1.0606 1.0607c.1465.1464.327.2379.5161.2746.0145.0028.0291.0052.0437.0074.3025.0448.6216-.0492.8544-.282.3906-.3906.3906-1.0237 0-1.4142l-1.0606-1.0607L21 16.1754l.004-.0041c.3906-.3905.3906-1.0237 0-1.4142l-.004-.004c-.0403-.0398-.0831-.0756-.128-.1072-.3902-.2749-.9331-.2378-1.2822.1112l-1.0606 1.0607-1.0607-1.0607ZM12 12c-.5523 0-1 .4477-1 1s.4477 1 1 1 1-.4477 1-1-.4477-1-1-1Zm-9.5-2 2.7-3.59999c.18885-.2518.48524-.4.8-.4h2.64902L5.39902 10H2.5Zm12.851-3.99999L18.601 10H21.5l-2.7-3.59999c-.1888-.2518-.4852-.4-.8-.4h-2.649Z"></path></svg>`), SchoolXmarkAltSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function SchoolXmarkAltSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolXmarkAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root605();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1605();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolXmarkAltSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2605();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolXmarkAltSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolXmarkAltSolid = hmr(SchoolXmarkAltSolid, () => SchoolXmarkAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolXmarkAltSolid[HMR].source;
    set(SchoolXmarkAltSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolXmarkAltSolid_default = SchoolXmarkAltSolid;

// node_modules/flowbite-svelte-icons/dist/SchoolXmarkOutline.svelte
SchoolXmarkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolXmarkOutline.svelte";
var root_1606 = add_locations(from_svg(`<title> </title>`), SchoolXmarkOutline[FILENAME], [[43, 4]]);
var root_2606 = add_locations(from_svg(`<desc> </desc>`), SchoolXmarkOutline[FILENAME], [[46, 4]]);
var root606 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.07141 20v-9l-4 1.125V20h4Zm0 0V6.66667m0 13.33333h3.99999m4-9V6.66667m0 4.33333 4 1.125V13m-4-2v2m2-5-6-4-5.99999 4m4.99999 1h2m-2 3h2m3.0148 4.4087 1.7678 1.7678m0 0 1.7678 1.7677m-1.7678-1.7677-1.7678 1.7677m1.7678-1.7677 1.7678-1.7678"></path></svg>`), SchoolXmarkOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SchoolXmarkOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolXmarkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root606();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1606();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolXmarkOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2606();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolXmarkOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolXmarkOutline = hmr(SchoolXmarkOutline, () => SchoolXmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolXmarkOutline[HMR].source;
    set(SchoolXmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var SchoolXmarkOutline_default = SchoolXmarkOutline;

// node_modules/flowbite-svelte-icons/dist/SchoolXmarkSolid.svelte
SchoolXmarkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SchoolXmarkSolid.svelte";
var root_1607 = add_locations(from_svg(`<title> </title>`), SchoolXmarkSolid[FILENAME], [[41, 4]]);
var root_2607 = add_locations(from_svg(`<desc> </desc>`), SchoolXmarkSolid[FILENAME], [[44, 4]]);
var root607 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15.3077 15.7016c.3906-.3905 1.0237-.3905 1.4142 0l1.0607 1.0607 1.0607-1.0607c.3905-.3905 1.0237-.3905 1.4142 0 .3905.3905.3905 1.0237 0 1.4142l-1.0607 1.0607 1.0607 1.0606c.3905.3906.3905 1.0237 0 1.4143-.3905.3905-1.0237.3905-1.4142 0l-1.0607-1.0607-1.0607 1.0607c-.3905.3905-1.0236.3905-1.4142 0-.3905-.3906-.3905-1.0237 0-1.4143l1.0607-1.0606-1.0607-1.0607c-.3905-.3905-.3905-1.0237 0-1.4142Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M11.4453 3.16795c.3359-.22393.7735-.22393 1.1094 0l6 4c.4595.30635.5837.92722.2773 1.38675-.1925.28877-.5092.44511-.832.44541-.1748.00016-.3515-.04546-.5112-.1406-.0146-.00873-.0292-.01789-.0435-.02746L16 7.86853v6.04017c-.6348.0038-1.2685.2478-1.7529.7322-.9763.9763-.9763 2.5592 0 3.5356-.7636.7635-.93 1.8982-.4991 2.8235H8V7.86853l-1.44532.96352c-.45952.30635-1.08039.18218-1.38675-.27735-.30635-.45953-.18217-1.0804.27735-1.38675l6.00002-4ZM11 11c-.5523 0-1 .4477-1 1s.4477 1 1 1h2c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2Zm-1-2c0-.55228.4477-1 1-1h2c.5523 0 1 .44772 1 1s-.4477 1-1 1h-2c-.5523 0-1-.44772-1-1Z" clip-rule="evenodd"></path><path d="M21 14.3714V12.125c0-.448-.298-.8414-.7293-.9627L18 10.5237v3.9235c.873-.6918 2.1011-.7171 3-.0758Zm-3 2.1735.8433-.8433c.3905-.3905 1.0237-.3905 1.4142 0 .3905.3905.3905 1.0237 0 1.4142l-1.0607 1.0607 1.0607 1.0606c.3905.3906.3905 1.0237 0 1.4143-.3905.3905-1.0237.3905-1.4142 0L18 19.8081v-3.2632Zm-2-1.1361c-.251.0037-.5008.1013-.6923.2928-.3905.3905-.3905 1.0237 0 1.4142l.6923.6923v-2.3993Zm0 3.1361v2.3992c-.251-.0037-.5008-.1013-.6923-.2927-.3905-.3906-.3905-1.0237 0-1.4143L16 18.5449ZM6 10.5237l-2.27075.6386C3.29797 11.2836 3 11.677 3 12.125V20c0 .5523.44772 1 1 1h2V10.5237Z"></path></svg>`), SchoolXmarkSolid[FILENAME], [[30, 0, [[46, 2], [51, 2], [56, 2]]]]);
function SchoolXmarkSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SchoolXmarkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root607();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1607();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SchoolXmarkSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2607();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SchoolXmarkSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SchoolXmarkSolid = hmr(SchoolXmarkSolid, () => SchoolXmarkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SchoolXmarkSolid[HMR].source;
    set(SchoolXmarkSolid[HMR].source, module.default[HMR].original);
  });
}
var SchoolXmarkSolid_default = SchoolXmarkSolid;

// node_modules/flowbite-svelte-icons/dist/SearchOutline.svelte
SearchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SearchOutline.svelte";
var root_1608 = add_locations(from_svg(`<title> </title>`), SearchOutline[FILENAME], [[43, 4]]);
var root_2608 = add_locations(from_svg(`<desc> </desc>`), SearchOutline[FILENAME], [[46, 4]]);
var root608 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), SearchOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SearchOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SearchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root608();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1608();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SearchOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2608();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SearchOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SearchOutline = hmr(SearchOutline, () => SearchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SearchOutline[HMR].source;
    set(SearchOutline[HMR].source, module.default[HMR].original);
  });
}
var SearchOutline_default = SearchOutline;

// node_modules/flowbite-svelte-icons/dist/SearchSolid.svelte
SearchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SearchSolid.svelte";
var root_1609 = add_locations(from_svg(`<title> </title>`), SearchSolid[FILENAME], [[41, 4]]);
var root_2609 = add_locations(from_svg(`<desc> </desc>`), SearchSolid[FILENAME], [[44, 4]]);
var root609 = add_locations(from_svg(`<svg><!><!><path d="M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"></path><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414Z" clip-rule="evenodd"></path></svg>`), SearchSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function SearchSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SearchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root609();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1609();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SearchSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2609();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SearchSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SearchSolid = hmr(SearchSolid, () => SearchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SearchSolid[HMR].source;
    set(SearchSolid[HMR].source, module.default[HMR].original);
  });
}
var SearchSolid_default = SearchSolid;

// node_modules/flowbite-svelte-icons/dist/SeedlingOutline.svelte
SeedlingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SeedlingOutline.svelte";
var root_1610 = add_locations(from_svg(`<title> </title>`), SeedlingOutline[FILENAME], [[43, 4]]);
var root_2610 = add_locations(from_svg(`<desc> </desc>`), SeedlingOutline[FILENAME], [[46, 4]]);
var root610 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.83892 12.4543s1.24988-3.08822-.21626-5.29004C8.15656 4.96245 4.58671 4.10885 4.39794 4.2436c-.18877.13476-1.11807 3.32546.34803 5.52727 1.4661 2.20183 5.09295 2.68343 5.09295 2.68343Zm0 0C10.3389 13.4543 12 15 12 18v2c0-2-.4304-3.4188 2.0696-5.9188m0 0s-.4894-2.7888 1.1206-4.35788c1.6101-1.56907 4.4903-1.54682 4.6701-1.28428.1798.26254.4317 2.84376-1.0809 4.31786-1.61 1.5691-4.7098 1.3243-4.7098 1.3243Z"></path></svg>`), SeedlingOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SeedlingOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SeedlingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root610();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1610();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SeedlingOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2610();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SeedlingOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SeedlingOutline = hmr(SeedlingOutline, () => SeedlingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SeedlingOutline[HMR].source;
    set(SeedlingOutline[HMR].source, module.default[HMR].original);
  });
}
var SeedlingOutline_default = SeedlingOutline;

// node_modules/flowbite-svelte-icons/dist/SeedlingSolid.svelte
SeedlingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SeedlingSolid.svelte";
var root_1611 = add_locations(from_svg(`<title> </title>`), SeedlingSolid[FILENAME], [[41, 4]]);
var root_2611 = add_locations(from_svg(`<desc> </desc>`), SeedlingSolid[FILENAME], [[44, 4]]);
var root611 = add_locations(from_svg(`<svg><!><!><path d="M10.9715 12.2168c-.0118.0406-.0234.0795-.0347.1166.0391.0574.0819.1192.1278.1855.3277.473.812 1.172 1.2141 2.0892.2147-.2864.4616-.5799.7447-.8832l-.0024-.0317c-.0236-.3254-.0361-.7783.0091-1.2905.0882-.9978.4095-2.3695 1.4623-3.39555 1.0079-.98229 2.3556-1.42385 3.4044-1.59916.5344-.08932 1.0323-.11665 1.4296-.09869.1954.00883.3932.02974.5707.07034.0872.01996.1979.05097.3114.10232.0867.03927.3102.14854.4769.39195.1453.21217.1993.45929.22.55586.0321.14963.0559.32134.0712.50398.0307.36676.0311.82807-.0291 1.32915-.1181.9828-.4871 2.2522-1.47 3.2102-1.0357 1.0093-2.4736 1.3803-3.5197 1.5249-.542.0749-1.0253.0952-1.3736.0969-.036.0002-.0706.0002-.1037 0-.931.9987-1.2688 1.7317-1.4072 2.3512-.0345.1545-.0581.303-.0739.451.0004.0342.0006.0685.0006.1029v2c0 .5523-.4477 1-1 1s-1-.4477-1-1c0-.1991-.0064-.4114-.0131-.6334-.0142-.4713-.0298-.9868.0117-1.5138-.0358-1.8786-.7555-2.9405-1.40123-3.8932-.13809-.2037-.2728-.4025-.39671-.6032-.05186-.0105-.10709-.0222-.16538-.035-.39471-.0865-.93803-.2268-1.53416-.4432-1.15636-.4197-2.67587-1.1841-3.58743-2.5531-.90552-1.35993-1.03979-2.96316-.96002-4.15955.04066-.60984.13916-1.15131.24451-1.56046.05234-.20327.10977-.38715.16845-.53804.02865-.07367.06419-.15663.10713-.23658.02132-.03968.0522-.09319.0933-.15021.03213-.04456.11389-.15344.24994-.25057.18341-.13093.36351-.16755.42749-.17932.0854-.01572.16019-.01941.21059-.02024.1023-.0017.20235.00733.28493.0176.17089.02126.37298.06155.58906.11526.43651.1085.99747.2886 1.59668.54576 1.16944.50188 2.63819 1.3629 3.52935 2.70126.9248 1.38891.9601 2.99601.818 4.14739-.0726.589-.1962 1.0975-.3016 1.4594Z"></path></svg>`), SeedlingSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function SeedlingSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SeedlingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root611();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1611();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SeedlingSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2611();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SeedlingSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SeedlingSolid = hmr(SeedlingSolid, () => SeedlingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SeedlingSolid[HMR].source;
    set(SeedlingSolid[HMR].source, module.default[HMR].original);
  });
}
var SeedlingSolid_default = SeedlingSolid;

// node_modules/flowbite-svelte-icons/dist/ServerOutline.svelte
ServerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ServerOutline.svelte";
var root_1612 = add_locations(from_svg(`<title> </title>`), ServerOutline[FILENAME], [[43, 4]]);
var root_2612 = add_locations(from_svg(`<desc> </desc>`), ServerOutline[FILENAME], [[46, 4]]);
var root612 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1M5 12h14M5 12a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1m-2 3h.01M14 15h.01M17 9h.01M14 9h.01"></path></svg>`), ServerOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ServerOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ServerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root612();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1612();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ServerOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2612();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ServerOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ServerOutline = hmr(ServerOutline, () => ServerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ServerOutline[HMR].source;
    set(ServerOutline[HMR].source, module.default[HMR].original);
  });
}
var ServerOutline_default = ServerOutline;

// node_modules/flowbite-svelte-icons/dist/ServerSolid.svelte
ServerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ServerSolid.svelte";
var root_1613 = add_locations(from_svg(`<title> </title>`), ServerSolid[FILENAME], [[41, 4]]);
var root_2613 = add_locations(from_svg(`<desc> </desc>`), ServerSolid[FILENAME], [[44, 4]]);
var root613 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 5a2 2 0 0 0-2 2v3a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a2 2 0 0 0-2-2H5Zm9 2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H14Zm3 0a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17ZM3 17v-3a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm11-2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H14Zm3 0a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), ServerSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ServerSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ServerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root613();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1613();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ServerSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2613();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ServerSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ServerSolid = hmr(ServerSolid, () => ServerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ServerSolid[HMR].source;
    set(ServerSolid[HMR].source, module.default[HMR].original);
  });
}
var ServerSolid_default = ServerSolid;

// node_modules/flowbite-svelte-icons/dist/ShapesOutline.svelte
ShapesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShapesOutline.svelte";
var root_1614 = add_locations(from_svg(`<title> </title>`), ShapesOutline[FILENAME], [[43, 4]]);
var root_2614 = add_locations(from_svg(`<desc> </desc>`), ShapesOutline[FILENAME], [[46, 4]]);
var root614 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4.07141 14v6h5.99999v-6H4.07141Zm4.5-4h6.99999l-3.5-6-3.49999 6Zm7.99999 10c1.933 0 3.5-1.567 3.5-3.5s-1.567-3.5-3.5-3.5-3.5 1.567-3.5 3.5 1.567 3.5 3.5 3.5Z"></path></svg>`), ShapesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShapesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShapesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root614();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1614();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShapesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2614();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShapesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShapesOutline = hmr(ShapesOutline, () => ShapesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShapesOutline[HMR].source;
    set(ShapesOutline[HMR].source, module.default[HMR].original);
  });
}
var ShapesOutline_default = ShapesOutline;

// node_modules/flowbite-svelte-icons/dist/ShapesSolid.svelte
ShapesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShapesSolid.svelte";
var root_1615 = add_locations(from_svg(`<title> </title>`), ShapesSolid[FILENAME], [[41, 4]]);
var root_2615 = add_locations(from_svg(`<desc> </desc>`), ShapesSolid[FILENAME], [[44, 4]]);
var root615 = add_locations(from_svg(`<svg><!><!><path d="M12.8638 3.49613C12.6846 3.18891 12.3557 3 12 3s-.6846.18891-.8638.49613l-3.49998 6c-.18042.30929-.1817.69147-.00336 1.00197S8.14193 11 8.5 11h7c.3581 0 .6888-.1914.8671-.5019.1784-.3105.1771-.69268-.0033-1.00197l-3.5-6ZM4 13c-.55228 0-1 .4477-1 1v6c0 .5523.44772 1 1 1h6c.5523 0 1-.4477 1-1v-6c0-.5523-.4477-1-1-1H4Zm12.5-1c-2.4853 0-4.5 2.0147-4.5 4.5s2.0147 4.5 4.5 4.5 4.5-2.0147 4.5-4.5-2.0147-4.5-4.5-4.5Z"></path></svg>`), ShapesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShapesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShapesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root615();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1615();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShapesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2615();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShapesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShapesSolid = hmr(ShapesSolid, () => ShapesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShapesSolid[HMR].source;
    set(ShapesSolid[HMR].source, module.default[HMR].original);
  });
}
var ShapesSolid_default = ShapesSolid;

// node_modules/flowbite-svelte-icons/dist/ShareAllOutline.svelte
ShareAllOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareAllOutline.svelte";
var root_1616 = add_locations(from_svg(`<title> </title>`), ShareAllOutline[FILENAME], [[43, 4]]);
var root_2616 = add_locations(from_svg(`<desc> </desc>`), ShareAllOutline[FILENAME], [[46, 4]]);
var root616 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15.141 6 5.518 4.95a1.05 1.05 0 0 1 0 1.549l-5.612 5.088m-6.154-3.214v1.615a.95.95 0 0 0 1.525.845l5.108-4.251a1.1 1.1 0 0 0 0-1.646l-5.108-4.251a.95.95 0 0 0-1.525.846v1.7c-3.312 0-6 2.979-6 6.654v1.329a.7.7 0 0 0 1.344.353 5.174 5.174 0 0 1 4.652-3.191l.004-.003Z"></path></svg>`), ShareAllOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShareAllOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShareAllOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root616();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1616();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShareAllOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2616();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShareAllOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShareAllOutline = hmr(ShareAllOutline, () => ShareAllOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareAllOutline[HMR].source;
    set(ShareAllOutline[HMR].source, module.default[HMR].original);
  });
}
var ShareAllOutline_default = ShareAllOutline;

// node_modules/flowbite-svelte-icons/dist/ShareAllSolid.svelte
ShareAllSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareAllSolid.svelte";
var root_1617 = add_locations(from_svg(`<title> </title>`), ShareAllSolid[FILENAME], [[41, 4]]);
var root_2617 = add_locations(from_svg(`<desc> </desc>`), ShareAllSolid[FILENAME], [[44, 4]]);
var root617 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14.516 6.743c-.41-.368-.443-1-.077-1.41a.99.99 0 0 1 1.405-.078l5.487 4.948.007.006A2.047 2.047 0 0 1 22 11.721a2.06 2.06 0 0 1-.662 1.51l-5.584 5.09a.99.99 0 0 1-1.404-.07 1.003 1.003 0 0 1 .068-1.412l5.578-5.082a.05.05 0 0 0 .015-.036.051.051 0 0 0-.015-.036l-5.48-4.942Zm-6.543 9.199v-.42a4.168 4.168 0 0 0-2.715 2.415c-.154.382-.44.695-.806.88a1.683 1.683 0 0 1-2.167-.571 1.705 1.705 0 0 1-.279-1.092V15.88c0-3.77 2.526-7.039 5.967-7.573V7.57a1.957 1.957 0 0 1 .993-1.838 1.931 1.931 0 0 1 2.153.184l5.08 4.248a.646.646 0 0 1 .012.011l.011.01a2.098 2.098 0 0 1 .703 1.57 2.108 2.108 0 0 1-.726 1.59l-5.08 4.25a1.933 1.933 0 0 1-2.929-.614 1.957 1.957 0 0 1-.217-1.04Z" clip-rule="evenodd"></path></svg>`), ShareAllSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShareAllSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShareAllSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root617();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1617();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShareAllSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2617();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShareAllSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShareAllSolid = hmr(ShareAllSolid, () => ShareAllSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareAllSolid[HMR].source;
    set(ShareAllSolid[HMR].source, module.default[HMR].original);
  });
}
var ShareAllSolid_default = ShareAllSolid;

// node_modules/flowbite-svelte-icons/dist/ShareNodesOutline.svelte
ShareNodesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareNodesOutline.svelte";
var root_1618 = add_locations(from_svg(`<title> </title>`), ShareNodesOutline[FILENAME], [[43, 4]]);
var root_2618 = add_locations(from_svg(`<desc> </desc>`), ShareNodesOutline[FILENAME], [[46, 4]]);
var root618 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M7.926 10.898 15 7.727m-7.074 5.39L15 16.29M8 12a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm12 5.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm0-11a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), ShareNodesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShareNodesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShareNodesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root618();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1618();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShareNodesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2618();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShareNodesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShareNodesOutline = hmr(ShareNodesOutline, () => ShareNodesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareNodesOutline[HMR].source;
    set(ShareNodesOutline[HMR].source, module.default[HMR].original);
  });
}
var ShareNodesOutline_default = ShareNodesOutline;

// node_modules/flowbite-svelte-icons/dist/ShareNodesSolid.svelte
ShareNodesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareNodesSolid.svelte";
var root_1619 = add_locations(from_svg(`<title> </title>`), ShareNodesSolid[FILENAME], [[41, 4]]);
var root_2619 = add_locations(from_svg(`<desc> </desc>`), ShareNodesSolid[FILENAME], [[44, 4]]);
var root619 = add_locations(from_svg(`<svg><!><!><path d="M17.5 3a3.5 3.5 0 0 0-3.456 4.06L8.143 9.704a3.5 3.5 0 1 0-.01 4.6l5.91 2.65a3.5 3.5 0 1 0 .863-1.805l-5.94-2.662a3.53 3.53 0 0 0 .002-.961l5.948-2.667A3.5 3.5 0 1 0 17.5 3Z"></path></svg>`), ShareNodesSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShareNodesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShareNodesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root619();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1619();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShareNodesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2619();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShareNodesSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShareNodesSolid = hmr(ShareNodesSolid, () => ShareNodesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareNodesSolid[HMR].source;
    set(ShareNodesSolid[HMR].source, module.default[HMR].original);
  });
}
var ShareNodesSolid_default = ShareNodesSolid;

// node_modules/flowbite-svelte-icons/dist/ShieldCheckOutline.svelte
ShieldCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldCheckOutline.svelte";
var root_1620 = add_locations(from_svg(`<title> </title>`), ShieldCheckOutline[FILENAME], [[43, 4]]);
var root_2620 = add_locations(from_svg(`<desc> </desc>`), ShieldCheckOutline[FILENAME], [[46, 4]]);
var root620 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.5 11.5 11 13l4-3.5M12 20a16.405 16.405 0 0 1-5.092-5.804A16.694 16.694 0 0 1 5 6.666L12 4l7 2.667a16.695 16.695 0 0 1-1.908 7.529A16.406 16.406 0 0 1 12 20Z"></path></svg>`), ShieldCheckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShieldCheckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShieldCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root620();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1620();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShieldCheckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2620();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShieldCheckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShieldCheckOutline = hmr(ShieldCheckOutline, () => ShieldCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldCheckOutline[HMR].source;
    set(ShieldCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var ShieldCheckOutline_default = ShieldCheckOutline;

// node_modules/flowbite-svelte-icons/dist/ShieldCheckSolid.svelte
ShieldCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldCheckSolid.svelte";
var root_1621 = add_locations(from_svg(`<title> </title>`), ShieldCheckSolid[FILENAME], [[41, 4]]);
var root_2621 = add_locations(from_svg(`<desc> </desc>`), ShieldCheckSolid[FILENAME], [[44, 4]]);
var root621 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M11.644 3.066a1 1 0 0 1 .712 0l7 2.666A1 1 0 0 1 20 6.68a17.694 17.694 0 0 1-2.023 7.98 17.406 17.406 0 0 1-5.402 6.158 1 1 0 0 1-1.15 0 17.405 17.405 0 0 1-5.403-6.157A17.695 17.695 0 0 1 4 6.68a1 1 0 0 1 .644-.949l7-2.666Zm4.014 7.187a1 1 0 0 0-1.316-1.506l-3.296 2.884-.839-.838a1 1 0 0 0-1.414 1.414l1.5 1.5a1 1 0 0 0 1.366.046l4-3.5Z" clip-rule="evenodd"></path></svg>`), ShieldCheckSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShieldCheckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShieldCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root621();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1621();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShieldCheckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2621();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShieldCheckSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShieldCheckSolid = hmr(ShieldCheckSolid, () => ShieldCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldCheckSolid[HMR].source;
    set(ShieldCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var ShieldCheckSolid_default = ShieldCheckSolid;

// node_modules/flowbite-svelte-icons/dist/ShieldOutline.svelte
ShieldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldOutline.svelte";
var root_1622 = add_locations(from_svg(`<title> </title>`), ShieldOutline[FILENAME], [[43, 4]]);
var root_2622 = add_locations(from_svg(`<desc> </desc>`), ShieldOutline[FILENAME], [[46, 4]]);
var root622 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 20a16.405 16.405 0 0 1-5.092-5.804A16.694 16.694 0 0 1 5 6.666L12 4l7 2.667a16.695 16.695 0 0 1-1.908 7.529A16.406 16.406 0 0 1 12 20Z"></path></svg>`), ShieldOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShieldOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShieldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root622();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1622();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShieldOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2622();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShieldOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShieldOutline = hmr(ShieldOutline, () => ShieldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldOutline[HMR].source;
    set(ShieldOutline[HMR].source, module.default[HMR].original);
  });
}
var ShieldOutline_default = ShieldOutline;

// node_modules/flowbite-svelte-icons/dist/ShieldSolid.svelte
ShieldSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldSolid.svelte";
var root_1623 = add_locations(from_svg(`<title> </title>`), ShieldSolid[FILENAME], [[41, 4]]);
var root_2623 = add_locations(from_svg(`<desc> </desc>`), ShieldSolid[FILENAME], [[44, 4]]);
var root623 = add_locations(from_svg(`<svg><!><!><path d="M12.356 3.066a1 1 0 0 0-.712 0l-7 2.666A1 1 0 0 0 4 6.68a17.695 17.695 0 0 0 2.022 7.98 17.405 17.405 0 0 0 5.403 6.158 1 1 0 0 0 1.15 0 17.406 17.406 0 0 0 5.402-6.157A17.694 17.694 0 0 0 20 6.68a1 1 0 0 0-.644-.949l-7-2.666Z"></path></svg>`), ShieldSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShieldSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShieldSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root623();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1623();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShieldSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2623();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShieldSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShieldSolid = hmr(ShieldSolid, () => ShieldSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldSolid[HMR].source;
    set(ShieldSolid[HMR].source, module.default[HMR].original);
  });
}
var ShieldSolid_default = ShieldSolid;

// node_modules/flowbite-svelte-icons/dist/ShoppingBagOutline.svelte
ShoppingBagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShoppingBagOutline.svelte";
var root_1624 = add_locations(from_svg(`<title> </title>`), ShoppingBagOutline[FILENAME], [[43, 4]]);
var root_2624 = add_locations(from_svg(`<desc> </desc>`), ShoppingBagOutline[FILENAME], [[46, 4]]);
var root624 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 10V6a3 3 0 0 1 3-3v0a3 3 0 0 1 3 3v4m3-2 .917 11.923A1 1 0 0 1 17.92 21H6.08a1 1 0 0 1-.997-1.077L6 8h12Z"></path></svg>`), ShoppingBagOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShoppingBagOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShoppingBagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root624();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1624();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShoppingBagOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2624();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShoppingBagOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShoppingBagOutline = hmr(ShoppingBagOutline, () => ShoppingBagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShoppingBagOutline[HMR].source;
    set(ShoppingBagOutline[HMR].source, module.default[HMR].original);
  });
}
var ShoppingBagOutline_default = ShoppingBagOutline;

// node_modules/flowbite-svelte-icons/dist/ShoppingBagSolid.svelte
ShoppingBagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShoppingBagSolid.svelte";
var root_1625 = add_locations(from_svg(`<title> </title>`), ShoppingBagSolid[FILENAME], [[41, 4]]);
var root_2625 = add_locations(from_svg(`<desc> </desc>`), ShoppingBagSolid[FILENAME], [[44, 4]]);
var root625 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14 7h-4v3a1 1 0 0 1-2 0V7H6a1 1 0 0 0-.997.923l-.917 11.924A2 2 0 0 0 6.08 22h11.84a2 2 0 0 0 1.994-2.153l-.917-11.924A1 1 0 0 0 18 7h-2v3a1 1 0 1 1-2 0V7Zm-2-3a2 2 0 0 0-2 2v1H8V6a4 4 0 0 1 8 0v1h-2V6a2 2 0 0 0-2-2Z" clip-rule="evenodd"></path></svg>`), ShoppingBagSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShoppingBagSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShoppingBagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root625();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1625();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShoppingBagSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2625();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShoppingBagSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShoppingBagSolid = hmr(ShoppingBagSolid, () => ShoppingBagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShoppingBagSolid[HMR].source;
    set(ShoppingBagSolid[HMR].source, module.default[HMR].original);
  });
}
var ShoppingBagSolid_default = ShoppingBagSolid;

// node_modules/flowbite-svelte-icons/dist/ShrimpOutline.svelte
ShrimpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShrimpOutline.svelte";
var root_1626 = add_locations(from_svg(`<title> </title>`), ShrimpOutline[FILENAME], [[43, 4]]);
var root_2626 = add_locations(from_svg(`<desc> </desc>`), ShrimpOutline[FILENAME], [[46, 4]]);
var root626 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5241 12.4701H8c-1.65685 0-3-1.3432-3-3.00001V8.00003h5m3.5241 4.47007c1.6367 0 2.733 1.6825 2.072 3.1798-.3623.8206-1.1749 1.3501-2.072 1.3501H11c-1.10457 0-2 .8955-2 2v1h6.5m-1.9759-7.5299L15.5 7.76388m-5.5.23615c1.8455-1.2511 3.0772-1.40822 5.5-.23615m-5.5.23615v4.47007L8 14m7.5-6.23612c3.1804-.24503 5.5559 2.36222 4.7544 5.44972-.1054.4062-.2247.8398-.3594 1.3107.0165.8114-.0058 1.4881-.0632 2.0873C19.6315 18.7026 17.6006 20 15.5 20m0 0-1.2042-3.1354M15.6675 14h4.3753M10 4.00003H6c-1.10457 0-2 .89543-2 2s.89543 2 2 2"></path></svg>`), ShrimpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShrimpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShrimpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root626();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1626();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShrimpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2626();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShrimpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShrimpOutline = hmr(ShrimpOutline, () => ShrimpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShrimpOutline[HMR].source;
    set(ShrimpOutline[HMR].source, module.default[HMR].original);
  });
}
var ShrimpOutline_default = ShrimpOutline;

// node_modules/flowbite-svelte-icons/dist/ShrimpSolid.svelte
ShrimpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShrimpSolid.svelte";
var root_1627 = add_locations(from_svg(`<title> </title>`), ShrimpSolid[FILENAME], [[41, 4]]);
var root_2627 = add_locations(from_svg(`<desc> </desc>`), ShrimpSolid[FILENAME], [[44, 4]]);
var root627 = add_locations(from_svg(`<svg><!><!><path d="M6 5.00003c-.55228 0-1 .44772-1 1 0 .55196.44718.99947.99901 1H9v7.49407l-.39242.3002c-.43865.3355-1.06628.252-1.40184-.1867-.28078-.367-.26809-.8664.00054-1.2163C5.37736 13.0232 4 11.4075 4 9.47009V8.23614c-.61375-.54932-1-1.34761-1-2.23611 0-1.65685 1.34315-3 3-3h4c.5523 0 1 .44772 1 1 0 .55229-.4477 1-1 1H6Zm5 8.47007h.9787l2.9923-7.0297c-.8803-.34081-1.6895-.51254-2.4958-.46543-.5196.03035-1.0047.14959-1.4752.33684v7.15829Zm5.9737-6.62806L14.3524 13h6.9717c.5476-3.07251-1.48-5.64288-4.3504-6.15796ZM20.9003 15h-6.1385c-.018.0824-.0446.1647-.0805.246-.0089.0202-.0183.0401-.0282.0597l2.3883 5.4932c1.8902-.4966 3.576-1.9019 3.7858-4.0919.0494-.5152.0739-1.0751.0731-1.707Zm-5.9523 6-2.1739-5H11c-1.65685 0-3 1.3432-3 3v2h6.948Z"></path></svg>`), ShrimpSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ShrimpSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShrimpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root627();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1627();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShrimpSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2627();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShrimpSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShrimpSolid = hmr(ShrimpSolid, () => ShrimpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShrimpSolid[HMR].source;
    set(ShrimpSolid[HMR].source, module.default[HMR].original);
  });
}
var ShrimpSolid_default = ShrimpSolid;

// node_modules/flowbite-svelte-icons/dist/ShuffleOutline.svelte
ShuffleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShuffleOutline.svelte";
var root_1628 = add_locations(from_svg(`<title> </title>`), ShuffleOutline[FILENAME], [[43, 4]]);
var root_2628 = add_locations(from_svg(`<desc> </desc>`), ShuffleOutline[FILENAME], [[46, 4]]);
var root628 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.484 9.166 15 7h5m0 0-3-3m3 3-3 3M4 17h4l1.577-2.253M4 7h4l7 10h5m0 0-3 3m3-3-3-3"></path></svg>`), ShuffleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ShuffleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ShuffleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root628();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1628();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ShuffleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2628();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ShuffleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ShuffleOutline = hmr(ShuffleOutline, () => ShuffleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShuffleOutline[HMR].source;
    set(ShuffleOutline[HMR].source, module.default[HMR].original);
  });
}
var ShuffleOutline_default = ShuffleOutline;

// node_modules/flowbite-svelte-icons/dist/SortHorizontalOutline.svelte
SortHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SortHorizontalOutline.svelte";
var root_1629 = add_locations(from_svg(`<title> </title>`), SortHorizontalOutline[FILENAME], [[43, 4]]);
var root_2629 = add_locations(from_svg(`<desc> </desc>`), SortHorizontalOutline[FILENAME], [[46, 4]]);
var root629 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 16h13M4 16l4-4m-4 4 4 4M20 8H7m13 0-4 4m4-4-4-4"></path></svg>`), SortHorizontalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SortHorizontalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SortHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root629();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1629();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SortHorizontalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2629();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SortHorizontalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SortHorizontalOutline = hmr(SortHorizontalOutline, () => SortHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SortHorizontalOutline[HMR].source;
    set(SortHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var SortHorizontalOutline_default = SortHorizontalOutline;

// node_modules/flowbite-svelte-icons/dist/SortOutline.svelte
SortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SortOutline.svelte";
var root_1630 = add_locations(from_svg(`<title> </title>`), SortOutline[FILENAME], [[43, 4]]);
var root_2630 = add_locations(from_svg(`<desc> </desc>`), SortOutline[FILENAME], [[46, 4]]);
var root630 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20V10m0 10-3-3m3 3 3-3m5-13v10m0-10 3 3m-3-3-3 3"></path></svg>`), SortOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SortOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root630();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1630();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SortOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2630();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SortOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SortOutline = hmr(SortOutline, () => SortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SortOutline[HMR].source;
    set(SortOutline[HMR].source, module.default[HMR].original);
  });
}
var SortOutline_default = SortOutline;

// node_modules/flowbite-svelte-icons/dist/SplitCellsOutline.svelte
SplitCellsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SplitCellsOutline.svelte";
var root_1631 = add_locations(from_svg(`<title> </title>`), SplitCellsOutline[FILENAME], [[43, 4]]);
var root_2631 = add_locations(from_svg(`<desc> </desc>`), SplitCellsOutline[FILENAME], [[46, 4]]);
var root631 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 18v2h6V4H4v2m16 12v2h-6V4h6v2M6.49545 14.4954 4.00003 12m0 0 2.49542-2.49543M4.00003 12h5.94809m7.49798 2.5539L20 12m0 0-2.5539-2.55392M20 12h-5.8319"></path></svg>`), SplitCellsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SplitCellsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SplitCellsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root631();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1631();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SplitCellsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2631();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SplitCellsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SplitCellsOutline = hmr(SplitCellsOutline, () => SplitCellsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SplitCellsOutline[HMR].source;
    set(SplitCellsOutline[HMR].source, module.default[HMR].original);
  });
}
var SplitCellsOutline_default = SplitCellsOutline;

// node_modules/flowbite-svelte-icons/dist/StackoverflowSolid.svelte
StackoverflowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StackoverflowSolid.svelte";
var root_1632 = add_locations(from_svg(`<title> </title>`), StackoverflowSolid[FILENAME], [[41, 4]]);
var root_2632 = add_locations(from_svg(`<desc> </desc>`), StackoverflowSolid[FILENAME], [[44, 4]]);
var root632 = add_locations(from_svg(`<svg><!><!><path d="M17 20v-5h2v6.988H3V15h1.98v5H17Z"></path><path d="m6.84 14.522 8.73 1.825.369-1.755-8.73-1.825-.369 1.755Zm1.155-4.323 8.083 3.764.739-1.617-8.083-3.787-.739 1.64Zm3.372-5.481L10.235 6.08l6.859 5.704 1.132-1.362-6.859-5.704ZM15.57 17H6.655v2h8.915v-2ZM12.861 3.111l6.193 6.415 1.414-1.415-6.43-6.177-1.177 1.177Z"></path></svg>`), StackoverflowSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function StackoverflowSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StackoverflowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root632();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1632();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StackoverflowSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2632();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StackoverflowSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StackoverflowSolid = hmr(StackoverflowSolid, () => StackoverflowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StackoverflowSolid[HMR].source;
    set(StackoverflowSolid[HMR].source, module.default[HMR].original);
  });
}
var StackoverflowSolid_default = StackoverflowSolid;

// node_modules/flowbite-svelte-icons/dist/StarHalfOutline.svelte
StarHalfOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfOutline.svelte";
var root_1633 = add_locations(from_svg(`<title> </title>`), StarHalfOutline[FILENAME], [[43, 4]]);
var root_2633 = add_locations(from_svg(`<desc> </desc>`), StarHalfOutline[FILENAME], [[46, 4]]);
var root633 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="m12.25 20.825 4.247-2.436a1 1 0 0 0 .503-.867V4.03c0-.405-2.062 3.38-2.8 4.747a1 1 0 0 1-.807.523l-4.87.367c-.903.068-1.258 1.208-.55 1.776l3.576 2.878a1 1 0 0 1 .343 1.025l-1.11 4.366c-.217.856.701 1.553 1.468 1.113Z"></path></svg>`), StarHalfOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StarHalfOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarHalfOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root633();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1633();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarHalfOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2633();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarHalfOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarHalfOutline = hmr(StarHalfOutline, () => StarHalfOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfOutline[HMR].source;
    set(StarHalfOutline[HMR].source, module.default[HMR].original);
  });
}
var StarHalfOutline_default = StarHalfOutline;

// node_modules/flowbite-svelte-icons/dist/StarHalfSolid.svelte
StarHalfSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfSolid.svelte";
var root_1634 = add_locations(from_svg(`<title> </title>`), StarHalfSolid[FILENAME], [[41, 4]]);
var root_2634 = add_locations(from_svg(`<desc> </desc>`), StarHalfSolid[FILENAME], [[44, 4]]);
var root634 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13 4.024v-.005c0-.053.002-.353-.217-.632a1.013 1.013 0 0 0-1.176-.315c-.192.076-.315.193-.35.225-.052.05-.094.1-.122.134a4.358 4.358 0 0 0-.31.457c-.207.343-.484.84-.773 1.375a168.719 168.719 0 0 0-1.606 3.074h-.002l-4.599.367c-1.775.14-2.495 2.339-1.143 3.488L6.17 15.14l-1.06 4.406c-.412 1.72 1.472 3.078 2.992 2.157l3.94-2.388c.592-.359.958-.996.958-1.692v-13.6Zm-2.002 0v.025-.025Z" clip-rule="evenodd"></path></svg>`), StarHalfSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StarHalfSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarHalfSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root634();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1634();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarHalfSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2634();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarHalfSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarHalfSolid = hmr(StarHalfSolid, () => StarHalfSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfSolid[HMR].source;
    set(StarHalfSolid[HMR].source, module.default[HMR].original);
  });
}
var StarHalfSolid_default = StarHalfSolid;

// node_modules/flowbite-svelte-icons/dist/StarHalfStrokeOutline.svelte
StarHalfStrokeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfStrokeOutline.svelte";
var root_1635 = add_locations(from_svg(`<title> </title>`), StarHalfStrokeOutline[FILENAME], [[43, 4]]);
var root_2635 = add_locations(from_svg(`<desc> </desc>`), StarHalfStrokeOutline[FILENAME], [[46, 4]]);
var root635 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M12 4.392v14.832M8.476 9.38l-4.553.36c-.888.07-1.248 1.165-.572 1.737l3.47 2.934a.98.98 0 0 1 .322.98l-1.06 4.388c-.206.855.736 1.531 1.497 1.073l3.898-2.351c.32-.193.723-.193 1.044 0l3.898 2.351c.76.458 1.703-.218 1.497-1.073l-1.06-4.388a.982.982 0 0 1 .322-.98l3.47-2.934c.676-.572.316-1.667-.572-1.737l-4.553-.36a1 1 0 0 1-.845-.606l-1.754-4.165c-.342-.812-1.508-.812-1.85 0L9.321 8.774a1 1 0 0 1-.845.606Z"></path></svg>`), StarHalfStrokeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StarHalfStrokeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarHalfStrokeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root635();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1635();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarHalfStrokeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2635();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarHalfStrokeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarHalfStrokeOutline = hmr(StarHalfStrokeOutline, () => StarHalfStrokeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfStrokeOutline[HMR].source;
    set(StarHalfStrokeOutline[HMR].source, module.default[HMR].original);
  });
}
var StarHalfStrokeOutline_default = StarHalfStrokeOutline;

// node_modules/flowbite-svelte-icons/dist/StarHalfStrokeSolid.svelte
StarHalfStrokeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfStrokeSolid.svelte";
var root_1636 = add_locations(from_svg(`<title> </title>`), StarHalfStrokeSolid[FILENAME], [[41, 4]]);
var root_2636 = add_locations(from_svg(`<desc> </desc>`), StarHalfStrokeSolid[FILENAME], [[44, 4]]);
var root636 = add_locations(from_svg(`<svg><!><!><path d="m13.001 19.927 2.896 1.773c1.52.93 3.405-.442 2.992-2.179l-1.06-4.452 3.468-2.978c1.353-1.162.633-3.382-1.142-3.525L15.603 8.2l-1.754-4.226A1.973 1.973 0 0 0 13 3v16.927ZM10.999 3c-.36.205-.663.53-.848.974L8.397 8.2l-4.552.366c-1.775.143-2.495 2.363-1.142 3.525l3.468 2.978-1.06 4.452c-.413 1.737 1.472 3.11 2.992 2.178l2.896-1.773V3Z"></path></svg>`), StarHalfStrokeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StarHalfStrokeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarHalfStrokeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root636();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1636();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarHalfStrokeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2636();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarHalfStrokeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarHalfStrokeSolid = hmr(StarHalfStrokeSolid, () => StarHalfStrokeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfStrokeSolid[HMR].source;
    set(StarHalfStrokeSolid[HMR].source, module.default[HMR].original);
  });
}
var StarHalfStrokeSolid_default = StarHalfStrokeSolid;

// node_modules/flowbite-svelte-icons/dist/StarOutline.svelte
StarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarOutline.svelte";
var root_1637 = add_locations(from_svg(`<title> </title>`), StarOutline[FILENAME], [[43, 4]]);
var root_2637 = add_locations(from_svg(`<desc> </desc>`), StarOutline[FILENAME], [[46, 4]]);
var root637 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M11.083 5.104c.35-.8 1.485-.8 1.834 0l1.752 4.022a1 1 0 0 0 .84.597l4.463.342c.9.069 1.255 1.2.556 1.771l-3.33 2.723a1 1 0 0 0-.337 1.016l1.03 4.119c.214.858-.71 1.552-1.474 1.106l-3.913-2.281a1 1 0 0 0-1.008 0L7.583 20.8c-.764.446-1.688-.248-1.474-1.106l1.03-4.119A1 1 0 0 0 6.8 14.56l-3.33-2.723c-.698-.571-.342-1.702.557-1.771l4.462-.342a1 1 0 0 0 .84-.597l1.753-4.022Z"></path></svg>`), StarOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StarOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root637();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1637();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2637();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarOutline = hmr(StarOutline, () => StarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarOutline[HMR].source;
    set(StarOutline[HMR].source, module.default[HMR].original);
  });
}
var StarOutline_default = StarOutline;

// node_modules/flowbite-svelte-icons/dist/StarSolid.svelte
StarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarSolid.svelte";
var root_1638 = add_locations(from_svg(`<title> </title>`), StarSolid[FILENAME], [[41, 4]]);
var root_2638 = add_locations(from_svg(`<desc> </desc>`), StarSolid[FILENAME], [[44, 4]]);
var root638 = add_locations(from_svg(`<svg><!><!><path d="M13.849 4.22c-.684-1.626-3.014-1.626-3.698 0L8.397 8.387l-4.552.361c-1.775.14-2.495 2.331-1.142 3.477l3.468 2.937-1.06 4.392c-.413 1.713 1.472 3.067 2.992 2.149L12 19.35l3.897 2.354c1.52.918 3.405-.436 2.992-2.15l-1.06-4.39 3.468-2.938c1.353-1.146.633-3.336-1.142-3.477l-4.552-.36-1.754-4.17Z"></path></svg>`), StarSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StarSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root638();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1638();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StarSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2638();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StarSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StarSolid = hmr(StarSolid, () => StarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarSolid[HMR].source;
    set(StarSolid[HMR].source, module.default[HMR].original);
  });
}
var StarSolid_default = StarSolid;

// node_modules/flowbite-svelte-icons/dist/StopOutline.svelte
StopOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StopOutline.svelte";
var root_1639 = add_locations(from_svg(`<title> </title>`), StopOutline[FILENAME], [[43, 4]]);
var root_2639 = add_locations(from_svg(`<desc> </desc>`), StopOutline[FILENAME], [[46, 4]]);
var root639 = add_locations(from_svg(`<svg><!><!><rect width="12" height="12" x="6" y="6" stroke="currentColor" stroke-linejoin="round" rx="1"></rect></svg>`), StopOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StopOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StopOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root639();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1639();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StopOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2639();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StopOutline,
      45,
      2
    );
  }
  var rect = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(rect, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StopOutline = hmr(StopOutline, () => StopOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StopOutline[HMR].source;
    set(StopOutline[HMR].source, module.default[HMR].original);
  });
}
var StopOutline_default = StopOutline;

// node_modules/flowbite-svelte-icons/dist/StopSolid.svelte
StopSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StopSolid.svelte";
var root_1640 = add_locations(from_svg(`<title> </title>`), StopSolid[FILENAME], [[41, 4]]);
var root_2640 = add_locations(from_svg(`<desc> </desc>`), StopSolid[FILENAME], [[44, 4]]);
var root640 = add_locations(from_svg(`<svg><!><!><path d="M7 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H7Z"></path></svg>`), StopSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StopSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StopSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root640();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1640();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StopSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2640();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StopSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StopSolid = hmr(StopSolid, () => StopSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StopSolid[HMR].source;
    set(StopSolid[HMR].source, module.default[HMR].original);
  });
}
var StopSolid_default = StopSolid;

// node_modules/flowbite-svelte-icons/dist/StoreOutline.svelte
StoreOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StoreOutline.svelte";
var root_1641 = add_locations(from_svg(`<title> </title>`), StoreOutline[FILENAME], [[43, 4]]);
var root_2641 = add_locations(from_svg(`<desc> </desc>`), StoreOutline[FILENAME], [[46, 4]]);
var root641 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 12c.263 0 .524-.06.767-.175a2 2 0 0 0 .65-.491c.186-.21.333-.46.433-.734.1-.274.15-.568.15-.864a2.4 2.4 0 0 0 .586 1.591c.375.422.884.659 1.414.659.53 0 1.04-.237 1.414-.659A2.4 2.4 0 0 0 12 9.736a2.4 2.4 0 0 0 .586 1.591c.375.422.884.659 1.414.659.53 0 1.04-.237 1.414-.659A2.4 2.4 0 0 0 16 9.736c0 .295.052.588.152.861s.248.521.434.73a2 2 0 0 0 .649.488 1.809 1.809 0 0 0 1.53 0 2.03 2.03 0 0 0 .65-.488c.185-.209.332-.457.433-.73.1-.273.152-.566.152-.861 0-.974-1.108-3.85-1.618-5.121A.983.983 0 0 0 17.466 4H6.456a.986.986 0 0 0-.93.645C5.045 5.962 4 8.905 4 9.736c.023.59.241 1.148.611 1.567.37.418.865.667 1.389.697Zm0 0c.328 0 .651-.091.94-.266A2.1 2.1 0 0 0 7.66 11h.681a2.1 2.1 0 0 0 .718.734c.29.175.613.266.942.266.328 0 .651-.091.94-.266.29-.174.537-.427.719-.734h.681a2.1 2.1 0 0 0 .719.734c.289.175.612.266.94.266.329 0 .652-.091.942-.266.29-.174.536-.427.718-.734h.681c.183.307.43.56.719.734.29.174.613.266.941.266a1.819 1.819 0 0 0 1.06-.351M6 12a1.766 1.766 0 0 1-1.163-.476M5 12v7a1 1 0 0 0 1 1h2v-5h3v5h7a1 1 0 0 0 1-1v-7m-5 3v2h2v-2h-2Z"></path></svg>`), StoreOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StoreOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StoreOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root641();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1641();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StoreOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2641();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StoreOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StoreOutline = hmr(StoreOutline, () => StoreOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoreOutline[HMR].source;
    set(StoreOutline[HMR].source, module.default[HMR].original);
  });
}
var StoreOutline_default = StoreOutline;

// node_modules/flowbite-svelte-icons/dist/StoreSolid.svelte
StoreSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StoreSolid.svelte";
var root_1642 = add_locations(from_svg(`<title> </title>`), StoreSolid[FILENAME], [[41, 4]]);
var root_2642 = add_locations(from_svg(`<desc> </desc>`), StoreSolid[FILENAME], [[44, 4]]);
var root642 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.535 7.677c.313-.98.687-2.023.926-2.677H17.46c.253.63.646 1.64.977 2.61.166.487.312.953.416 1.347.11.42.148.675.148.779 0 .18-.032.355-.09.515-.06.161-.144.3-.243.412-.1.111-.21.192-.324.245a.809.809 0 0 1-.686 0 1.004 1.004 0 0 1-.324-.245c-.1-.112-.183-.25-.242-.412a1.473 1.473 0 0 1-.091-.515 1 1 0 1 0-2 0 1.4 1.4 0 0 1-.333.927.896.896 0 0 1-.667.323.896.896 0 0 1-.667-.323A1.401 1.401 0 0 1 13 9.736a1 1 0 1 0-2 0 1.4 1.4 0 0 1-.333.927.896.896 0 0 1-.667.323.896.896 0 0 1-.667-.323A1.4 1.4 0 0 1 9 9.74v-.008a1 1 0 0 0-2 .003v.008a1.504 1.504 0 0 1-.18.712 1.22 1.22 0 0 1-.146.209l-.007.007a1.01 1.01 0 0 1-.325.248.82.82 0 0 1-.316.08.973.973 0 0 1-.563-.256 1.224 1.224 0 0 1-.102-.103A1.518 1.518 0 0 1 5 9.724v-.006a2.543 2.543 0 0 1 .029-.207c.024-.132.06-.296.11-.49.098-.385.237-.85.395-1.344ZM4 12.112a3.521 3.521 0 0 1-1-2.376c0-.349.098-.8.202-1.208.112-.441.264-.95.428-1.46.327-1.024.715-2.104.958-2.767A1.985 1.985 0 0 1 6.456 3h11.01c.803 0 1.539.481 1.844 1.243.258.641.67 1.697 1.019 2.72a22.3 22.3 0 0 1 .457 1.487c.114.433.214.903.214 1.286 0 .412-.072.821-.214 1.207A3.288 3.288 0 0 1 20 12.16V19a2 2 0 0 1-2 2h-6a1 1 0 0 1-1-1v-4H8v4a1 1 0 0 1-1 1H6a2 2 0 0 1-2-2v-6.888ZM13 15a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2Z" clip-rule="evenodd"></path></svg>`), StoreSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StoreSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StoreSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root642();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1642();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StoreSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2642();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StoreSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StoreSolid = hmr(StoreSolid, () => StoreSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoreSolid[HMR].source;
    set(StoreSolid[HMR].source, module.default[HMR].original);
  });
}
var StoreSolid_default = StoreSolid;

// node_modules/flowbite-svelte-icons/dist/StroopwafelOutline.svelte
StroopwafelOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StroopwafelOutline.svelte";
var root_1643 = add_locations(from_svg(`<title> </title>`), StroopwafelOutline[FILENAME], [[43, 4]]);
var root_2643 = add_locations(from_svg(`<desc> </desc>`), StroopwafelOutline[FILENAME], [[46, 4]]);
var root643 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 12c0 4.9706-4.0294 9-9 9m9-9c0-4.97056-4.0294-9-9-9m9 9h-5m-4 9c-4.97056 0-9-4.0294-9-9m9 9v-5m-9-4c0-4.97056 4.02944-9 9-9m-9 9h5m4-9v5M8 3.93552V8m0 0v4m0-4H3.93552M8 8h4m-4 4v4m0-4h4m-4 4v4.0645M8 16H3.93552M8 16h4m0-8v4m0-4h4m-4 4v4m0-4h4m-4 4h4m0-12.06448V8m0 0v4m0-4h4.0645M16 12v4m0 0v4.0645M16 16h4.0645"></path></svg>`), StroopwafelOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function StroopwafelOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StroopwafelOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root643();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1643();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StroopwafelOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2643();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StroopwafelOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StroopwafelOutline = hmr(StroopwafelOutline, () => StroopwafelOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StroopwafelOutline[HMR].source;
    set(StroopwafelOutline[HMR].source, module.default[HMR].original);
  });
}
var StroopwafelOutline_default = StroopwafelOutline;

// node_modules/flowbite-svelte-icons/dist/StroopwafelSolid.svelte
StroopwafelSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StroopwafelSolid.svelte";
var root_1644 = add_locations(from_svg(`<title> </title>`), StroopwafelSolid[FILENAME], [[41, 4]]);
var root_2644 = add_locations(from_svg(`<desc> </desc>`), StroopwafelSolid[FILENAME], [[44, 4]]);
var root644 = add_locations(from_svg(`<svg><!><!><path d="M10.9999 2.04938c-.6896.06847-1.35872.20702-1.99996.40842V7h1.99996V2.04938ZM6.99994 3.33782C5.4818 4.21602 4.21596 5.48186 3.33776 7h3.66218V3.33782ZM2.45774 9c-.2014.64124-.33995 1.3103-.40842 2h4.95062V9h-4.5422Zm-.40842 4c.06847.6897.20702 1.3588.40842 2h4.5422v-2H2.04932Zm1.28844 4c.8782 1.5181 2.14404 2.784 3.66218 3.6622V17H3.33776Zm5.66218 4.5422c.64124.2014 1.31036.34 1.99996.4084V17H8.99994v4.5422Zm3.99996.4084c.6897-.0684 1.3588-.207 2-.4084V17h-2v4.9506Zm4-1.2884c1.5182-.8782 2.784-2.1441 3.6622-3.6622h-3.6622v3.6622ZM21.5421 15c.2014-.6412.34-1.3103.4085-2h-4.9507v2h4.5422Zm.4085-4c-.0685-.6897-.2071-1.35876-.4085-2h-4.5422v2h4.9507Zm-1.2885-4c-.8782-1.51814-2.144-2.78398-3.6622-3.66218V7h3.6622Zm-5.6622-4.5422c-.6412-.2014-1.3103-.33995-2-.40842V7h2V2.4578ZM8.99994 9h1.99996v2H8.99994V9Zm0 4h1.99996v2H8.99994v-2Zm3.99996 0v2h2v-2h-2Zm0-2h2V9h-2v2Z"></path></svg>`), StroopwafelSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function StroopwafelSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, StroopwafelSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root644();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1644();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      StroopwafelSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2644();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      StroopwafelSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  StroopwafelSolid = hmr(StroopwafelSolid, () => StroopwafelSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StroopwafelSolid[HMR].source;
    set(StroopwafelSolid[HMR].source, module.default[HMR].original);
  });
}
var StroopwafelSolid_default = StroopwafelSolid;

// node_modules/flowbite-svelte-icons/dist/SubscriptOutline.svelte
SubscriptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SubscriptOutline.svelte";
var root_1645 = add_locations(from_svg(`<title> </title>`), SubscriptOutline[FILENAME], [[43, 4]]);
var root_2645 = add_locations(from_svg(`<desc> </desc>`), SubscriptOutline[FILENAME], [[46, 4]]);
var root645 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 20h-4v-.5c1.0989-1.0329 3.75-2.5 3.75-3.5v-1.0001c0-.5523-.4477-.9999-1-.9999H17c-.5522 0-1 .4477-1 1M4.00004 4l9.12206 11.3932m0-11.3932L4 15.3932"></path></svg>`), SubscriptOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SubscriptOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SubscriptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root645();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1645();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SubscriptOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2645();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SubscriptOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SubscriptOutline = hmr(SubscriptOutline, () => SubscriptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SubscriptOutline[HMR].source;
    set(SubscriptOutline[HMR].source, module.default[HMR].original);
  });
}
var SubscriptOutline_default = SubscriptOutline;

// node_modules/flowbite-svelte-icons/dist/SunOutline.svelte
SunOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SunOutline.svelte";
var root_1646 = add_locations(from_svg(`<title> </title>`), SunOutline[FILENAME], [[43, 4]]);
var root_2646 = add_locations(from_svg(`<desc> </desc>`), SunOutline[FILENAME], [[46, 4]]);
var root646 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5V3m0 18v-2M7.05 7.05 5.636 5.636m12.728 12.728L16.95 16.95M5 12H3m18 0h-2M7.05 16.95l-1.414 1.414M18.364 5.636 16.95 7.05M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"></path></svg>`), SunOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SunOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SunOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root646();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1646();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SunOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2646();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SunOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SunOutline = hmr(SunOutline, () => SunOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SunOutline[HMR].source;
    set(SunOutline[HMR].source, module.default[HMR].original);
  });
}
var SunOutline_default = SunOutline;

// node_modules/flowbite-svelte-icons/dist/SunSolid.svelte
SunSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SunSolid.svelte";
var root_1647 = add_locations(from_svg(`<title> </title>`), SunSolid[FILENAME], [[41, 4]]);
var root_2647 = add_locations(from_svg(`<desc> </desc>`), SunSolid[FILENAME], [[44, 4]]);
var root647 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M13 3a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0V3ZM6.343 4.929A1 1 0 0 0 4.93 6.343l1.414 1.414a1 1 0 0 0 1.414-1.414L6.343 4.929Zm12.728 1.414a1 1 0 0 0-1.414-1.414l-1.414 1.414a1 1 0 0 0 1.414 1.414l1.414-1.414ZM12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-9 4a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2H3Zm16 0a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2ZM7.757 17.657a1 1 0 1 0-1.414-1.414l-1.414 1.414a1 1 0 1 0 1.414 1.414l1.414-1.414Zm9.9-1.414a1 1 0 0 0-1.414 1.414l1.414 1.414a1 1 0 0 0 1.414-1.414l-1.414-1.414ZM13 19a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0v-2Z" clip-rule="evenodd"></path></svg>`), SunSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function SunSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SunSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root647();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1647();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SunSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2647();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SunSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SunSolid = hmr(SunSolid, () => SunSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SunSolid[HMR].source;
    set(SunSolid[HMR].source, module.default[HMR].original);
  });
}
var SunSolid_default = SunSolid;

// node_modules/flowbite-svelte-icons/dist/SuperscriptOutline.svelte
SuperscriptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SuperscriptOutline.svelte";
var root_1648 = add_locations(from_svg(`<title> </title>`), SuperscriptOutline[FILENAME], [[43, 4]]);
var root_2648 = add_locations(from_svg(`<desc> </desc>`), SuperscriptOutline[FILENAME], [[46, 4]]);
var root648 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 10h-4v-.5C17.0989 8.46711 19.75 7 19.75 6V4.99989c0-.55228-.4477-.99989-1-.99989H17c-.5523 0-1 .44772-1 1M4 7.30341l9.1221 11.39319m0-11.39319L4 18.6966"></path></svg>`), SuperscriptOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SuperscriptOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SuperscriptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root648();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1648();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SuperscriptOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2648();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SuperscriptOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SuperscriptOutline = hmr(SuperscriptOutline, () => SuperscriptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SuperscriptOutline[HMR].source;
    set(SuperscriptOutline[HMR].source, module.default[HMR].original);
  });
}
var SuperscriptOutline_default = SuperscriptOutline;

// node_modules/flowbite-svelte-icons/dist/SwatchbookOutline.svelte
SwatchbookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SwatchbookOutline.svelte";
var root_1649 = add_locations(from_svg(`<title> </title>`), SwatchbookOutline[FILENAME], [[43, 4]]);
var root_2649 = add_locations(from_svg(`<desc> </desc>`), SwatchbookOutline[FILENAME], [[46, 4]]);
var root649 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M7.111 20A3.111 3.111 0 0 1 4 16.889v-12C4 4.398 4.398 4 4.889 4h4.444a.89.89 0 0 1 .89.889v12A3.111 3.111 0 0 1 7.11 20Zm0 0h12a.889.889 0 0 0 .889-.889v-4.444a.889.889 0 0 0-.889-.89h-4.389a.889.889 0 0 0-.62.253l-3.767 3.665a.933.933 0 0 0-.146.185c-.868 1.433-1.581 1.858-3.078 2.12Zm0-3.556h.009m7.933-10.927 3.143 3.143a.889.889 0 0 1 0 1.257l-7.974 7.974v-8.8l3.574-3.574a.889.889 0 0 1 1.257 0Z"></path></svg>`), SwatchbookOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function SwatchbookOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SwatchbookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root649();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1649();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SwatchbookOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2649();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SwatchbookOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SwatchbookOutline = hmr(SwatchbookOutline, () => SwatchbookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SwatchbookOutline[HMR].source;
    set(SwatchbookOutline[HMR].source, module.default[HMR].original);
  });
}
var SwatchbookOutline_default = SwatchbookOutline;

// node_modules/flowbite-svelte-icons/dist/SwatchbookSolid.svelte
SwatchbookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SwatchbookSolid.svelte";
var root_1650 = add_locations(from_svg(`<title> </title>`), SwatchbookSolid[FILENAME], [[41, 4]]);
var root_2650 = add_locations(from_svg(`<desc> </desc>`), SwatchbookSolid[FILENAME], [[44, 4]]);
var root650 = add_locations(from_svg(`<svg><!><!><path d="M20 14h-2.722L11 20.278a5.511 5.511 0 0 1-.9.722H20a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1ZM9 3H4a1 1 0 0 0-1 1v13.5a3.5 3.5 0 1 0 7 0V4a1 1 0 0 0-1-1ZM6.5 18.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2ZM19.132 7.9 15.6 4.368a1 1 0 0 0-1.414 0L12 6.55v9.9l7.132-7.132a1 1 0 0 0 0-1.418Z"></path></svg>`), SwatchbookSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function SwatchbookSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, SwatchbookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root650();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1650();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      SwatchbookSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2650();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      SwatchbookSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  SwatchbookSolid = hmr(SwatchbookSolid, () => SwatchbookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SwatchbookSolid[HMR].source;
    set(SwatchbookSolid[HMR].source, module.default[HMR].original);
  });
}
var SwatchbookSolid_default = SwatchbookSolid;

// node_modules/flowbite-svelte-icons/dist/TableColumnOutline.svelte
TableColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableColumnOutline.svelte";
var root_1651 = add_locations(from_svg(`<title> </title>`), TableColumnOutline[FILENAME], [[43, 4]]);
var root_2651 = add_locations(from_svg(`<desc> </desc>`), TableColumnOutline[FILENAME], [[46, 4]]);
var root651 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M3 11h18m-9 0v8m-8 0h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TableColumnOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TableColumnOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TableColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root651();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1651();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TableColumnOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2651();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TableColumnOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TableColumnOutline = hmr(TableColumnOutline, () => TableColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableColumnOutline[HMR].source;
    set(TableColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var TableColumnOutline_default = TableColumnOutline;

// node_modules/flowbite-svelte-icons/dist/TableColumnSolid.svelte
TableColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableColumnSolid.svelte";
var root_1652 = add_locations(from_svg(`<title> </title>`), TableColumnSolid[FILENAME], [[41, 4]]);
var root_2652 = add_locations(from_svg(`<desc> </desc>`), TableColumnSolid[FILENAME], [[44, 4]]);
var root652 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm0 8v6h7v-6H4Zm16 6h-7v-6h7v6Z" clip-rule="evenodd"></path></svg>`), TableColumnSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TableColumnSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TableColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root652();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1652();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TableColumnSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2652();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TableColumnSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TableColumnSolid = hmr(TableColumnSolid, () => TableColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableColumnSolid[HMR].source;
    set(TableColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var TableColumnSolid_default = TableColumnSolid;

// node_modules/flowbite-svelte-icons/dist/TableRowOutline.svelte
TableRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableRowOutline.svelte";
var root_1653 = add_locations(from_svg(`<title> </title>`), TableRowOutline[FILENAME], [[43, 4]]);
var root_2653 = add_locations(from_svg(`<desc> </desc>`), TableRowOutline[FILENAME], [[46, 4]]);
var root653 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M3 11h18M3 15h18m-9-4v8m-8 0h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TableRowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TableRowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TableRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root653();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1653();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TableRowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2653();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TableRowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TableRowOutline = hmr(TableRowOutline, () => TableRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableRowOutline[HMR].source;
    set(TableRowOutline[HMR].source, module.default[HMR].original);
  });
}
var TableRowOutline_default = TableRowOutline;

// node_modules/flowbite-svelte-icons/dist/TableRowSolid.svelte
TableRowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableRowSolid.svelte";
var root_1654 = add_locations(from_svg(`<title> </title>`), TableRowSolid[FILENAME], [[41, 4]]);
var root_2654 = add_locations(from_svg(`<desc> </desc>`), TableRowSolid[FILENAME], [[44, 4]]);
var root654 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm2 8v-2h7v2H4Zm0 2v2h7v-2H4Zm9 2h7v-2h-7v2Zm7-4v-2h-7v2h7Z" clip-rule="evenodd"></path></svg>`), TableRowSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TableRowSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TableRowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root654();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1654();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TableRowSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2654();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TableRowSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TableRowSolid = hmr(TableRowSolid, () => TableRowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableRowSolid[HMR].source;
    set(TableRowSolid[HMR].source, module.default[HMR].original);
  });
}
var TableRowSolid_default = TableRowSolid;

// node_modules/flowbite-svelte-icons/dist/TabletOutline.svelte
TabletOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TabletOutline.svelte";
var root_1655 = add_locations(from_svg(`<title> </title>`), TabletOutline[FILENAME], [[43, 4]]);
var root_2655 = add_locations(from_svg(`<desc> </desc>`), TabletOutline[FILENAME], [[46, 4]]);
var root655 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 18h2M5.875 3h12.25c.483 0 .875.448.875 1v16c0 .552-.392 1-.875 1H5.875C5.392 21 5 20.552 5 20V4c0-.552.392-1 .875-1Z"></path></svg>`), TabletOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TabletOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TabletOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root655();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1655();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TabletOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2655();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TabletOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TabletOutline = hmr(TabletOutline, () => TabletOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabletOutline[HMR].source;
    set(TabletOutline[HMR].source, module.default[HMR].original);
  });
}
var TabletOutline_default = TabletOutline;

// node_modules/flowbite-svelte-icons/dist/TabletSolid.svelte
TabletSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TabletSolid.svelte";
var root_1656 = add_locations(from_svg(`<title> </title>`), TabletSolid[FILENAME], [[41, 4]]);
var root_2656 = add_locations(from_svg(`<desc> </desc>`), TabletSolid[FILENAME], [[44, 4]]);
var root656 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4c0-.975.718-2 1.875-2h12.25C19.282 2 20 3.025 20 4v16c0 .975-.718 2-1.875 2H5.875C4.718 22 4 20.975 4 20V4Zm7 13a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), TabletSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TabletSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TabletSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root656();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1656();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TabletSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2656();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TabletSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TabletSolid = hmr(TabletSolid, () => TabletSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabletSolid[HMR].source;
    set(TabletSolid[HMR].source, module.default[HMR].original);
  });
}
var TabletSolid_default = TabletSolid;

// node_modules/flowbite-svelte-icons/dist/TagOutline.svelte
TagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TagOutline.svelte";
var root_1657 = add_locations(from_svg(`<title> </title>`), TagOutline[FILENAME], [[43, 4]]);
var root_2657 = add_locations(from_svg(`<desc> </desc>`), TagOutline[FILENAME], [[46, 4]]);
var root657 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.583 8.445h.01M10.86 19.71l-6.573-6.63a.993.993 0 0 1 0-1.4l7.329-7.394A.98.98 0 0 1 12.31 4l5.734.007A1.968 1.968 0 0 1 20 5.983v5.5a.992.992 0 0 1-.316.727l-7.44 7.5a.974.974 0 0 1-1.384.001Z"></path></svg>`), TagOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TagOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root657();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1657();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TagOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2657();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TagOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TagOutline = hmr(TagOutline, () => TagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TagOutline[HMR].source;
    set(TagOutline[HMR].source, module.default[HMR].original);
  });
}
var TagOutline_default = TagOutline;

// node_modules/flowbite-svelte-icons/dist/TagSolid.svelte
TagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TagSolid.svelte";
var root_1658 = add_locations(from_svg(`<title> </title>`), TagSolid[FILENAME], [[41, 4]]);
var root_2658 = add_locations(from_svg(`<desc> </desc>`), TagSolid[FILENAME], [[44, 4]]);
var root658 = add_locations(from_svg(`<svg><!><!><path d="M18.045 3.007 12.31 3a1.965 1.965 0 0 0-1.4.585l-7.33 7.394a2 2 0 0 0 0 2.805l6.573 6.631a1.957 1.957 0 0 0 1.4.585 1.965 1.965 0 0 0 1.4-.585l7.409-7.477A2 2 0 0 0 21 11.479v-5.5a2.972 2.972 0 0 0-2.955-2.972Zm-2.452 6.438a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>`), TagSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TagSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root658();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1658();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TagSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2658();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TagSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TagSolid = hmr(TagSolid, () => TagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TagSolid[HMR].source;
    set(TagSolid[HMR].source, module.default[HMR].original);
  });
}
var TagSolid_default = TagSolid;

// node_modules/flowbite-svelte-icons/dist/TailwindSolid.svelte
TailwindSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TailwindSolid.svelte";
var root_1659 = add_locations(from_svg(`<title> </title>`), TailwindSolid[FILENAME], [[41, 4]]);
var root_2659 = add_locations(from_svg(`<desc> </desc>`), TailwindSolid[FILENAME], [[44, 4]]);
var root659 = add_locations(from_svg(`<svg><!><!><path d="M11.782 5.72a4.773 4.773 0 0 0-4.8 4.173 3.43 3.43 0 0 1 2.741-1.687c1.689 0 2.974 1.972 3.758 2.587a5.733 5.733 0 0 0 5.382.935c2-.638 2.934-2.865 3.137-3.921-.969 1.379-2.44 2.207-4.259 1.231-1.253-.673-2.19-3.438-5.959-3.318ZM6.8 11.979A4.772 4.772 0 0 0 2 16.151a3.431 3.431 0 0 1 2.745-1.687c1.689 0 2.974 1.972 3.758 2.587a5.733 5.733 0 0 0 5.382.935c2-.638 2.933-2.865 3.137-3.921-.97 1.379-2.44 2.208-4.259 1.231-1.253-.673-2.19-3.443-5.963-3.317Z"></path></svg>`), TailwindSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TailwindSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TailwindSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root659();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1659();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TailwindSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2659();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TailwindSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TailwindSolid = hmr(TailwindSolid, () => TailwindSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TailwindSolid[HMR].source;
    set(TailwindSolid[HMR].source, module.default[HMR].original);
  });
}
var TailwindSolid_default = TailwindSolid;

// node_modules/flowbite-svelte-icons/dist/TeddyBearOutline.svelte
TeddyBearOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TeddyBearOutline.svelte";
var root_1660 = add_locations(from_svg(`<title> </title>`), TeddyBearOutline[FILENAME], [[43, 4]]);
var root_2660 = add_locations(from_svg(`<desc> </desc>`), TeddyBearOutline[FILENAME], [[46, 4]]);
var root660 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.5 15C6.11929 15 5 16.1193 5 17.5S6.11929 20 7.5 20s2.5-1.1193 2.5-2.5S8.88071 15 7.5 15Zm0 0 1.67693-4.1693m6.69787-3.82761C17.0117 7.00309 18 6.10457 18 5c0-1.10457-.9217-2-2.0586-2-.8963 0-1.6853.74312-1.9679 1.51992M8.12719 6.99544C7.00181 6.99544 6 6.10457 6 5s.9123-2 2.03768-2c.93446 0 1.70666.67806 1.94698 1.51992M14 18h-4m6-3-1.4578-3.8912m-6.63506 2.8789-.44889.1929C6.24889 14.5837 5 13.6836 5 12.4088c0-.8339.55278-1.5667 1.35457-1.7958L8.5 10m7.1055 3.9877.4133.1446c1.2127.4242 2.4812-.476 2.4812-1.7607 0-.8159-.5302-1.5371-1.309-1.7805l-1.7458-.5575M12 9.06243v-.01m-1.3779-1.55397v-.01m3.0337.01v-.01M16 8c0 2.2091-1.7909 4-4 4-2.20914 0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091 0 4 1.79086 4 4Zm3 9.5c0 1.3807-1.1193 2.5-2.5 2.5S14 18.8807 14 17.5s1.1193-2.5 2.5-2.5 2.5 1.1193 2.5 2.5Z"></path></svg>`), TeddyBearOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TeddyBearOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TeddyBearOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root660();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1660();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TeddyBearOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2660();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TeddyBearOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TeddyBearOutline = hmr(TeddyBearOutline, () => TeddyBearOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TeddyBearOutline[HMR].source;
    set(TeddyBearOutline[HMR].source, module.default[HMR].original);
  });
}
var TeddyBearOutline_default = TeddyBearOutline;

// node_modules/flowbite-svelte-icons/dist/TeddyBearSolid.svelte
TeddyBearSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TeddyBearSolid.svelte";
var root_1661 = add_locations(from_svg(`<title> </title>`), TeddyBearSolid[FILENAME], [[41, 4]]);
var root_2661 = add_locations(from_svg(`<desc> </desc>`), TeddyBearSolid[FILENAME], [[44, 4]]);
var root661 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M10.451 3.244C9.911 2.514 9.052 2 8.038 2 6.378 2 5 3.326 5 5c0 1.315.88 2.36 2.004 2.787a5.082 5.082 0 0 0 .177 1.55L6.08 9.65a2.868 2.868 0 0 0-.802 5.145A3.5 3.5 0 1 0 10.663 19h2.674a3.5 3.5 0 1 0 5.11-4.409 2.865 2.865 0 0 0-.954-4.953l-.696-.223a5.002 5.002 0 0 0 .2-1.588l-.001-.031C18.128 7.367 19 6.311 19 5c0-1.684-1.397-3-3.059-3-1.005 0-1.841.554-2.384 1.247A4.996 4.996 0 0 0 12 3c-.54 0-1.061.086-1.549.244ZM8.685 4.257c-.49.435-.895.964-1.184 1.56C7.193 5.624 7 5.304 7 5c0-.535.447-1 1.038-1a.99.99 0 0 1 .647.257ZM17 5c0 .31-.19.63-.497.824a5.017 5.017 0 0 0-1.174-1.555c.197-.169.423-.269.612-.269C16.553 4 17 4.475 17 5Zm-2 12.5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Zm-9 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Zm5.043-10.012a.5.5 0 0 0-1 0v.01a.5.5 0 0 0 1 0v-.01Zm3.023.01a.5.5 0 0 0-1 0v.01a.5.5 0 1 0 1 0v-.01ZM13 9.052a1 1 0 1 0-2 0v.01a1 1 0 1 0 2 0v-.01Z" clip-rule="evenodd"></path></svg>`), TeddyBearSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TeddyBearSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TeddyBearSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root661();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1661();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TeddyBearSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2661();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TeddyBearSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TeddyBearSolid = hmr(TeddyBearSolid, () => TeddyBearSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TeddyBearSolid[HMR].source;
    set(TeddyBearSolid[HMR].source, module.default[HMR].original);
  });
}
var TeddyBearSolid_default = TeddyBearSolid;

// node_modules/flowbite-svelte-icons/dist/TerminalOutline.svelte
TerminalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TerminalOutline.svelte";
var root_1662 = add_locations(from_svg(`<title> </title>`), TerminalOutline[FILENAME], [[43, 4]]);
var root_2662 = add_locations(from_svg(`<desc> </desc>`), TerminalOutline[FILENAME], [[46, 4]]);
var root662 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 9 3 3-3 3m5 0h3M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TerminalOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TerminalOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TerminalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root662();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1662();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TerminalOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2662();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TerminalOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TerminalOutline = hmr(TerminalOutline, () => TerminalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TerminalOutline[HMR].source;
    set(TerminalOutline[HMR].source, module.default[HMR].original);
  });
}
var TerminalOutline_default = TerminalOutline;

// node_modules/flowbite-svelte-icons/dist/TerminalSolid.svelte
TerminalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TerminalSolid.svelte";
var root_1663 = add_locations(from_svg(`<title> </title>`), TerminalSolid[FILENAME], [[41, 4]]);
var root_2663 = add_locations(from_svg(`<desc> </desc>`), TerminalSolid[FILENAME], [[44, 4]]);
var root663 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3Zm4.293 5.707a1 1 0 0 1 1.414-1.414l3 3a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L9.586 12 7.293 9.707ZM13 14a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Z" clip-rule="evenodd"></path></svg>`), TerminalSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TerminalSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TerminalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root663();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1663();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TerminalSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2663();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TerminalSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TerminalSolid = hmr(TerminalSolid, () => TerminalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TerminalSolid[HMR].source;
    set(TerminalSolid[HMR].source, module.default[HMR].original);
  });
}
var TerminalSolid_default = TerminalSolid;

// node_modules/flowbite-svelte-icons/dist/TextSizeOutline.svelte
TextSizeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextSizeOutline.svelte";
var root_1664 = add_locations(from_svg(`<title> </title>`), TextSizeOutline[FILENAME], [[43, 4]]);
var root_2664 = add_locations(from_svg(`<desc> </desc>`), TextSizeOutline[FILENAME], [[46, 4]]);
var root664 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 6.2V5h11v1.2M8 5v14m-3 0h6m2-6.8V11h8v1.2M17 11v8m-1.5 0h3"></path></svg>`), TextSizeOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TextSizeOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TextSizeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root664();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1664();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TextSizeOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2664();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TextSizeOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TextSizeOutline = hmr(TextSizeOutline, () => TextSizeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextSizeOutline[HMR].source;
    set(TextSizeOutline[HMR].source, module.default[HMR].original);
  });
}
var TextSizeOutline_default = TextSizeOutline;

// node_modules/flowbite-svelte-icons/dist/TextSlashOutline.svelte
TextSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextSlashOutline.svelte";
var root_1665 = add_locations(from_svg(`<title> </title>`), TextSlashOutline[FILENAME], [[43, 4]]);
var root_2665 = add_locations(from_svg(`<desc> </desc>`), TextSlashOutline[FILENAME], [[46, 4]]);
var root665 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 6.2V5h12v1.2M7 19h6m.2-14-1.677 6.523M9.6 19l1.029-4M5 5l6.523 6.523M19 19l-7.477-7.477"></path></svg>`), TextSlashOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TextSlashOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TextSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root665();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1665();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TextSlashOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2665();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TextSlashOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TextSlashOutline = hmr(TextSlashOutline, () => TextSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextSlashOutline[HMR].source;
    set(TextSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var TextSlashOutline_default = TextSlashOutline;

// node_modules/flowbite-svelte-icons/dist/TextUnderlineOutline.svelte
TextUnderlineOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextUnderlineOutline.svelte";
var root_1666 = add_locations(from_svg(`<title> </title>`), TextUnderlineOutline[FILENAME], [[43, 4]]);
var root_2666 = add_locations(from_svg(`<desc> </desc>`), TextUnderlineOutline[FILENAME], [[46, 4]]);
var root666 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 19h14M7.6 16l4.2979-10.92963c.0368-.09379.1674-.09379.2042 0L16.4 16m-8.8 0H6.5m1.1 0h1.65m7.15 0h-1.65m1.65 0h1.1m-8.33315-4h5.66025"></path></svg>`), TextUnderlineOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TextUnderlineOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TextUnderlineOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root666();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1666();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TextUnderlineOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2666();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TextUnderlineOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TextUnderlineOutline = hmr(TextUnderlineOutline, () => TextUnderlineOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextUnderlineOutline[HMR].source;
    set(TextUnderlineOutline[HMR].source, module.default[HMR].original);
  });
}
var TextUnderlineOutline_default = TextUnderlineOutline;

// node_modules/flowbite-svelte-icons/dist/TheatreOutline.svelte
TheatreOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TheatreOutline.svelte";
var root_1667 = add_locations(from_svg(`<title> </title>`), TheatreOutline[FILENAME], [[43, 4]]);
var root_2667 = add_locations(from_svg(`<desc> </desc>`), TheatreOutline[FILENAME], [[46, 4]]);
var root667 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m7.53316 11.8623.00957-.0029m5.58157 7.1424c-.5.515-.9195.8473-1.0611.8903-.4784.1454-5.42881-1.2797-6.23759-3.3305-.80878-2.0507-1.83058-5.8152-1.88967-6.2192-.0591-.40404 1.5599-1.72424 3.59722-2.61073m1.98839 8.05513c-.22637.262-.38955.5599-.55552.8474M13.4999 12c.5.5 1 1.049 2 1.049s1.5-.549 2-1.049m-4-4h.01m3.99 0h.01m-7.01-2.5c0-.28929 2.5-1.5 5-1.5s5 1.13645 5 1.5V12c0 1.9655-4.291 5-5 5-.7432 0-5-3.0345-5-5V5.5Z"></path></svg>`), TheatreOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TheatreOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TheatreOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root667();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1667();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TheatreOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2667();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TheatreOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TheatreOutline = hmr(TheatreOutline, () => TheatreOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TheatreOutline[HMR].source;
    set(TheatreOutline[HMR].source, module.default[HMR].original);
  });
}
var TheatreOutline_default = TheatreOutline;

// node_modules/flowbite-svelte-icons/dist/TheatreSolid.svelte
TheatreSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TheatreSolid.svelte";
var root_1668 = add_locations(from_svg(`<title> </title>`), TheatreSolid[FILENAME], [[41, 4]]);
var root_2668 = add_locations(from_svg(`<desc> </desc>`), TheatreSolid[FILENAME], [[44, 4]]);
var root668 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M7.50001 6.49476c-.00222.00067-.00443.00134-.00665.00202-1.36964.41615-2.57189 1.22541-3.40555 1.89335-.42318.33907-.76614.65372-1.00483.88517-.11959.11596-.21369.21169-.2793.27999-.03283.03417-.05857.06153-.07687.08118l-.02184.02361-.00665.00728-.00225.00247-.00152.00167c-.23565.26049-.31736.6255-.21524.9616l1.88966 6.2193c.28122.9255.90731 1.6328 1.59535 2.159.68925.5272 1.4966.9166 2.25327 1.198.76111.2832 1.50814.4708 2.10341.5791.2973.054.5684.0904.7934.1077.1117.0085.2238.0133.3286.0113.0814-.0016.2434-.0076.4111-.0586.1678-.051.3057-.1361.3743-.18.0882-.0566.1786-.123.2667-.1923.1774-.1395.3824-.3205.5994-.5309-.076-.0369-.1525-.0755-.2297-.1152-.6068-.312-1.3433-.7546-2.0675-1.3064-.4898-.3733-1.01068-.8242-1.48988-1.3492-.28662.4467-.87678.5935-1.34124.3253-.47829-.2761-.64217-.8877-.36603-1.366.01906-.033.03873-.0675.05915-.1034.10835-.1902.23774-.4173.40797-.6498C7.73454 14.6941 7.5 13.8935 7.5 13V6.5l.00001-.00524ZM5.72195 11.0461c-.52844.1606-.82665.7191-.6661 1.2476.16056.5284.7191.8266 1.24753.6661l.00957-.003c.52843-.1605.82665-.7191.66609-1.2475-.16056-.5284-.7191-.8266-1.24753-.6661l-.00956.0029Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M15 4c-1.4315 0-2.8171.42479-3.8089.82152-.5035.2014-.9231.40276-1.21876.55482-.14814.07618-.26601.14043-.34864.1867-.04134.02315-.07393.04184-.09715.05533l-.02775.01624-.00849.00502-.00286.00171-.00195.00117C9.1843 5.82323 9 6.14874 9 6.5V13c0 .9673.39342 1.8261.89875 2.5296.50625.7048 1.16555 1.312 1.80765 1.8013.646.4922 1.3062.8889 1.8442 1.1655.2688.1382.5176.2518.7279.3338.1044.0407.2102.0778.3111.1063.0784.0222.2351.0635.4104.0635.1753 0 .332-.0413.4104-.0635.1009-.0285.2067-.0656.3111-.1063.2103-.082.4591-.1956.7279-.3338.538-.2766 1.1982-.6733 1.8442-1.1655.6421-.4893 1.3014-1.0965 1.8076-1.8013C20.6066 14.8261 21 13.9673 21 13V6.5c0-.35126-.1852-.67728-.4864-.85801l-.001-.00065-.0029-.00171-.0085-.00502-.0278-.01624c-.0232-.01349-.0558-.03218-.0971-.05533-.0826-.04627-.2005-.11052-.3486-.1867-.2957-.15206-.7153-.35342-1.2188-.55482C17.8171 4.42479 16.4315 4 15 4Zm5 2.5.5136-.85801S20.5145 5.64251 20 6.5ZM13 7c-.5523 0-1 .44772-1 1s.4477 1 1 1h.01c.5523 0 1-.44772 1-1s-.4477-1-1-1H13Zm4 0c-.5523 0-1 .44772-1 1s.4477 1 1 1h.01c.5523 0 1-.44772 1-1s-.4477-1-1-1H17Zm-4.7071 4.2929c-.3905.3905-.3905 1.0237 0 1.4142.0269.027.0549.0552.0838.0845.4776.4831 1.243 1.2574 2.6233 1.2574 1.3803 0 2.1457-.7743 2.6232-1.2573.029-.0294.057-.0576.0839-.0846.3905-.3905.3905-1.0237 0-1.4142-.3905-.3905-1.0237-.3905-1.4142 0-.5293.5293-.757.7561-1.2929.7561-.5359 0-.7636-.2268-1.2929-.7561-.3905-.3905-1.0237-.3905-1.4142 0Z" clip-rule="evenodd"></path></svg>`), TheatreSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function TheatreSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TheatreSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root668();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1668();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TheatreSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2668();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TheatreSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TheatreSolid = hmr(TheatreSolid, () => TheatreSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TheatreSolid[HMR].source;
    set(TheatreSolid[HMR].source, module.default[HMR].original);
  });
}
var TheatreSolid_default = TheatreSolid;

// node_modules/flowbite-svelte-icons/dist/ThumbsDownOutline.svelte
ThumbsDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsDownOutline.svelte";
var root_1669 = add_locations(from_svg(`<title> </title>`), ThumbsDownOutline[FILENAME], [[43, 4]]);
var root_2669 = add_locations(from_svg(`<desc> </desc>`), ThumbsDownOutline[FILENAME], [[46, 4]]);
var root669 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 13c-.889.086-1.416.543-2.156 1.057a22.322 22.322 0 0 0-3.958 5.084 1.6 1.6 0 0 1-.582.628 1.549 1.549 0 0 1-1.466.087 1.587 1.587 0 0 1-.537-.406 1.666 1.666 0 0 1-.384-1.279l1.389-4.114M17 13h3V6.5A1.5 1.5 0 0 0 18.5 5v0A1.5 1.5 0 0 0 17 6.5V13Zm-6.5 1H5.585c-.286 0-.372-.014-.626-.15a1.797 1.797 0 0 1-.637-.572 1.873 1.873 0 0 1-.215-1.673l2.098-6.4C6.462 4.48 6.632 4 7.88 4c2.302 0 4.79.943 6.67 1.475"></path></svg>`), ThumbsDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ThumbsDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbsDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root669();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1669();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbsDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2669();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbsDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbsDownOutline = hmr(ThumbsDownOutline, () => ThumbsDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsDownOutline[HMR].source;
    set(ThumbsDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbsDownOutline_default = ThumbsDownOutline;

// node_modules/flowbite-svelte-icons/dist/ThumbsDownSolid.svelte
ThumbsDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsDownSolid.svelte";
var root_1670 = add_locations(from_svg(`<title> </title>`), ThumbsDownSolid[FILENAME], [[41, 4]]);
var root_2670 = add_locations(from_svg(`<desc> </desc>`), ThumbsDownSolid[FILENAME], [[44, 4]]);
var root670 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.97 14.316H5.004c-.322 0-.64-.08-.925-.232a2.022 2.022 0 0 1-.717-.645 2.108 2.108 0 0 1-.242-1.883l2.36-7.201C5.769 3.54 5.96 3 7.365 3c2.072 0 4.276.678 6.156 1.256.473.145.925.284 1.35.404h.114v9.862a25.485 25.485 0 0 0-4.238 5.514c-.197.376-.516.67-.901.83a1.74 1.74 0 0 1-1.21.048 1.79 1.79 0 0 1-.96-.757 1.867 1.867 0 0 1-.269-1.211l1.562-4.63ZM19.822 14H17V6a2 2 0 1 1 4 0v6.823c0 .65-.527 1.177-1.177 1.177Z" clip-rule="evenodd"></path></svg>`), ThumbsDownSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbsDownSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbsDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root670();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1670();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbsDownSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2670();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbsDownSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbsDownSolid = hmr(ThumbsDownSolid, () => ThumbsDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsDownSolid[HMR].source;
    set(ThumbsDownSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbsDownSolid_default = ThumbsDownSolid;

// node_modules/flowbite-svelte-icons/dist/ThumbsUpOutline.svelte
ThumbsUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsUpOutline.svelte";
var root_1671 = add_locations(from_svg(`<title> </title>`), ThumbsUpOutline[FILENAME], [[43, 4]]);
var root_2671 = add_locations(from_svg(`<desc> </desc>`), ThumbsUpOutline[FILENAME], [[46, 4]]);
var root671 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 11c.889-.086 1.416-.543 2.156-1.057a22.323 22.323 0 0 0 3.958-5.084 1.6 1.6 0 0 1 .582-.628 1.549 1.549 0 0 1 1.466-.087c.205.095.388.233.537.406a1.64 1.64 0 0 1 .384 1.279l-1.388 4.114M7 11H4v6.5A1.5 1.5 0 0 0 5.5 19v0A1.5 1.5 0 0 0 7 17.5V11Zm6.5-1h4.915c.286 0 .372.014.626.15.254.135.472.332.637.572a1.874 1.874 0 0 1 .215 1.673l-2.098 6.4C17.538 19.52 17.368 20 16.12 20c-2.303 0-4.79-.943-6.67-1.475"></path></svg>`), ThumbsUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ThumbsUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbsUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root671();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1671();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbsUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2671();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbsUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbsUpOutline = hmr(ThumbsUpOutline, () => ThumbsUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsUpOutline[HMR].source;
    set(ThumbsUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbsUpOutline_default = ThumbsUpOutline;

// node_modules/flowbite-svelte-icons/dist/ThumbsUpSolid.svelte
ThumbsUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsUpSolid.svelte";
var root_1672 = add_locations(from_svg(`<title> </title>`), ThumbsUpSolid[FILENAME], [[41, 4]]);
var root_2672 = add_locations(from_svg(`<desc> </desc>`), ThumbsUpSolid[FILENAME], [[44, 4]]);
var root672 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M15.03 9.684h3.965c.322 0 .64.08.925.232.286.153.532.374.717.645a2.109 2.109 0 0 1 .242 1.883l-2.36 7.201c-.288.814-.48 1.355-1.884 1.355-2.072 0-4.276-.677-6.157-1.256-.472-.145-.924-.284-1.348-.404h-.115V9.478a25.485 25.485 0 0 0 4.238-5.514 1.8 1.8 0 0 1 .901-.83 1.74 1.74 0 0 1 1.21-.048c.396.13.736.397.96.757.225.36.32.788.269 1.211l-1.562 4.63ZM4.177 10H7v8a2 2 0 1 1-4 0v-6.823C3 10.527 3.527 10 4.176 10Z" clip-rule="evenodd"></path></svg>`), ThumbsUpSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbsUpSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbsUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root672();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1672();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbsUpSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2672();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbsUpSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbsUpSolid = hmr(ThumbsUpSolid, () => ThumbsUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsUpSolid[HMR].source;
    set(ThumbsUpSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbsUpSolid_default = ThumbsUpSolid;

// node_modules/flowbite-svelte-icons/dist/ThumbtackOutline.svelte
ThumbtackOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbtackOutline.svelte";
var root_1673 = add_locations(from_svg(`<title> </title>`), ThumbtackOutline[FILENAME], [[43, 4]]);
var root_2673 = add_locations(from_svg(`<desc> </desc>`), ThumbtackOutline[FILENAME], [[46, 4]]);
var root673 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M12.0001 20v-4M7.00012 4h9.99998M9.00012 5v5c0 .5523-.46939 1.0045-.94861 1.279-1.43433.8217-2.60135 3.245-2.25635 4.3653.07806.2535.35396.3557.61917.3557H17.5859c.2652 0 .5411-.1022.6192-.3557.3449-1.1204-.8221-3.5436-2.2564-4.3653-.4792-.2745-.9486-.7267-.9486-1.279V5c0-.55228-.4477-1-1-1h-4c-.55226 0-.99998.44772-.99998 1Z"></path></svg>`), ThumbtackOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ThumbtackOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbtackOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root673();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1673();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbtackOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2673();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbtackOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbtackOutline = hmr(ThumbtackOutline, () => ThumbtackOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbtackOutline[HMR].source;
    set(ThumbtackOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbtackOutline_default = ThumbtackOutline;

// node_modules/flowbite-svelte-icons/dist/ThumbtackSolid.svelte
ThumbtackSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbtackSolid.svelte";
var root_1674 = add_locations(from_svg(`<title> </title>`), ThumbtackSolid[FILENAME], [[41, 4]]);
var root_2674 = add_locations(from_svg(`<desc> </desc>`), ThumbtackSolid[FILENAME], [[44, 4]]);
var root674 = add_locations(from_svg(`<svg><!><!><path d="M8 5v4.997a.31.31 0 0 1-.068.113c-.08.098-.213.207-.378.301-.947.543-1.713 1.54-2.191 2.488A6.237 6.237 0 0 0 4.82 14.4c-.1.48-.138 1.031.018 1.539C5.12 16.846 6.02 17 6.414 17H11v3a1 1 0 1 0 2 0v-3h4.586c.395 0 1.295-.154 1.575-1.061.156-.508.118-1.059.017-1.539a6.241 6.241 0 0 0-.541-1.5c-.479-.95-1.244-1.946-2.191-2.489a1.393 1.393 0 0 1-.378-.301.309.309 0 0 1-.068-.113V5h1a1 1 0 1 0 0-2H7a1 1 0 1 0 0 2h1Z"></path></svg>`), ThumbtackSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbtackSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ThumbtackSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root674();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1674();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ThumbtackSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2674();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ThumbtackSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ThumbtackSolid = hmr(ThumbtackSolid, () => ThumbtackSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbtackSolid[HMR].source;
    set(ThumbtackSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbtackSolid_default = ThumbtackSolid;

// node_modules/flowbite-svelte-icons/dist/TicketOutline.svelte
TicketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TicketOutline.svelte";
var root_1675 = add_locations(from_svg(`<title> </title>`), TicketOutline[FILENAME], [[43, 4]]);
var root_2675 = add_locations(from_svg(`<desc> </desc>`), TicketOutline[FILENAME], [[46, 4]]);
var root675 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5 12A2.5 2.5 0 0 1 21 9.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v2.5a2.5 2.5 0 0 1 0 5V17a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-2.5a2.5 2.5 0 0 1-2.5-2.5Z"></path></svg>`), TicketOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TicketOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TicketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root675();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1675();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TicketOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2675();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TicketOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TicketOutline = hmr(TicketOutline, () => TicketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TicketOutline[HMR].source;
    set(TicketOutline[HMR].source, module.default[HMR].original);
  });
}
var TicketOutline_default = TicketOutline;

// node_modules/flowbite-svelte-icons/dist/TicketSolid.svelte
TicketSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TicketSolid.svelte";
var root_1676 = add_locations(from_svg(`<title> </title>`), TicketSolid[FILENAME], [[41, 4]]);
var root_2676 = add_locations(from_svg(`<desc> </desc>`), TicketSolid[FILENAME], [[44, 4]]);
var root676 = add_locations(from_svg(`<svg><!><!><path d="M4 5a2 2 0 0 0-2 2v2.5a1 1 0 0 0 1 1 1.5 1.5 0 1 1 0 3 1 1 0 0 0-1 1V17a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2.5a1 1 0 0 0-1-1 1.5 1.5 0 1 1 0-3 1 1 0 0 0 1-1V7a2 2 0 0 0-2-2H4Z"></path></svg>`), TicketSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TicketSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TicketSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root676();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1676();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TicketSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2676();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TicketSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TicketSolid = hmr(TicketSolid, () => TicketSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TicketSolid[HMR].source;
    set(TicketSolid[HMR].source, module.default[HMR].original);
  });
}
var TicketSolid_default = TicketSolid;

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderCellOutline.svelte
ToggleHeaderCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderCellOutline.svelte";
var root_1677 = add_locations(from_svg(`<title> </title>`), ToggleHeaderCellOutline[FILENAME], [[43, 4]]);
var root_2677 = add_locations(from_svg(`<desc> </desc>`), ToggleHeaderCellOutline[FILENAME], [[46, 4]]);
var root677 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v3M3 11h11m-2-.2079V19m3-4h1.9909M21 15c0 1.1046-.8954 2-2 2s-2-.8954-2-2 .8954-2 2-2 2 .8954 2 2Z"></path></svg>`), ToggleHeaderCellOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ToggleHeaderCellOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ToggleHeaderCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root677();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1677();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ToggleHeaderCellOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2677();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ToggleHeaderCellOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ToggleHeaderCellOutline = hmr(ToggleHeaderCellOutline, () => ToggleHeaderCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderCellOutline[HMR].source;
    set(ToggleHeaderCellOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderCellOutline_default = ToggleHeaderCellOutline;

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderColumnOutline.svelte
ToggleHeaderColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderColumnOutline.svelte";
var root_1678 = add_locations(from_svg(`<title> </title>`), ToggleHeaderColumnOutline[FILENAME], [[43, 4]]);
var root_2678 = add_locations(from_svg(`<desc> </desc>`), ToggleHeaderColumnOutline[FILENAME], [[46, 4]]);
var root678 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14m6-8h-6m6 4h-6m-9-3h1.99093M4 19h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Zm8-7c0 1.1046-.8954 2-2 2-1.10457 0-2-.8954-2-2s.89543-2 2-2c1.1046 0 2 .8954 2 2Z"></path></svg>`), ToggleHeaderColumnOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ToggleHeaderColumnOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ToggleHeaderColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root678();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1678();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ToggleHeaderColumnOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2678();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ToggleHeaderColumnOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ToggleHeaderColumnOutline = hmr(ToggleHeaderColumnOutline, () => ToggleHeaderColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderColumnOutline[HMR].source;
    set(ToggleHeaderColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderColumnOutline_default = ToggleHeaderColumnOutline;

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderRowOutline.svelte
ToggleHeaderRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderRowOutline.svelte";
var root_1679 = add_locations(from_svg(`<title> </title>`), ToggleHeaderRowOutline[FILENAME], [[43, 4]]);
var root_2679 = add_locations(from_svg(`<desc> </desc>`), ToggleHeaderRowOutline[FILENAME], [[46, 4]]);
var root679 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-7-9h1.9909M15 10c0 1.1046-.8954 2-2 2s-2-.8954-2-2c0-1.10457.8954-2 2-2s2 .89543 2 2Z"></path></svg>`), ToggleHeaderRowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ToggleHeaderRowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ToggleHeaderRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root679();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1679();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ToggleHeaderRowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2679();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ToggleHeaderRowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ToggleHeaderRowOutline = hmr(ToggleHeaderRowOutline, () => ToggleHeaderRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderRowOutline[HMR].source;
    set(ToggleHeaderRowOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderRowOutline_default = ToggleHeaderRowOutline;

// node_modules/flowbite-svelte-icons/dist/ToolsOutline.svelte
ToolsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToolsOutline.svelte";
var root_1680 = add_locations(from_svg(`<title> </title>`), ToolsOutline[FILENAME], [[43, 4]]);
var root_2680 = add_locations(from_svg(`<desc> </desc>`), ToolsOutline[FILENAME], [[46, 4]]);
var root680 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M7.58209 8.96025 9.8136 11.1917l-1.61782 1.6178c-1.08305-.1811-2.23623.1454-3.07364.9828-1.1208 1.1208-1.32697 2.8069-.62368 4.1363.14842.2806.42122.474.73509.5213.06726.0101.1347.0133.20136.0098-.00351.0666-.00036.1341.00977.2013.04724.3139.24069.5867.52125.7351 1.32944.7033 3.01552.4971 4.13627-.6237.8375-.8374 1.1639-1.9906.9829-3.0736l4.8107-4.8108c1.0831.1811 2.2363-.1454 3.0737-.9828 1.1208-1.1208 1.3269-2.80688.6237-4.13632-.1485-.28056-.4213-.474-.7351-.52125-.0673-.01012-.1347-.01327-.2014-.00977.0035-.06666.0004-.13409-.0098-.20136-.0472-.31386-.2406-.58666-.5212-.73508-1.3294-.70329-3.0155-.49713-4.1363.62367-.8374.83741-1.1639 1.9906-.9828 3.07365l-1.7788 1.77875-2.23152-2.23148-1.41419 1.41424Zm1.31056-3.1394c-.04235-.32684-.24303-.61183-.53647-.76186l-1.98183-1.0133c-.38619-.19746-.85564-.12345-1.16234.18326l-.86321.8632c-.3067.3067-.38072.77616-.18326 1.16235l1.0133 1.98182c.15004.29345.43503.49412.76187.53647l1.1127.14418c.3076.03985.61628-.06528.8356-.28461l.86321-.8632c.21932-.21932.32446-.52801.2846-.83561l-.14417-1.1127ZM19.4448 16.4052l-3.1186-3.1187c-.7811-.781-2.0474-.781-2.8285 0l-.1719.172c-.7811.781-.7811 2.0474 0 2.8284l3.1186 3.1187c.7811.781 2.0474.781 2.8285 0l.1719-.172c.7811-.781.7811-2.0474 0-2.8284Z"></path></svg>`), ToolsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ToolsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ToolsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root680();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1680();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ToolsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2680();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ToolsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ToolsOutline = hmr(ToolsOutline, () => ToolsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolsOutline[HMR].source;
    set(ToolsOutline[HMR].source, module.default[HMR].original);
  });
}
var ToolsOutline_default = ToolsOutline;

// node_modules/flowbite-svelte-icons/dist/TrackingOutline.svelte
TrackingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrackingOutline.svelte";
var root_1681 = add_locations(from_svg(`<title> </title>`), TrackingOutline[FILENAME], [[43, 4]]);
var root_2681 = add_locations(from_svg(`<desc> </desc>`), TrackingOutline[FILENAME], [[46, 4]]);
var root681 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 19h4m6 0h4m-6.9627-4.3843V8.63418L17 5.93918m-4.9298 2.66213L7.04175 5.93919M12 2.99719l5.033 2.90583v5.81168L12 14.6205l-5.03303-2.9058V5.90302L12 2.99719ZM14 19c0 1.1045-.8954 2-2 2s-2-.8955-2-2c0-1.1046.8954-2 2-2s2 .8954 2 2Z"></path></svg>`), TrackingOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TrackingOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TrackingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root681();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1681();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TrackingOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2681();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TrackingOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TrackingOutline = hmr(TrackingOutline, () => TrackingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackingOutline[HMR].source;
    set(TrackingOutline[HMR].source, module.default[HMR].original);
  });
}
var TrackingOutline_default = TrackingOutline;

// node_modules/flowbite-svelte-icons/dist/TrackingSolid.svelte
TrackingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrackingSolid.svelte";
var root_1682 = add_locations(from_svg(`<title> </title>`), TrackingSolid[FILENAME], [[41, 4]]);
var root_2682 = add_locations(from_svg(`<desc> </desc>`), TrackingSolid[FILENAME], [[44, 4]]);
var root682 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9.166 19.986A.915.915 0 0 1 9 20H5a1 1 0 1 1 0-2h4c.057 0 .112.005.166.014a3.001 3.001 0 0 1 5.668 0A.915.915 0 0 1 15 18h4a1 1 0 1 1 0 2h-4c-.056 0-.112-.005-.166-.014a3.001 3.001 0 0 1-5.668 0ZM11 19a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z" clip-rule="evenodd"></path><path d="M11.5 2.131a1 1 0 0 1 1 0l4.601 2.657c-.06.018-.12.044-.179.075L12.08 7.475 6.946 4.76 11.5 2.131ZM5.967 6.505v5.21a1 1 0 0 0 .5.866l4.57 2.638V9.186l-5.07-2.681Zm7.07 8.671 4.496-2.595a1 1 0 0 0 .5-.866v-5.2a1 1 0 0 1-.161.108l-4.835 2.608v5.945Z"></path></svg>`), TrackingSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function TrackingSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TrackingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root682();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1682();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TrackingSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2682();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TrackingSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TrackingSolid = hmr(TrackingSolid, () => TrackingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackingSolid[HMR].source;
    set(TrackingSolid[HMR].source, module.default[HMR].original);
  });
}
var TrackingSolid_default = TrackingSolid;

// node_modules/flowbite-svelte-icons/dist/TrashBinOutline.svelte
TrashBinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrashBinOutline.svelte";
var root_1683 = add_locations(from_svg(`<title> </title>`), TrashBinOutline[FILENAME], [[43, 4]]);
var root_2683 = add_locations(from_svg(`<desc> </desc>`), TrashBinOutline[FILENAME], [[46, 4]]);
var root683 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 7h14m-9 3v8m4-8v8M10 3h4a1 1 0 0 1 1 1v3H9V4a1 1 0 0 1 1-1ZM6 7h12v13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V7Z"></path></svg>`), TrashBinOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TrashBinOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TrashBinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root683();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1683();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TrashBinOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2683();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TrashBinOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TrashBinOutline = hmr(TrashBinOutline, () => TrashBinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrashBinOutline[HMR].source;
    set(TrashBinOutline[HMR].source, module.default[HMR].original);
  });
}
var TrashBinOutline_default = TrashBinOutline;

// node_modules/flowbite-svelte-icons/dist/TrashBinSolid.svelte
TrashBinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrashBinSolid.svelte";
var root_1684 = add_locations(from_svg(`<title> </title>`), TrashBinSolid[FILENAME], [[41, 4]]);
var root_2684 = add_locations(from_svg(`<desc> </desc>`), TrashBinSolid[FILENAME], [[44, 4]]);
var root684 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.586 2.586A2 2 0 0 1 10 2h4a2 2 0 0 1 2 2v2h3a1 1 0 1 1 0 2v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V8a1 1 0 0 1 0-2h3V4a2 2 0 0 1 .586-1.414ZM10 6h4V4h-4v2Zm1 4a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Zm4 0a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Z" clip-rule="evenodd"></path></svg>`), TrashBinSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TrashBinSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TrashBinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root684();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1684();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TrashBinSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2684();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TrashBinSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TrashBinSolid = hmr(TrashBinSolid, () => TrashBinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrashBinSolid[HMR].source;
    set(TrashBinSolid[HMR].source, module.default[HMR].original);
  });
}
var TrashBinSolid_default = TrashBinSolid;

// node_modules/flowbite-svelte-icons/dist/TruckClockOutline.svelte
TruckClockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckClockOutline.svelte";
var root_1685 = add_locations(from_svg(`<title> </title>`), TruckClockOutline[FILENAME], [[43, 4]]);
var root_2685 = add_locations(from_svg(`<desc> </desc>`), TruckClockOutline[FILENAME], [[46, 4]]);
var root685 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 7h6l2 4m-8-4v8H9m4-8V6c0-.26522-.1054-.51957-.2929-.70711C12.5196 5.10536 12.2652 5 12 5H4c-.26522 0-.51957.10536-.70711.29289C3.10536 5.48043 3 5.73478 3 6v9h2m14 0h2v-4m0 0h-5M8 8.66669V10l1.5 1.5m10 5c0 1.3807-1.1193 2.5-2.5 2.5s-2.5-1.1193-2.5-2.5S15.6193 14 17 14s2.5 1.1193 2.5 2.5Zm-10 0C9.5 17.8807 8.38071 19 7 19s-2.5-1.1193-2.5-2.5S5.61929 14 7 14s2.5 1.1193 2.5 2.5Z"></path></svg>`), TruckClockOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TruckClockOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TruckClockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root685();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1685();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TruckClockOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2685();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TruckClockOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TruckClockOutline = hmr(TruckClockOutline, () => TruckClockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckClockOutline[HMR].source;
    set(TruckClockOutline[HMR].source, module.default[HMR].original);
  });
}
var TruckClockOutline_default = TruckClockOutline;

// node_modules/flowbite-svelte-icons/dist/TruckClockSolid.svelte
TruckClockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckClockSolid.svelte";
var root_1686 = add_locations(from_svg(`<title> </title>`), TruckClockSolid[FILENAME], [[41, 4]]);
var root_2686 = add_locations(from_svg(`<desc> </desc>`), TruckClockSolid[FILENAME], [[44, 4]]);
var root686 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M2.586 4.586A2 2 0 0 1 4 4h8a2 2 0 0 1 2 2h5a1 1 0 0 1 .894.553l2 4c.07.139.106.292.106.447v4a1 1 0 0 1-1 1h-.535a3.5 3.5 0 1 1-6.93 0h-3.07a3.5 3.5 0 1 1-6.93 0H3a1 1 0 0 1-1-1V6a2 2 0 0 1 .586-1.414ZM18.208 15.61a1.497 1.497 0 0 0-2.416 0 1.5 1.5 0 1 0 2.416 0Zm-10 0a1.498 1.498 0 0 0-2.416 0 1.5 1.5 0 1 0 2.416 0Zm5.79-7.612v2.02h5.396l-1-2.02h-4.396ZM9 8.667a1 1 0 1 0-2 0V10a1 1 0 0 0 .293.707l1.5 1.5a1 1 0 0 0 1.414-1.414L9 9.586v-.92Z" clip-rule="evenodd"></path></svg>`), TruckClockSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TruckClockSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TruckClockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root686();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1686();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TruckClockSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2686();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TruckClockSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TruckClockSolid = hmr(TruckClockSolid, () => TruckClockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckClockSolid[HMR].source;
    set(TruckClockSolid[HMR].source, module.default[HMR].original);
  });
}
var TruckClockSolid_default = TruckClockSolid;

// node_modules/flowbite-svelte-icons/dist/TruckOutline.svelte
TruckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckOutline.svelte";
var root_1687 = add_locations(from_svg(`<title> </title>`), TruckOutline[FILENAME], [[43, 4]]);
var root_2687 = add_locations(from_svg(`<desc> </desc>`), TruckOutline[FILENAME], [[46, 4]]);
var root687 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 7h6l2 4m-8-4v8m0-8V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v9h2m8 0H9m4 0h2m4 0h2v-4m0 0h-5m3.5 5.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm-10 0a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), TruckOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TruckOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TruckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root687();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1687();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TruckOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2687();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TruckOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TruckOutline = hmr(TruckOutline, () => TruckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckOutline[HMR].source;
    set(TruckOutline[HMR].source, module.default[HMR].original);
  });
}
var TruckOutline_default = TruckOutline;

// node_modules/flowbite-svelte-icons/dist/TruckSolid.svelte
TruckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckSolid.svelte";
var root_1688 = add_locations(from_svg(`<title> </title>`), TruckSolid[FILENAME], [[41, 4]]);
var root_2688 = add_locations(from_svg(`<desc> </desc>`), TruckSolid[FILENAME], [[44, 4]]);
var root688 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v9a1 1 0 0 0 1 1h.535a3.5 3.5 0 1 0 6.93 0h3.07a3.5 3.5 0 1 0 6.93 0H21a1 1 0 0 0 1-1v-4a.999.999 0 0 0-.106-.447l-2-4A1 1 0 0 0 19 6h-5a2 2 0 0 0-2-2H4Zm14.192 11.59.016.02a1.5 1.5 0 1 1-.016-.021Zm-10 0 .016.02a1.5 1.5 0 1 1-.016-.021Zm5.806-5.572v-2.02h4.396l1 2.02h-5.396Z" clip-rule="evenodd"></path></svg>`), TruckSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TruckSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TruckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root688();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1688();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TruckSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2688();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TruckSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TruckSolid = hmr(TruckSolid, () => TruckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckSolid[HMR].source;
    set(TruckSolid[HMR].source, module.default[HMR].original);
  });
}
var TruckSolid_default = TruckSolid;

// node_modules/flowbite-svelte-icons/dist/TShirtOutline.svelte
TShirtOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TShirtOutline.svelte";
var root_1689 = add_locations(from_svg(`<title> </title>`), TShirtOutline[FILENAME], [[43, 4]]);
var root_2689 = add_locations(from_svg(`<desc> </desc>`), TShirtOutline[FILENAME], [[46, 4]]);
var root689 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M9 5h-.16667c-.86548 0-1.70761.28071-2.4.8L3.5 8l2 3.5L8 10v9h8v-9l2.5 1.5 2-3.5-2.9333-2.2c-.6924-.51929-1.5346-.8-2.4-.8H15M9 5c0 1.5 1.5 3 3 3s3-1.5 3-3M9 5h6"></path></svg>`), TShirtOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function TShirtOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TShirtOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root689();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1689();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TShirtOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2689();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TShirtOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TShirtOutline = hmr(TShirtOutline, () => TShirtOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TShirtOutline[HMR].source;
    set(TShirtOutline[HMR].source, module.default[HMR].original);
  });
}
var TShirtOutline_default = TShirtOutline;

// node_modules/flowbite-svelte-icons/dist/TShirtSolid.svelte
TShirtSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TShirtSolid.svelte";
var root_1690 = add_locations(from_svg(`<title> </title>`), TShirtSolid[FILENAME], [[41, 4]]);
var root_2690 = add_locations(from_svg(`<desc> </desc>`), TShirtSolid[FILENAME], [[44, 4]]);
var root690 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5.833 5a5 5 0 0 1 3-1h6.334a5 5 0 0 1 3 1L21.1 7.2a1 1 0 0 1 .268 1.296l-2 3.5a1 1 0 0 1-1.382.361l-.986-.59V19a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-7.234l-.985.591a1 1 0 0 1-1.383-.36l-2-3.5A1 1 0 0 1 2.9 7.2L5.833 5ZM14 5h-4c0 .425.223.933.645 1.355.422.423.93.645 1.355.645.425 0 .933-.222 1.355-.645.423-.422.645-.93.645-1.355Z" clip-rule="evenodd"></path></svg>`), TShirtSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TShirtSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TShirtSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root690();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1690();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TShirtSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2690();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TShirtSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TShirtSolid = hmr(TShirtSolid, () => TShirtSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TShirtSolid[HMR].source;
    set(TShirtSolid[HMR].source, module.default[HMR].original);
  });
}
var TShirtSolid_default = TShirtSolid;

// node_modules/flowbite-svelte-icons/dist/TwitterSolid.svelte
TwitterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TwitterSolid.svelte";
var root_1691 = add_locations(from_svg(`<title> </title>`), TwitterSolid[FILENAME], [[41, 4]]);
var root_2691 = add_locations(from_svg(`<desc> </desc>`), TwitterSolid[FILENAME], [[44, 4]]);
var root691 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M22 5.892a8.178 8.178 0 0 1-2.355.635 4.074 4.074 0 0 0 1.8-2.235 8.343 8.343 0 0 1-2.605.981A4.13 4.13 0 0 0 15.85 4a4.068 4.068 0 0 0-4.1 4.038c0 .31.035.618.105.919A11.705 11.705 0 0 1 3.4 4.734a4.006 4.006 0 0 0 1.268 5.392 4.165 4.165 0 0 1-1.859-.5v.05A4.057 4.057 0 0 0 6.1 13.635a4.192 4.192 0 0 1-1.856.07 4.108 4.108 0 0 0 3.831 2.807A8.36 8.36 0 0 1 2 18.184 11.732 11.732 0 0 0 8.291 20 11.502 11.502 0 0 0 19.964 8.5c0-.177 0-.349-.012-.523A8.143 8.143 0 0 0 22 5.892Z" clip-rule="evenodd"></path></svg>`), TwitterSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function TwitterSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, TwitterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root691();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1691();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      TwitterSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2691();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      TwitterSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  TwitterSolid = hmr(TwitterSolid, () => TwitterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TwitterSolid[HMR].source;
    set(TwitterSolid[HMR].source, module.default[HMR].original);
  });
}
var TwitterSolid_default = TwitterSolid;

// node_modules/flowbite-svelte-icons/dist/UndoOutline.svelte
UndoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UndoOutline.svelte";
var root_1692 = add_locations(from_svg(`<title> </title>`), UndoOutline[FILENAME], [[43, 4]]);
var root_2692 = add_locations(from_svg(`<desc> </desc>`), UndoOutline[FILENAME], [[46, 4]]);
var root692 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 9h13a5 5 0 0 1 0 10H7M3 9l4-4M3 9l4 4"></path></svg>`), UndoOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UndoOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UndoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root692();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1692();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UndoOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2692();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UndoOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UndoOutline = hmr(UndoOutline, () => UndoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UndoOutline[HMR].source;
    set(UndoOutline[HMR].source, module.default[HMR].original);
  });
}
var UndoOutline_default = UndoOutline;

// node_modules/flowbite-svelte-icons/dist/UploadOutline.svelte
UploadOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UploadOutline.svelte";
var root_1693 = add_locations(from_svg(`<title> </title>`), UploadOutline[FILENAME], [[43, 4]]);
var root_2693 = add_locations(from_svg(`<desc> </desc>`), UploadOutline[FILENAME], [[46, 4]]);
var root693 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5v9m-5 0H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-2M8 9l4-5 4 5m1 8h.01"></path></svg>`), UploadOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UploadOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UploadOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root693();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1693();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UploadOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2693();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UploadOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UploadOutline = hmr(UploadOutline, () => UploadOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UploadOutline[HMR].source;
    set(UploadOutline[HMR].source, module.default[HMR].original);
  });
}
var UploadOutline_default = UploadOutline;

// node_modules/flowbite-svelte-icons/dist/UploadSolid.svelte
UploadSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UploadSolid.svelte";
var root_1694 = add_locations(from_svg(`<title> </title>`), UploadSolid[FILENAME], [[41, 4]]);
var root_2694 = add_locations(from_svg(`<desc> </desc>`), UploadSolid[FILENAME], [[44, 4]]);
var root694 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 3a1 1 0 0 1 .78.375l4 5a1 1 0 1 1-1.56 1.25L13 6.85V14a1 1 0 1 1-2 0V6.85L8.78 9.626a1 1 0 1 1-1.56-1.25l4-5A1 1 0 0 1 12 3ZM9 14v-1H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-4v1a3 3 0 1 1-6 0Zm8 2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), UploadSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UploadSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UploadSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root694();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1694();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UploadSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2694();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UploadSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UploadSolid = hmr(UploadSolid, () => UploadSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UploadSolid[HMR].source;
    set(UploadSolid[HMR].source, module.default[HMR].original);
  });
}
var UploadSolid_default = UploadSolid;

// node_modules/flowbite-svelte-icons/dist/UserAddOutline.svelte
UserAddOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserAddOutline.svelte";
var root_1695 = add_locations(from_svg(`<title> </title>`), UserAddOutline[FILENAME], [[43, 4]]);
var root_2695 = add_locations(from_svg(`<desc> </desc>`), UserAddOutline[FILENAME], [[46, 4]]);
var root695 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12h4m-2 2v-4M4 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserAddOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserAddOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserAddOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root695();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1695();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserAddOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2695();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserAddOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserAddOutline = hmr(UserAddOutline, () => UserAddOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserAddOutline[HMR].source;
    set(UserAddOutline[HMR].source, module.default[HMR].original);
  });
}
var UserAddOutline_default = UserAddOutline;

// node_modules/flowbite-svelte-icons/dist/UserAddSolid.svelte
UserAddSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserAddSolid.svelte";
var root_1696 = add_locations(from_svg(`<title> </title>`), UserAddSolid[FILENAME], [[41, 4]]);
var root_2696 = add_locations(from_svg(`<desc> </desc>`), UserAddSolid[FILENAME], [[44, 4]]);
var root696 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4H7Zm8-1a1 1 0 0 1 1-1h1v-1a1 1 0 1 1 2 0v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), UserAddSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserAddSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserAddSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root696();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1696();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserAddSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2696();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserAddSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserAddSolid = hmr(UserAddSolid, () => UserAddSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserAddSolid[HMR].source;
    set(UserAddSolid[HMR].source, module.default[HMR].original);
  });
}
var UserAddSolid_default = UserAddSolid;

// node_modules/flowbite-svelte-icons/dist/UserCircleOutline.svelte
UserCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserCircleOutline.svelte";
var root_1697 = add_locations(from_svg(`<title> </title>`), UserCircleOutline[FILENAME], [[43, 4]]);
var root_2697 = add_locations(from_svg(`<desc> </desc>`), UserCircleOutline[FILENAME], [[46, 4]]);
var root697 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Zm0 0a8.949 8.949 0 0 0 4.951-1.488A3.987 3.987 0 0 0 13 16h-2a3.987 3.987 0 0 0-3.951 3.512A8.948 8.948 0 0 0 12 21Zm3-11a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserCircleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserCircleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root697();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1697();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserCircleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2697();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserCircleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserCircleOutline = hmr(UserCircleOutline, () => UserCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserCircleOutline[HMR].source;
    set(UserCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var UserCircleOutline_default = UserCircleOutline;

// node_modules/flowbite-svelte-icons/dist/UserCircleSolid.svelte
UserCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserCircleSolid.svelte";
var root_1698 = add_locations(from_svg(`<title> </title>`), UserCircleSolid[FILENAME], [[41, 4]]);
var root_2698 = add_locations(from_svg(`<desc> </desc>`), UserCircleSolid[FILENAME], [[44, 4]]);
var root698 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 20a7.966 7.966 0 0 1-5.002-1.756l.002.001v-.683c0-1.794 1.492-3.25 3.333-3.25h3.334c1.84 0 3.333 1.456 3.333 3.25v.683A7.966 7.966 0 0 1 12 20ZM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10c0 5.5-4.44 9.963-9.932 10h-.138C6.438 21.962 2 17.5 2 12Zm10-5c-1.84 0-3.333 1.455-3.333 3.25S10.159 13.5 12 13.5c1.84 0 3.333-1.455 3.333-3.25S13.841 7 12 7Z" clip-rule="evenodd"></path></svg>`), UserCircleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserCircleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root698();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1698();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserCircleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2698();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserCircleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserCircleSolid = hmr(UserCircleSolid, () => UserCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserCircleSolid[HMR].source;
    set(UserCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var UserCircleSolid_default = UserCircleSolid;

// node_modules/flowbite-svelte-icons/dist/UserEditOutline.svelte
UserEditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserEditOutline.svelte";
var root_1699 = add_locations(from_svg(`<title> </title>`), UserEditOutline[FILENAME], [[43, 4]]);
var root_2699 = add_locations(from_svg(`<desc> </desc>`), UserEditOutline[FILENAME], [[46, 4]]);
var root699 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M7 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h1m4-6a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm7.441 1.559a1.907 1.907 0 0 1 0 2.698l-6.069 6.069L10 19l.674-3.372 6.07-6.07a1.907 1.907 0 0 1 2.697 0Z"></path></svg>`), UserEditOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserEditOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserEditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root699();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1699();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserEditOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2699();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserEditOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserEditOutline = hmr(UserEditOutline, () => UserEditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserEditOutline[HMR].source;
    set(UserEditOutline[HMR].source, module.default[HMR].original);
  });
}
var UserEditOutline_default = UserEditOutline;

// node_modules/flowbite-svelte-icons/dist/UserEditSolid.svelte
UserEditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserEditSolid.svelte";
var root_1700 = add_locations(from_svg(`<title> </title>`), UserEditSolid[FILENAME], [[41, 4]]);
var root_2700 = add_locations(from_svg(`<desc> </desc>`), UserEditSolid[FILENAME], [[44, 4]]);
var root700 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 8a4 4 0 1 1 7.796 1.263l-2.533 2.534A4 4 0 0 1 5 8Zm4.06 5H7a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h2.172a2.999 2.999 0 0 1-.114-1.588l.674-3.372a3 3 0 0 1 .82-1.533L9.06 13Zm9.032-5a2.907 2.907 0 0 0-2.056.852L9.967 14.92a1 1 0 0 0-.273.51l-.675 3.373a1 1 0 0 0 1.177 1.177l3.372-.675a1 1 0 0 0 .511-.273l6.07-6.07a2.91 2.91 0 0 0-.944-4.742A2.907 2.907 0 0 0 18.092 8Z" clip-rule="evenodd"></path></svg>`), UserEditSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserEditSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserEditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root700();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1700();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserEditSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2700();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserEditSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserEditSolid = hmr(UserEditSolid, () => UserEditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserEditSolid[HMR].source;
    set(UserEditSolid[HMR].source, module.default[HMR].original);
  });
}
var UserEditSolid_default = UserEditSolid;

// node_modules/flowbite-svelte-icons/dist/UserGraduateOutline.svelte
UserGraduateOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserGraduateOutline.svelte";
var root_1701 = add_locations(from_svg(`<title> </title>`), UserGraduateOutline[FILENAME], [[43, 4]]);
var root_2701 = add_locations(from_svg(`<desc> </desc>`), UserGraduateOutline[FILENAME], [[46, 4]]);
var root701 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.6144 7.19994c.3479.48981.5999 1.15357.5999 1.80006 0 1.6569-1.3432 3-3 3-1.6569 0-3.00004-1.3431-3.00004-3 0-.67539.22319-1.29865.59983-1.80006M6.21426 6v4m0-4 6.00004-3 6 3-6 2-2.40021-.80006M6.21426 6l3.59983 1.19994M6.21426 19.8013v-2.1525c0-1.6825 1.27251-3.3075 2.95093-3.6488l3.04911 2.9345 3-2.9441c1.7026.3193 3 1.9596 3 3.6584v2.1525c0 .6312-.5373 1.1429-1.2 1.1429H7.41426c-.66274 0-1.2-.5117-1.2-1.1429Z"></path></svg>`), UserGraduateOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserGraduateOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserGraduateOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root701();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1701();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserGraduateOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2701();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserGraduateOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserGraduateOutline = hmr(UserGraduateOutline, () => UserGraduateOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserGraduateOutline[HMR].source;
    set(UserGraduateOutline[HMR].source, module.default[HMR].original);
  });
}
var UserGraduateOutline_default = UserGraduateOutline;

// node_modules/flowbite-svelte-icons/dist/UserGraduateSolid.svelte
UserGraduateSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserGraduateSolid.svelte";
var root_1702 = add_locations(from_svg(`<title> </title>`), UserGraduateSolid[FILENAME], [[41, 4]]);
var root_2702 = add_locations(from_svg(`<desc> </desc>`), UserGraduateSolid[FILENAME], [[44, 4]]);
var root702 = add_locations(from_svg(`<svg><!><!><path d="M12.4472 2.10557c-.2815-.14076-.6129-.14076-.8944 0L5.90482 4.92956l.37762.11119c.01131.00333.02257.00687.03376.0106L12 6.94594l5.6808-1.89361.3927-.13363-5.6263-2.81313ZM5 10V6.74803l.70053.20628L7 7.38747V10c0 .5523-.44772 1-1 1s-1-.4477-1-1Zm3-1c0-.42413.06601-.83285.18832-1.21643l3.49538 1.16514c.2053.06842.4272.06842.6325 0l3.4955-1.16514C15.934 8.16715 16 8.57587 16 9c0 2.2091-1.7909 4-4 4-2.20914 0-4-1.7909-4-4Z"></path><path d="M14.2996 13.2767c.2332-.2289.5636-.3294.8847-.2692C17.379 13.4191 19 15.4884 19 17.6488v2.1525c0 1.2289-1.0315 2.1428-2.2 2.1428H7.2c-1.16849 0-2.2-.9139-2.2-2.1428v-2.1525c0-2.1409 1.59079-4.1893 3.75163-4.6288.32214-.0655.65589.0315.89274.2595l2.34883 2.2606 2.3064-2.2634Z"></path></svg>`), UserGraduateSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function UserGraduateSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserGraduateSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root702();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1702();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserGraduateSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2702();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserGraduateSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserGraduateSolid = hmr(UserGraduateSolid, () => UserGraduateSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserGraduateSolid[HMR].source;
    set(UserGraduateSolid[HMR].source, module.default[HMR].original);
  });
}
var UserGraduateSolid_default = UserGraduateSolid;

// node_modules/flowbite-svelte-icons/dist/UserHeadsetOutline.svelte
UserHeadsetOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserHeadsetOutline.svelte";
var root_1703 = add_locations(from_svg(`<title> </title>`), UserHeadsetOutline[FILENAME], [[43, 4]]);
var root_2703 = add_locations(from_svg(`<desc> </desc>`), UserHeadsetOutline[FILENAME], [[46, 4]]);
var root703 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.079 6.839a3 3 0 0 0-4.255.1M13 20h1.083A3.916 3.916 0 0 0 18 16.083V9A6 6 0 1 0 6 9v7m7 4v-1a1 1 0 0 0-1-1h-1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1Zm-7-4v-6H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1Zm12-6h1a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-1v-6Z"></path></svg>`), UserHeadsetOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserHeadsetOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserHeadsetOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root703();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1703();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserHeadsetOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2703();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserHeadsetOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserHeadsetOutline = hmr(UserHeadsetOutline, () => UserHeadsetOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserHeadsetOutline[HMR].source;
    set(UserHeadsetOutline[HMR].source, module.default[HMR].original);
  });
}
var UserHeadsetOutline_default = UserHeadsetOutline;

// node_modules/flowbite-svelte-icons/dist/UserHeadsetSolid.svelte
UserHeadsetSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserHeadsetSolid.svelte";
var root_1704 = add_locations(from_svg(`<title> </title>`), UserHeadsetSolid[FILENAME], [[41, 4]]);
var root_2704 = add_locations(from_svg(`<desc> </desc>`), UserHeadsetSolid[FILENAME], [[44, 4]]);
var root704 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 2a7 7 0 0 0-7 7 3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1a1 1 0 0 0 1-1V9a5 5 0 1 1 10 0v7.083A2.919 2.919 0 0 1 14.083 19H14a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h1a2 2 0 0 0 1.732-1h.351a4.917 4.917 0 0 0 4.83-4H19a3 3 0 0 0 3-3v-2a3 3 0 0 0-3-3 7 7 0 0 0-7-7Zm1.45 3.275a4 4 0 0 0-4.352.976 1 1 0 0 0 1.452 1.376 2.001 2.001 0 0 1 2.836-.067 1 1 0 1 0 1.386-1.442 4 4 0 0 0-1.321-.843Z" clip-rule="evenodd"></path></svg>`), UserHeadsetSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserHeadsetSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserHeadsetSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root704();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1704();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserHeadsetSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2704();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserHeadsetSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserHeadsetSolid = hmr(UserHeadsetSolid, () => UserHeadsetSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserHeadsetSolid[HMR].source;
    set(UserHeadsetSolid[HMR].source, module.default[HMR].original);
  });
}
var UserHeadsetSolid_default = UserHeadsetSolid;

// node_modules/flowbite-svelte-icons/dist/UserOutline.svelte
UserOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserOutline.svelte";
var root_1705 = add_locations(from_svg(`<title> </title>`), UserOutline[FILENAME], [[43, 4]]);
var root_2705 = add_locations(from_svg(`<desc> </desc>`), UserOutline[FILENAME], [[46, 4]]);
var root705 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" d="M7 17v1a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1a3 3 0 0 0-3-3h-4a3 3 0 0 0-3 3Zm8-9a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root705();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1705();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2705();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserOutline = hmr(UserOutline, () => UserOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserOutline[HMR].source;
    set(UserOutline[HMR].source, module.default[HMR].original);
  });
}
var UserOutline_default = UserOutline;

// node_modules/flowbite-svelte-icons/dist/UserRemoveOutline.svelte
UserRemoveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserRemoveOutline.svelte";
var root_1706 = add_locations(from_svg(`<title> </title>`), UserRemoveOutline[FILENAME], [[43, 4]]);
var root_2706 = add_locations(from_svg(`<desc> </desc>`), UserRemoveOutline[FILENAME], [[46, 4]]);
var root706 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12h4M4 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserRemoveOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserRemoveOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserRemoveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root706();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1706();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserRemoveOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2706();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserRemoveOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserRemoveOutline = hmr(UserRemoveOutline, () => UserRemoveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserRemoveOutline[HMR].source;
    set(UserRemoveOutline[HMR].source, module.default[HMR].original);
  });
}
var UserRemoveOutline_default = UserRemoveOutline;

// node_modules/flowbite-svelte-icons/dist/UserRemoveSolid.svelte
UserRemoveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserRemoveSolid.svelte";
var root_1707 = add_locations(from_svg(`<title> </title>`), UserRemoveSolid[FILENAME], [[41, 4]]);
var root_2707 = add_locations(from_svg(`<desc> </desc>`), UserRemoveSolid[FILENAME], [[44, 4]]);
var root707 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M5 8a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm-2 9a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1Zm13-6a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-4Z" clip-rule="evenodd"></path></svg>`), UserRemoveSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserRemoveSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserRemoveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root707();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1707();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserRemoveSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2707();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserRemoveSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserRemoveSolid = hmr(UserRemoveSolid, () => UserRemoveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserRemoveSolid[HMR].source;
    set(UserRemoveSolid[HMR].source, module.default[HMR].original);
  });
}
var UserRemoveSolid_default = UserRemoveSolid;

// node_modules/flowbite-svelte-icons/dist/UserSettingsOutline.svelte
UserSettingsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSettingsOutline.svelte";
var root_1708 = add_locations(from_svg(`<title> </title>`), UserSettingsOutline[FILENAME], [[43, 4]]);
var root_2708 = add_locations(from_svg(`<desc> </desc>`), UserSettingsOutline[FILENAME], [[46, 4]]);
var root708 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M10 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h2m10 1a3 3 0 0 1-3 3m3-3a3 3 0 0 0-3-3m3 3h1m-4 3a3 3 0 0 1-3-3m3 3v1m-3-4a3 3 0 0 1 3-3m-3 3h-1m4-3v-1m-2.121 1.879-.707-.707m5.656 5.656-.707-.707m-4.242 0-.707.707m5.656-5.656-.707.707M12 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserSettingsOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UserSettingsOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserSettingsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root708();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1708();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserSettingsOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2708();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserSettingsOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserSettingsOutline = hmr(UserSettingsOutline, () => UserSettingsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSettingsOutline[HMR].source;
    set(UserSettingsOutline[HMR].source, module.default[HMR].original);
  });
}
var UserSettingsOutline_default = UserSettingsOutline;

// node_modules/flowbite-svelte-icons/dist/UserSettingsSolid.svelte
UserSettingsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSettingsSolid.svelte";
var root_1709 = add_locations(from_svg(`<title> </title>`), UserSettingsSolid[FILENAME], [[41, 4]]);
var root_2709 = add_locations(from_svg(`<desc> </desc>`), UserSettingsSolid[FILENAME], [[44, 4]]);
var root709 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17 10v1.126c.367.095.714.24 1.032.428l.796-.797 1.415 1.415-.797.796c.188.318.333.665.428 1.032H21v2h-1.126c-.095.367-.24.714-.428 1.032l.797.796-1.415 1.415-.796-.797a3.979 3.979 0 0 1-1.032.428V20h-2v-1.126a3.977 3.977 0 0 1-1.032-.428l-.796.797-1.415-1.415.797-.796A3.975 3.975 0 0 1 12.126 16H11v-2h1.126c.095-.367.24-.714.428-1.032l-.797-.796 1.415-1.415.796.797A3.977 3.977 0 0 1 15 11.126V10h2Zm.406 3.578.016.016c.354.358.574.85.578 1.392v.028a2 2 0 0 1-3.409 1.406l-.01-.012a2 2 0 0 1 2.826-2.83ZM5 8a4 4 0 1 1 7.938.703 7.029 7.029 0 0 0-3.235 3.235A4 4 0 0 1 5 8Zm4.29 5H7a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h6.101A6.979 6.979 0 0 1 9 15c0-.695.101-1.366.29-2Z" clip-rule="evenodd"></path></svg>`), UserSettingsSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserSettingsSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserSettingsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root709();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1709();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserSettingsSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2709();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserSettingsSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserSettingsSolid = hmr(UserSettingsSolid, () => UserSettingsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSettingsSolid[HMR].source;
    set(UserSettingsSolid[HMR].source, module.default[HMR].original);
  });
}
var UserSettingsSolid_default = UserSettingsSolid;

// node_modules/flowbite-svelte-icons/dist/UsersGroupOutline.svelte
UsersGroupOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersGroupOutline.svelte";
var root_1710 = add_locations(from_svg(`<title> </title>`), UsersGroupOutline[FILENAME], [[43, 4]]);
var root_2710 = add_locations(from_svg(`<desc> </desc>`), UsersGroupOutline[FILENAME], [[46, 4]]);
var root710 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M4.5 17H4a1 1 0 0 1-1-1 3 3 0 0 1 3-3h1m0-3.05A2.5 2.5 0 1 1 9 5.5M19.5 17h.5a1 1 0 0 0 1-1 3 3 0 0 0-3-3h-1m0-3.05a2.5 2.5 0 1 0-2-4.45m.5 13.5h-7a1 1 0 0 1-1-1 3 3 0 0 1 3-3h3a3 3 0 0 1 3 3 1 1 0 0 1-1 1Zm-1-9.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), UsersGroupOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UsersGroupOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UsersGroupOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root710();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1710();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UsersGroupOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2710();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UsersGroupOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UsersGroupOutline = hmr(UsersGroupOutline, () => UsersGroupOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersGroupOutline[HMR].source;
    set(UsersGroupOutline[HMR].source, module.default[HMR].original);
  });
}
var UsersGroupOutline_default = UsersGroupOutline;

// node_modules/flowbite-svelte-icons/dist/UsersGroupSolid.svelte
UsersGroupSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersGroupSolid.svelte";
var root_1711 = add_locations(from_svg(`<title> </title>`), UsersGroupSolid[FILENAME], [[41, 4]]);
var root_2711 = add_locations(from_svg(`<desc> </desc>`), UsersGroupSolid[FILENAME], [[44, 4]]);
var root711 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 6a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7Zm-1.5 8a4 4 0 0 0-4 4 2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 4 4 0 0 0-4-4h-3Zm6.82-3.096a5.51 5.51 0 0 0-2.797-6.293 3.5 3.5 0 1 1 2.796 6.292ZM19.5 18h.5a2 2 0 0 0 2-2 4 4 0 0 0-4-4h-1.1a5.503 5.503 0 0 1-.471.762A5.998 5.998 0 0 1 19.5 18ZM4 7.5a3.5 3.5 0 0 1 5.477-2.889 5.5 5.5 0 0 0-2.796 6.293A3.501 3.501 0 0 1 4 7.5ZM7.1 12H6a4 4 0 0 0-4 4 2 2 0 0 0 2 2h.5a5.998 5.998 0 0 1 3.071-5.238A5.505 5.505 0 0 1 7.1 12Z" clip-rule="evenodd"></path></svg>`), UsersGroupSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UsersGroupSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UsersGroupSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root711();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1711();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UsersGroupSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2711();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UsersGroupSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UsersGroupSolid = hmr(UsersGroupSolid, () => UsersGroupSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersGroupSolid[HMR].source;
    set(UsersGroupSolid[HMR].source, module.default[HMR].original);
  });
}
var UsersGroupSolid_default = UsersGroupSolid;

// node_modules/flowbite-svelte-icons/dist/UserSolid.svelte
UserSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSolid.svelte";
var root_1712 = add_locations(from_svg(`<title> </title>`), UserSolid[FILENAME], [[41, 4]]);
var root_2712 = add_locations(from_svg(`<desc> </desc>`), UserSolid[FILENAME], [[44, 4]]);
var root712 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4h-4Z" clip-rule="evenodd"></path></svg>`), UserSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UserSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UserSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root712();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1712();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UserSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2712();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UserSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UserSolid = hmr(UserSolid, () => UserSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSolid[HMR].source;
    set(UserSolid[HMR].source, module.default[HMR].original);
  });
}
var UserSolid_default = UserSolid;

// node_modules/flowbite-svelte-icons/dist/UsersOutline.svelte
UsersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersOutline.svelte";
var root_1713 = add_locations(from_svg(`<title> </title>`), UsersOutline[FILENAME], [[43, 4]]);
var root_2713 = add_locations(from_svg(`<desc> </desc>`), UsersOutline[FILENAME], [[46, 4]]);
var root713 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M16 19h4a1 1 0 0 0 1-1v-1a3 3 0 0 0-3-3h-2m-2.236-4a3 3 0 1 0 0-4M3 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UsersOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function UsersOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UsersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root713();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1713();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UsersOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2713();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UsersOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UsersOutline = hmr(UsersOutline, () => UsersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersOutline[HMR].source;
    set(UsersOutline[HMR].source, module.default[HMR].original);
  });
}
var UsersOutline_default = UsersOutline;

// node_modules/flowbite-svelte-icons/dist/UsersSolid.svelte
UsersSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersSolid.svelte";
var root_1714 = add_locations(from_svg(`<title> </title>`), UsersSolid[FILENAME], [[41, 4]]);
var root_2714 = add_locations(from_svg(`<desc> </desc>`), UsersSolid[FILENAME], [[44, 4]]);
var root714 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4H6Zm7.25-2.095c.478-.86.75-1.85.75-2.905a5.973 5.973 0 0 0-.75-2.906 4 4 0 1 1 0 5.811ZM15.466 20c.34-.588.535-1.271.535-2v-1a5.978 5.978 0 0 0-1.528-4H18a4 4 0 0 1 4 4v1a2 2 0 0 1-2 2h-4.535Z" clip-rule="evenodd"></path></svg>`), UsersSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function UsersSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, UsersSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root714();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1714();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      UsersSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2714();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      UsersSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  UsersSolid = hmr(UsersSolid, () => UsersSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersSolid[HMR].source;
    set(UsersSolid[HMR].source, module.default[HMR].original);
  });
}
var UsersSolid_default = UsersSolid;

// node_modules/flowbite-svelte-icons/dist/VideoCameraOutline.svelte
VideoCameraOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VideoCameraOutline.svelte";
var root_1715 = add_locations(from_svg(`<title> </title>`), VideoCameraOutline[FILENAME], [[43, 4]]);
var root_2715 = add_locations(from_svg(`<desc> </desc>`), VideoCameraOutline[FILENAME], [[46, 4]]);
var root715 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm7 11-6-2V9l6-2v10Z"></path></svg>`), VideoCameraOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function VideoCameraOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VideoCameraOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root715();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1715();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VideoCameraOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2715();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VideoCameraOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VideoCameraOutline = hmr(VideoCameraOutline, () => VideoCameraOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VideoCameraOutline[HMR].source;
    set(VideoCameraOutline[HMR].source, module.default[HMR].original);
  });
}
var VideoCameraOutline_default = VideoCameraOutline;

// node_modules/flowbite-svelte-icons/dist/VideoCameraSolid.svelte
VideoCameraSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VideoCameraSolid.svelte";
var root_1716 = add_locations(from_svg(`<title> </title>`), VideoCameraSolid[FILENAME], [[41, 4]]);
var root_2716 = add_locations(from_svg(`<desc> </desc>`), VideoCameraSolid[FILENAME], [[44, 4]]);
var root716 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M14 7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7Zm2 9.387 4.684 1.562A1 1 0 0 0 22 17V7a1 1 0 0 0-1.316-.949L16 7.613v8.774Z" clip-rule="evenodd"></path></svg>`), VideoCameraSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function VideoCameraSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VideoCameraSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root716();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1716();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VideoCameraSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2716();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VideoCameraSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VideoCameraSolid = hmr(VideoCameraSolid, () => VideoCameraSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VideoCameraSolid[HMR].source;
    set(VideoCameraSolid[HMR].source, module.default[HMR].original);
  });
}
var VideoCameraSolid_default = VideoCameraSolid;

// node_modules/flowbite-svelte-icons/dist/VisaSolid.svelte
VisaSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VisaSolid.svelte";
var root_1717 = add_locations(from_svg(`<title> </title>`), VisaSolid[FILENAME], [[41, 4]]);
var root_2717 = add_locations(from_svg(`<desc> </desc>`), VisaSolid[FILENAME], [[44, 4]]);
var root717 = add_locations(from_svg(`<svg><!><!><path fill="none" d="M17.4 12.6h1l-.3-1.4v-.4l-.2.4-.5 1.4Z"></path><path fill-rule="evenodd" d="M2 6.3c0-1.1.9-2 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-12Zm12.5 3.2c.4 0 .8 0 1.1.2l-.1 1h-.1a2 2 0 0 0-1-.3c-.5 0-.7.3-.7.5s.2.3.7.5c.7.4 1 .8 1 1.3 0 1-.8 1.7-2.2 1.7-.6 0-1.1-.2-1.4-.3l.2-1h.1c.4.2.7.3 1.2.3.4 0 .8-.2.8-.5 0-.2-.2-.3-.7-.6-.5-.2-1.1-.6-1.1-1.3 0-.9 1-1.5 2.2-1.5Zm3.5 0h1l1 4.8h-1.2l-.2-.7H17l-.3.7h-1.3l1.9-4.4c.1-.3.3-.3.7-.3Zm-6.2 0h-1.3l-.8 4.8H11l.8-4.8Zm-4.5 3.3-.1-.7-.5-2.2c0-.3-.3-.3-.6-.4h-2v.1l1.2.5.1.2 1.1 4H8l2-4.7H8.7l-1.3 3.2Z" clip-rule="evenodd"></path></svg>`), VisaSolid[FILENAME], [[30, 0, [[46, 2], [47, 2]]]]);
function VisaSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VisaSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root717();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1717();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VisaSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2717();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VisaSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VisaSolid = hmr(VisaSolid, () => VisaSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VisaSolid[HMR].source;
    set(VisaSolid[HMR].source, module.default[HMR].original);
  });
}
var VisaSolid_default = VisaSolid;

// node_modules/flowbite-svelte-icons/dist/VolumeDownOutline.svelte
VolumeDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeDownOutline.svelte";
var root_1718 = add_locations(from_svg(`<title> </title>`), VolumeDownOutline[FILENAME], [[43, 4]]);
var root_2718 = add_locations(from_svg(`<desc> </desc>`), VolumeDownOutline[FILENAME], [[46, 4]]);
var root718 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.5 8.43A4.985 4.985 0 0 1 19 12a4.984 4.984 0 0 1-1.43 3.5M14 6.135v11.73a1 1 0 0 1-1.64.768L8 15H6a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"></path></svg>`), VolumeDownOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function VolumeDownOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root718();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1718();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeDownOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2718();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeDownOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeDownOutline = hmr(VolumeDownOutline, () => VolumeDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeDownOutline[HMR].source;
    set(VolumeDownOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeDownOutline_default = VolumeDownOutline;

// node_modules/flowbite-svelte-icons/dist/VolumeDownSolid.svelte
VolumeDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeDownSolid.svelte";
var root_1719 = add_locations(from_svg(`<title> </title>`), VolumeDownSolid[FILENAME], [[41, 4]]);
var root_2719 = add_locations(from_svg(`<desc> </desc>`), VolumeDownSolid[FILENAME], [[44, 4]]);
var root719 = add_locations(from_svg(`<svg><!><!><path d="M15 6.037c0-1.724-1.978-2.665-3.28-1.562L7.638 7.933H6c-1.105 0-2 .91-2 2.034v4.066c0 1.123.895 2.034 2 2.034h1.638l4.082 3.458c1.302 1.104 3.28.162 3.28-1.562V6.037Z"></path><path fill-rule="evenodd" d="M16.786 7.658a.988.988 0 0 1 1.414-.014A6.135 6.135 0 0 1 20 12c0 1.662-.655 3.17-1.715 4.27a.989.989 0 0 1-1.414.014 1.029 1.029 0 0 1-.014-1.437A4.085 4.085 0 0 0 18 12a4.085 4.085 0 0 0-1.2-2.904 1.029 1.029 0 0 1-.014-1.438Z" clip-rule="evenodd"></path></svg>`), VolumeDownSolid[FILENAME], [[30, 0, [[46, 2], [49, 2]]]]);
function VolumeDownSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root719();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1719();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeDownSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2719();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeDownSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeDownSolid = hmr(VolumeDownSolid, () => VolumeDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeDownSolid[HMR].source;
    set(VolumeDownSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeDownSolid_default = VolumeDownSolid;

// node_modules/flowbite-svelte-icons/dist/VolumeMuteOutline.svelte
VolumeMuteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeMuteOutline.svelte";
var root_1720 = add_locations(from_svg(`<title> </title>`), VolumeMuteOutline[FILENAME], [[43, 4]]);
var root_2720 = add_locations(from_svg(`<desc> </desc>`), VolumeMuteOutline[FILENAME], [[46, 4]]);
var root720 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.5 8.43A4.985 4.985 0 0 1 17 12c0 1.126-.5 2.5-1.5 3.5m2.864-9.864A8.972 8.972 0 0 1 21 12c0 2.023-.5 4.5-2.5 6M7.8 7.5l2.56-2.133a1 1 0 0 1 1.64.768V12m0 4.5v1.365a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m1-4 14 14"></path></svg>`), VolumeMuteOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function VolumeMuteOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeMuteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root720();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1720();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeMuteOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2720();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeMuteOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeMuteOutline = hmr(VolumeMuteOutline, () => VolumeMuteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeMuteOutline[HMR].source;
    set(VolumeMuteOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeMuteOutline_default = VolumeMuteOutline;

// node_modules/flowbite-svelte-icons/dist/VolumeMuteSolid.svelte
VolumeMuteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeMuteSolid.svelte";
var root_1721 = add_locations(from_svg(`<title> </title>`), VolumeMuteSolid[FILENAME], [[41, 4]]);
var root_2721 = add_locations(from_svg(`<desc> </desc>`), VolumeMuteSolid[FILENAME], [[44, 4]]);
var root721 = add_locations(from_svg(`<svg><!><!><path d="M5.707 4.293a1 1 0 0 0-1.414 1.414l14 14a1 1 0 0 0 1.414-1.414l-.004-.005C21.57 16.498 22 13.938 22 12a9.972 9.972 0 0 0-2.929-7.071 1 1 0 1 0-1.414 1.414A7.972 7.972 0 0 1 20 12c0 1.752-.403 3.636-1.712 4.873l-1.433-1.433C17.616 14.37 18 13.107 18 12c0-1.678-.69-3.197-1.8-4.285a1 1 0 1 0-1.4 1.428A3.985 3.985 0 0 1 16 12c0 .606-.195 1.335-.59 1.996L13 11.586V6.135c0-1.696-1.978-2.622-3.28-1.536L7.698 6.284l-1.99-1.991ZM4 8h.586L13 16.414v1.451c0 1.696-1.978 2.622-3.28 1.536L5.638 16H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2Z"></path></svg>`), VolumeMuteSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function VolumeMuteSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeMuteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root721();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1721();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeMuteSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2721();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeMuteSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeMuteSolid = hmr(VolumeMuteSolid, () => VolumeMuteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeMuteSolid[HMR].source;
    set(VolumeMuteSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeMuteSolid_default = VolumeMuteSolid;

// node_modules/flowbite-svelte-icons/dist/VolumeUpOutline.svelte
VolumeUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeUpOutline.svelte";
var root_1722 = add_locations(from_svg(`<title> </title>`), VolumeUpOutline[FILENAME], [[43, 4]]);
var root_2722 = add_locations(from_svg(`<desc> </desc>`), VolumeUpOutline[FILENAME], [[46, 4]]);
var root722 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.5 8.43A4.985 4.985 0 0 1 17 12a4.984 4.984 0 0 1-1.43 3.5m2.794 2.864A8.972 8.972 0 0 0 21 12a8.972 8.972 0 0 0-2.636-6.364M12 6.135v11.73a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"></path></svg>`), VolumeUpOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function VolumeUpOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root722();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1722();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeUpOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2722();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeUpOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeUpOutline = hmr(VolumeUpOutline, () => VolumeUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeUpOutline[HMR].source;
    set(VolumeUpOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeUpOutline_default = VolumeUpOutline;

// node_modules/flowbite-svelte-icons/dist/VolumeUpSolid.svelte
VolumeUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeUpSolid.svelte";
var root_1723 = add_locations(from_svg(`<title> </title>`), VolumeUpSolid[FILENAME], [[41, 4]]);
var root_2723 = add_locations(from_svg(`<desc> </desc>`), VolumeUpSolid[FILENAME], [[44, 4]]);
var root723 = add_locations(from_svg(`<svg><!><!><path d="M13 6.037c0-1.724-1.978-2.665-3.28-1.562L5.638 7.933H4c-1.105 0-2 .91-2 2.034v4.066c0 1.123.895 2.034 2 2.034h1.638l4.082 3.458c1.302 1.104 3.28.162 3.28-1.562V6.037Z"></path><path fill-rule="evenodd" d="M14.786 7.658a.988.988 0 0 1 1.414-.014A6.135 6.135 0 0 1 18 12c0 1.662-.655 3.17-1.715 4.27a.989.989 0 0 1-1.414.014 1.029 1.029 0 0 1-.014-1.437A4.085 4.085 0 0 0 16 12a4.085 4.085 0 0 0-1.2-2.904 1.029 1.029 0 0 1-.014-1.438Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M17.657 4.811a.988.988 0 0 1 1.414 0A10.224 10.224 0 0 1 22 12c0 2.807-1.12 5.35-2.929 7.189a.988.988 0 0 1-1.414 0 1.029 1.029 0 0 1 0-1.438A8.173 8.173 0 0 0 20 12a8.173 8.173 0 0 0-2.343-5.751 1.029 1.029 0 0 1 0-1.438Z" clip-rule="evenodd"></path></svg>`), VolumeUpSolid[FILENAME], [[30, 0, [[46, 2], [49, 2], [54, 2]]]]);
function VolumeUpSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VolumeUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root723();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1723();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VolumeUpSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2723();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VolumeUpSolid,
      43,
      2
    );
  }
  next(3);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VolumeUpSolid = hmr(VolumeUpSolid, () => VolumeUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeUpSolid[HMR].source;
    set(VolumeUpSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeUpSolid_default = VolumeUpSolid;

// node_modules/flowbite-svelte-icons/dist/VueSolid.svelte
VueSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VueSolid.svelte";
var root_1724 = add_locations(from_svg(`<title> </title>`), VueSolid[FILENAME], [[41, 4]]);
var root_2724 = add_locations(from_svg(`<desc> </desc>`), VueSolid[FILENAME], [[44, 4]]);
var root724 = add_locations(from_svg(`<svg><!><!><path d="M14.5 3 12 7.156 9.857 3H2l10 18L22 3h-7.5ZM4.486 4.5h2.4L12 13.8l5.107-9.3h2.4L12 18.021 4.486 4.5Z"></path></svg>`), VueSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function VueSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, VueSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root724();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1724();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      VueSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2724();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      VueSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  VueSolid = hmr(VueSolid, () => VueSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VueSolid[HMR].source;
    set(VueSolid[HMR].source, module.default[HMR].original);
  });
}
var VueSolid_default = VueSolid;

// node_modules/flowbite-svelte-icons/dist/WalletOutline.svelte
WalletOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WalletOutline.svelte";
var root_1725 = add_locations(from_svg(`<title> </title>`), WalletOutline[FILENAME], [[43, 4]]);
var root_2725 = add_locations(from_svg(`<desc> </desc>`), WalletOutline[FILENAME], [[46, 4]]);
var root725 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 8H5m12 0a1 1 0 0 1 1 1v2.6M17 8l-4-4M5 8a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.6M5 8l4-4 4 4m6 4h-4a2 2 0 1 0 0 4h4a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z"></path></svg>`), WalletOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WalletOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WalletOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root725();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1725();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WalletOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2725();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WalletOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WalletOutline = hmr(WalletOutline, () => WalletOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WalletOutline[HMR].source;
    set(WalletOutline[HMR].source, module.default[HMR].original);
  });
}
var WalletOutline_default = WalletOutline;

// node_modules/flowbite-svelte-icons/dist/WalletSolid.svelte
WalletSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WalletSolid.svelte";
var root_1726 = add_locations(from_svg(`<title> </title>`), WalletSolid[FILENAME], [[41, 4]]);
var root_2726 = add_locations(from_svg(`<desc> </desc>`), WalletSolid[FILENAME], [[44, 4]]);
var root726 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 14a3 3 0 0 1 3-3h4a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-4a3 3 0 0 1-3-3Zm3-1a1 1 0 1 0 0 2h4v-2h-4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M12.293 3.293a1 1 0 0 1 1.414 0L16.414 6h-2.828l-1.293-1.293a1 1 0 0 1 0-1.414ZM12.414 6 9.707 3.293a1 1 0 0 0-1.414 0L5.586 6h6.828ZM4.586 7l-.056.055A2 2 0 0 0 3 9v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2h-4a5 5 0 0 1 0-10h4a2 2 0 0 0-1.53-1.945L17.414 7H4.586Z" clip-rule="evenodd"></path></svg>`), WalletSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function WalletSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WalletSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root726();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1726();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WalletSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2726();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WalletSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WalletSolid = hmr(WalletSolid, () => WalletSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WalletSolid[HMR].source;
    set(WalletSolid[HMR].source, module.default[HMR].original);
  });
}
var WalletSolid_default = WalletSolid;

// node_modules/flowbite-svelte-icons/dist/WandMagicSparklesOutline.svelte
WandMagicSparklesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WandMagicSparklesOutline.svelte";
var root_1727 = add_locations(from_svg(`<title> </title>`), WandMagicSparklesOutline[FILENAME], [[43, 4]]);
var root_2727 = add_locations(from_svg(`<desc> </desc>`), WandMagicSparklesOutline[FILENAME], [[46, 4]]);
var root727 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.872 9.687 20 6.56 17.44 4 4 17.44 6.56 20 16.873 9.687Zm0 0-2.56-2.56M6 7v2m0 0v2m0-2H4m2 0h2m7 7v2m0 0v2m0-2h-2m2 0h2M8 4h.01v.01H8V4Zm2 2h.01v.01H10V6Zm2-2h.01v.01H12V4Zm8 8h.01v.01H20V12Zm-2 2h.01v.01H18V14Zm2 2h.01v.01H20V16Z"></path></svg>`), WandMagicSparklesOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WandMagicSparklesOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WandMagicSparklesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root727();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1727();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WandMagicSparklesOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2727();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WandMagicSparklesOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WandMagicSparklesOutline = hmr(WandMagicSparklesOutline, () => WandMagicSparklesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WandMagicSparklesOutline[HMR].source;
    set(WandMagicSparklesOutline[HMR].source, module.default[HMR].original);
  });
}
var WandMagicSparklesOutline_default = WandMagicSparklesOutline;

// node_modules/flowbite-svelte-icons/dist/WandMagicSparklesSolid.svelte
WandMagicSparklesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WandMagicSparklesSolid.svelte";
var root_1728 = add_locations(from_svg(`<title> </title>`), WandMagicSparklesSolid[FILENAME], [[41, 4]]);
var root_2728 = add_locations(from_svg(`<desc> </desc>`), WandMagicSparklesSolid[FILENAME], [[44, 4]]);
var root728 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M17.44 3a1 1 0 0 1 .707.293l2.56 2.56a1 1 0 0 1 0 1.414L18.194 9.78 14.22 5.806l2.513-2.513A1 1 0 0 1 17.44 3Zm-4.634 4.22-9.513 9.513a1 1 0 0 0 0 1.414l2.56 2.56a1 1 0 0 0 1.414 0l9.513-9.513-3.974-3.974ZM6 6a1 1 0 0 1 1 1v1h1a1 1 0 0 1 0 2H7v1a1 1 0 1 1-2 0v-1H4a1 1 0 0 1 0-2h1V7a1 1 0 0 1 1-1Zm9 9a1 1 0 0 1 1 1v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 1 1 0-2h1v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M19 13h-2v2h2v-2ZM13 3h-2v2h2V3Zm-2 2H9v2h2V5ZM9 3H7v2h2V3Zm12 8h-2v2h2v-2Zm0 4h-2v2h2v-2Z"></path></svg>`), WandMagicSparklesSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function WandMagicSparklesSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WandMagicSparklesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root728();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1728();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WandMagicSparklesSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2728();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WandMagicSparklesSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WandMagicSparklesSolid = hmr(WandMagicSparklesSolid, () => WandMagicSparklesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WandMagicSparklesSolid[HMR].source;
    set(WandMagicSparklesSolid[HMR].source, module.default[HMR].original);
  });
}
var WandMagicSparklesSolid_default = WandMagicSparklesSolid;

// node_modules/flowbite-svelte-icons/dist/WaterBottleOutline.svelte
WaterBottleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WaterBottleOutline.svelte";
var root_1729 = add_locations(from_svg(`<title> </title>`), WaterBottleOutline[FILENAME], [[43, 4]]);
var root_2729 = add_locations(from_svg(`<desc> </desc>`), WaterBottleOutline[FILENAME], [[46, 4]]);
var root729 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 6v2s-3 1-3 3.25 1 2.25 1 3-1 1.125-1 2.25V19c0 .9375 1 2 2.5 2s2-.9375 2-.9375S13 21 14.5 21s2.5-1.0625 2.5-2v-2.5c0-1.125-1-1.5-1-2.25s1-.75 1-3S14 8 14 8V6m-3 0h-1V3h5v3h-1m-3 0h3m-5.95629 6h8.91259M8 17h9"></path></svg>`), WaterBottleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WaterBottleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WaterBottleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root729();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1729();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WaterBottleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2729();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WaterBottleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WaterBottleOutline = hmr(WaterBottleOutline, () => WaterBottleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WaterBottleOutline[HMR].source;
    set(WaterBottleOutline[HMR].source, module.default[HMR].original);
  });
}
var WaterBottleOutline_default = WaterBottleOutline;

// node_modules/flowbite-svelte-icons/dist/WaterBottleSolid.svelte
WaterBottleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WaterBottleSolid.svelte";
var root_1730 = add_locations(from_svg(`<title> </title>`), WaterBottleSolid[FILENAME], [[41, 4]]);
var root_2730 = add_locations(from_svg(`<desc> </desc>`), WaterBottleSolid[FILENAME], [[44, 4]]);
var root730 = add_locations(from_svg(`<svg><!><!><path d="M9 3c0-.55228.44772-1 1-1h5c.5523 0 1 .44772 1 1v2c0 .55228-.4477 1-1 1h-5c-.55228 0-1-.44772-1-1V3Zm-.12662 5c-.79243.57264-1.76284 1.55553-1.86463 3H17.9913c-.1018-1.44447-1.0723-2.42736-1.8647-3H8.87338Zm8.88162 5H7.24496c.15128.4553.35264.7798.54427 1.0396.05399.0733.09613.1308.12882.1755l.04722.0644c-.03725.0584-.08278.1174-.15764.2145-.02941.0382-.06333.0822-.10306.1343-.22586.2965-.54312.7403-.6595 1.3717H17.9549c-.1163-.6314-.4336-1.0752-.6595-1.3717-.0397-.0521-.0736-.0961-.103-.1343-.0749-.0971-.1204-.1562-.1577-.2145l.0472-.0644c.0327-.0446.0749-.1022.1289-.1755.1916-.2598.393-.5843.5442-1.0396ZM18 18H7v1c0 1.611 1.57732 3 3.5 3 .8707 0 1.5288-.2471 2-.5549.4712.3078 1.1293.5549 2 .5549 1.9227 0 3.5-1.389 3.5-3v-1Z"></path></svg>`), WaterBottleSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WaterBottleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WaterBottleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root730();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1730();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WaterBottleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2730();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WaterBottleSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WaterBottleSolid = hmr(WaterBottleSolid, () => WaterBottleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WaterBottleSolid[HMR].source;
    set(WaterBottleSolid[HMR].source, module.default[HMR].original);
  });
}
var WaterBottleSolid_default = WaterBottleSolid;

// node_modules/flowbite-svelte-icons/dist/WhatsappSolid.svelte
WhatsappSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WhatsappSolid.svelte";
var root_1731 = add_locations(from_svg(`<title> </title>`), WhatsappSolid[FILENAME], [[41, 4]]);
var root_2731 = add_locations(from_svg(`<desc> </desc>`), WhatsappSolid[FILENAME], [[44, 4]]);
var root731 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M12 4a8 8 0 0 0-6.895 12.06l.569.718-.697 2.359 2.32-.648.379.243A8 8 0 1 0 12 4ZM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10a9.96 9.96 0 0 1-5.016-1.347l-4.948 1.382 1.426-4.829-.006-.007-.033-.055A9.958 9.958 0 0 1 2 12Z" clip-rule="evenodd"></path><path d="M16.735 13.492c-.038-.018-1.497-.736-1.756-.83a1.008 1.008 0 0 0-.34-.075c-.196 0-.362.098-.49.291-.146.217-.587.732-.723.886-.018.02-.042.045-.057.045-.013 0-.239-.093-.307-.123-1.564-.68-2.751-2.313-2.914-2.589-.023-.04-.024-.057-.024-.057.005-.021.058-.074.085-.101.08-.079.166-.182.249-.283l.117-.14c.121-.14.175-.25.237-.375l.033-.066a.68.68 0 0 0-.02-.64c-.034-.069-.65-1.555-.715-1.711-.158-.377-.366-.552-.655-.552-.027 0 0 0-.112.005-.137.005-.883.104-1.213.311-.35.22-.94.924-.94 2.16 0 1.112.705 2.162 1.008 2.561l.041.06c1.161 1.695 2.608 2.951 4.074 3.537 1.412.564 2.081.63 2.461.63.16 0 .288-.013.4-.024l.072-.007c.488-.043 1.56-.599 1.804-1.276.192-.534.243-1.117.115-1.329-.088-.144-.239-.216-.43-.308Z"></path></svg>`), WhatsappSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function WhatsappSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WhatsappSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root731();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1731();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WhatsappSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2731();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WhatsappSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WhatsappSolid = hmr(WhatsappSolid, () => WhatsappSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WhatsappSolid[HMR].source;
    set(WhatsappSolid[HMR].source, module.default[HMR].original);
  });
}
var WhatsappSolid_default = WhatsappSolid;

// node_modules/flowbite-svelte-icons/dist/WheatExclamationOutline.svelte
WheatExclamationOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WheatExclamationOutline.svelte";
var root_1732 = add_locations(from_svg(`<title> </title>`), WheatExclamationOutline[FILENAME], [[43, 4]]);
var root_2732 = add_locations(from_svg(`<desc> </desc>`), WheatExclamationOutline[FILENAME], [[46, 4]]);
var root732 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.54025 15.4598c-.15524.0503-.82936-1.9171-.89837-2.3619-.08825-.5688.03111-1.7696.15081-1.7963.1197-.0267.68672 1.2412.75573 1.686.06901.4447.14706 2.4219-.00817 2.4722Zm0 0c-.00841-.163 2.06645-.3049 2.51395-.2565.5722.062 1.7012.4881 1.696.6106-.0052.1225-1.3766.3421-1.8241.2936-.4475-.0484-2.37745-.4848-2.38585-.6477Zm3.71475-3.7147L4 20m8.255-8.2549 6.6038-6.6039m-6.6038 6.6039c-.1553.0503-.8294-1.91714-.8984-2.36191-.0883-.56876.0311-1.76956.1508-1.79626.1197-.0267.6867 1.24116.7557 1.68593.069.44477.1471 2.42194-.0081 2.47224Zm0 0c-.0084-.163 2.0664-.3049 2.5139-.2565.5722.062 1.7012.4881 1.696.6106-.0052.1225-1.3766.3421-1.8241.2936-.4475-.0484-2.3774-.4848-2.3858-.6477ZM20 8.95298l-1.2713 1.27132m-3.6816-6.22427-1.2713 1.27129M19.99 20H20m-.01-3v-3M5.26953 18.7305c-.15523.0503-.82935-1.9171-.89836-2.3619-.08825-.5687.0311-1.7696.1508-1.7963.1197-.0267.68673 1.2412.75574 1.686.06901.4447.14705 2.4219-.00818 2.4722Zm0 0c-.0084-.163 2.06645-.3049 2.51393-.2565.57221.062 1.70121.4881 1.69602.6106-.00519.1226-1.37661.3421-1.82408.2937-.44748-.0485-2.37746-.4848-2.38587-.6478Z"></path></svg>`), WheatExclamationOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WheatExclamationOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WheatExclamationOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root732();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1732();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WheatExclamationOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2732();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WheatExclamationOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WheatExclamationOutline = hmr(WheatExclamationOutline, () => WheatExclamationOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WheatExclamationOutline[HMR].source;
    set(WheatExclamationOutline[HMR].source, module.default[HMR].original);
  });
}
var WheatExclamationOutline_default = WheatExclamationOutline;

// node_modules/flowbite-svelte-icons/dist/WheatOutline.svelte
WheatOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WheatOutline.svelte";
var root_1733 = add_locations(from_svg(`<title> </title>`), WheatOutline[FILENAME], [[43, 4]]);
var root_2733 = add_locations(from_svg(`<desc> </desc>`), WheatOutline[FILENAME], [[46, 4]]);
var root733 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.54025 15.4598c-.15524.0503-.82936-1.9171-.89837-2.3619-.08825-.5688.03111-1.7696.15081-1.7963.1197-.0267.68672 1.2412.75573 1.686.06901.4447.14706 2.4219-.00817 2.4722Zm0 0c-.00841-.163 2.06645-.3049 2.51395-.2565.5722.062 1.7012.4881 1.696.6106-.0052.1225-1.3766.3421-1.8241.2936-.4475-.0484-2.37745-.4848-2.38585-.6477Zm3.71475-3.7147L4 20m8.255-8.2549 6.6038-6.6039m-6.6038 6.6039c-.1553.0503-.8294-1.91714-.8984-2.36191-.0883-.56876.0311-1.76956.1508-1.79626.1197-.0267.6867 1.24116.7557 1.68593.069.44477.1471 2.42194-.0081 2.47224Zm0 0c-.0084-.163 2.0664-.3049 2.5139-.2565.5722.062 1.7012.4881 1.696.6106-.0052.1225-1.3766.3421-1.8241.2936-.4475-.0484-2.3774-.4848-2.3858-.6477ZM20 8.95298l-1.2713 1.27132m-3.6816-6.22427-1.2713 1.27129M5.26953 18.7305c-.15523.0503-.82935-1.9171-.89836-2.3619-.08825-.5687.0311-1.7696.1508-1.7963.1197-.0267.68673 1.2412.75574 1.686.06901.4447.14705 2.4219-.00818 2.4722Zm0 0c-.0084-.163 2.06645-.3049 2.51393-.2565.57221.062 1.70121.4881 1.69602.6106-.00519.1226-1.37661.3421-1.82408.2937-.44748-.0485-2.37746-.4848-2.38587-.6478Z"></path></svg>`), WheatOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WheatOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WheatOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root733();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1733();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WheatOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2733();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WheatOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WheatOutline = hmr(WheatOutline, () => WheatOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WheatOutline[HMR].source;
    set(WheatOutline[HMR].source, module.default[HMR].original);
  });
}
var WheatOutline_default = WheatOutline;

// node_modules/flowbite-svelte-icons/dist/WhiskeyGlassOutline.svelte
WhiskeyGlassOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WhiskeyGlassOutline.svelte";
var root_1734 = add_locations(from_svg(`<title> </title>`), WhiskeyGlassOutline[FILENAME], [[43, 4]]);
var root_2734 = add_locations(from_svg(`<desc> </desc>`), WhiskeyGlassOutline[FILENAME], [[46, 4]]);
var root734 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 14h10M6 7l.84717 10.1661C6.93356 18.2027 7.80009 19 8.84027 19h6.31943c1.0402 0 1.9067-.7973 1.9931-1.8339L18 7H6Z"></path></svg>`), WhiskeyGlassOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WhiskeyGlassOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WhiskeyGlassOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root734();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1734();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WhiskeyGlassOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2734();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WhiskeyGlassOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WhiskeyGlassOutline = hmr(WhiskeyGlassOutline, () => WhiskeyGlassOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WhiskeyGlassOutline[HMR].source;
    set(WhiskeyGlassOutline[HMR].source, module.default[HMR].original);
  });
}
var WhiskeyGlassOutline_default = WhiskeyGlassOutline;

// node_modules/flowbite-svelte-icons/dist/WhiskeyGlassSolid.svelte
WhiskeyGlassSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WhiskeyGlassSolid.svelte";
var root_1735 = add_locations(from_svg(`<title> </title>`), WhiskeyGlassSolid[FILENAME], [[41, 4]]);
var root_2735 = add_locations(from_svg(`<desc> </desc>`), WhiskeyGlassSolid[FILENAME], [[44, 4]]);
var root735 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M6 6c-.27965 0-.54652.1171-.73588.32289-.18935.20579-.28389.48147-.26066.76016l.84717 10.16605C5.9802 18.804 7.28 20 8.84027 20h6.31943c1.5603 0 2.8601-1.196 2.9897-2.7509l.8471-10.16605c.0233-.27869-.0713-.55437-.2606-.76016C18.5465 6.1171 18.2797 6 18 6H6Zm1.50347 7L7.0868 8h9.8264l-.4167 5H7.50347Z" clip-rule="evenodd"></path></svg>`), WhiskeyGlassSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WhiskeyGlassSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WhiskeyGlassSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root735();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1735();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WhiskeyGlassSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2735();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WhiskeyGlassSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WhiskeyGlassSolid = hmr(WhiskeyGlassSolid, () => WhiskeyGlassSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WhiskeyGlassSolid[HMR].source;
    set(WhiskeyGlassSolid[HMR].source, module.default[HMR].original);
  });
}
var WhiskeyGlassSolid_default = WhiskeyGlassSolid;

// node_modules/flowbite-svelte-icons/dist/WindowOutline.svelte
WindowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowOutline.svelte";
var root_1736 = add_locations(from_svg(`<title> </title>`), WindowOutline[FILENAME], [[43, 4]]);
var root_2736 = add_locations(from_svg(`<desc> </desc>`), WindowOutline[FILENAME], [[46, 4]]);
var root736 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 8h.01M9 8h.01M12 8h.01M4 11h16M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), WindowOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WindowOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WindowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root736();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1736();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WindowOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2736();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WindowOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WindowOutline = hmr(WindowOutline, () => WindowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowOutline[HMR].source;
    set(WindowOutline[HMR].source, module.default[HMR].original);
  });
}
var WindowOutline_default = WindowOutline;

// node_modules/flowbite-svelte-icons/dist/WindowRestoreSolid.svelte
WindowRestoreSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowRestoreSolid.svelte";
var root_1737 = add_locations(from_svg(`<title> </title>`), WindowRestoreSolid[FILENAME], [[41, 4]]);
var root_2737 = add_locations(from_svg(`<desc> </desc>`), WindowRestoreSolid[FILENAME], [[44, 4]]);
var root737 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8 5a1 1 0 0 1 1-1h11a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-1a1 1 0 1 1 0-2h1V6H9a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M4 7a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2H4Zm0 11v-5.5h11V18H4Z" clip-rule="evenodd"></path></svg>`), WindowRestoreSolid[FILENAME], [[30, 0, [[46, 2], [51, 2]]]]);
function WindowRestoreSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WindowRestoreSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root737();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1737();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WindowRestoreSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2737();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WindowRestoreSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WindowRestoreSolid = hmr(WindowRestoreSolid, () => WindowRestoreSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowRestoreSolid[HMR].source;
    set(WindowRestoreSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowRestoreSolid_default = WindowRestoreSolid;

// node_modules/flowbite-svelte-icons/dist/WindowSolid.svelte
WindowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowSolid.svelte";
var root_1738 = add_locations(from_svg(`<title> </title>`), WindowSolid[FILENAME], [[41, 4]]);
var root_2738 = add_locations(from_svg(`<desc> </desc>`), WindowSolid[FILENAME], [[44, 4]]);
var root738 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm16 7H4v7h16v-7ZM5 8a1 1 0 0 1 1-1h.01a1 1 0 0 1 0 2H6a1 1 0 0 1-1-1Zm4-1a1 1 0 0 0 0 2h.01a1 1 0 0 0 0-2H9Zm2 1a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H12a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), WindowSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WindowSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WindowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root738();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1738();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WindowSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2738();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WindowSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WindowSolid = hmr(WindowSolid, () => WindowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowSolid[HMR].source;
    set(WindowSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowSolid_default = WindowSolid;

// node_modules/flowbite-svelte-icons/dist/WindowsSolid.svelte
WindowsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowsSolid.svelte";
var root_1739 = add_locations(from_svg(`<title> </title>`), WindowsSolid[FILENAME], [[41, 4]]);
var root_2739 = add_locations(from_svg(`<desc> </desc>`), WindowsSolid[FILENAME], [[44, 4]]);
var root739 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M3.005 12 3 6.408l6.8-.923v6.517H3.005ZM11 5.32 19.997 4v8H11V5.32ZM20.067 13l-.069 8-9.065-1.275L11 13h9.067ZM9.8 19.58l-6.795-.931V13H9.8v6.58Z" clip-rule="evenodd"></path></svg>`), WindowsSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WindowsSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WindowsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root739();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1739();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WindowsSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2739();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WindowsSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WindowsSolid = hmr(WindowsSolid, () => WindowsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowsSolid[HMR].source;
    set(WindowsSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowsSolid_default = WindowsSolid;

// node_modules/flowbite-svelte-icons/dist/WineBottleOutline.svelte
WineBottleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineBottleOutline.svelte";
var root_1740 = add_locations(from_svg(`<title> </title>`), WineBottleOutline[FILENAME], [[43, 4]]);
var root_2740 = add_locations(from_svg(`<desc> </desc>`), WineBottleOutline[FILENAME], [[46, 4]]);
var root740 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 8h4m-3-5c-.5523 0-1 .44772-1 1v6c-2 1-2 2.5-2 4.5V20c0 .5523.44772 1 1 1h6c.5523 0 1-.4477 1-1v-5.5c0-2 0-3.5-2-4.5V4c0-.55228-.4477-1-1-1h-2Zm5 10h-4v5h4v-5Z"></path></svg>`), WineBottleOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WineBottleOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineBottleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root740();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1740();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineBottleOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2740();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineBottleOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineBottleOutline = hmr(WineBottleOutline, () => WineBottleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineBottleOutline[HMR].source;
    set(WineBottleOutline[HMR].source, module.default[HMR].original);
  });
}
var WineBottleOutline_default = WineBottleOutline;

// node_modules/flowbite-svelte-icons/dist/WineBottleSolid.svelte
WineBottleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineBottleSolid.svelte";
var root_1741 = add_locations(from_svg(`<title> </title>`), WineBottleSolid[FILENAME], [[41, 4]]);
var root_2741 = add_locations(from_svg(`<desc> </desc>`), WineBottleSolid[FILENAME], [[44, 4]]);
var root741 = add_locations(from_svg(`<svg><!><!><path d="M9.00004 4c0-1.10457.89543-2 1.99996-2h2c1.1046 0 2 .89543 2 2v3H9.00004V4Zm0 5v.41924c-.87786.56584-1.41239 1.28066-1.69868 2.13956-.30199.9059-.30165 1.9228-.30134 2.8523L7.00004 20c0 1.1047.89549 2 2 2H15c1.1046 0 2-.8954 2-2v-1h-4.9999c-.5523 0-1-.4477-1-1v-5c0-.5523.4477-1 1-1h4.8213c-.034-.1494-.0745-.2967-.1227-.4412-.2863-.8589-.8208-1.57372-1.6987-2.13956V9H9.00004Z"></path><path d="M17 14h-3.9999v3H17v-3Z"></path></svg>`), WineBottleSolid[FILENAME], [[30, 0, [[46, 2], [48, 5]]]]);
function WineBottleSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineBottleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root741();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1741();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineBottleSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2741();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineBottleSolid,
      43,
      2
    );
  }
  next(2);
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineBottleSolid = hmr(WineBottleSolid, () => WineBottleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineBottleSolid[HMR].source;
    set(WineBottleSolid[HMR].source, module.default[HMR].original);
  });
}
var WineBottleSolid_default = WineBottleSolid;

// node_modules/flowbite-svelte-icons/dist/WineGlassEmptyOutline.svelte
WineGlassEmptyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineGlassEmptyOutline.svelte";
var root_1742 = add_locations(from_svg(`<title> </title>`), WineGlassEmptyOutline[FILENAME], [[43, 4]]);
var root_2742 = add_locations(from_svg(`<desc> </desc>`), WineGlassEmptyOutline[FILENAME], [[46, 4]]);
var root742 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 14c2.7614 0 5-2.6679 5-5.42928C17 7.18458 15.8809 4.06255 15.5 3h-7C8.15198 4.02095 7 7.17202 7 8.57072 7 11.3321 9.23858 14 12 14Zm0 0v7m-3 0h6"></path></svg>`), WineGlassEmptyOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WineGlassEmptyOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineGlassEmptyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root742();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1742();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineGlassEmptyOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2742();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineGlassEmptyOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineGlassEmptyOutline = hmr(WineGlassEmptyOutline, () => WineGlassEmptyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineGlassEmptyOutline[HMR].source;
    set(WineGlassEmptyOutline[HMR].source, module.default[HMR].original);
  });
}
var WineGlassEmptyOutline_default = WineGlassEmptyOutline;

// node_modules/flowbite-svelte-icons/dist/WineGlassEmptySolid.svelte
WineGlassEmptySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineGlassEmptySolid.svelte";
var root_1743 = add_locations(from_svg(`<title> </title>`), WineGlassEmptySolid[FILENAME], [[41, 4]]);
var root_2743 = add_locations(from_svg(`<desc> </desc>`), WineGlassEmptySolid[FILENAME], [[44, 4]]);
var root743 = add_locations(from_svg(`<svg><!><!><path d="M8.5 2c-.42794 0-.80845.2723-.94652.67736-.03443.10101-.07815.2268-.12882.3726-.1952.56172-.4936 1.42039-.76192 2.30283C6.33766 6.42192 6 7.69926 6 8.57072c0 2.88418 2.09201 5.78348 5 6.33548V20H9c-.55228 0-1 .4477-1 1s.44772 1 1 1h6c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2v-5.0938c2.908-.552 5-3.4513 5-6.33548 0-.86275-.3278-2.12695-.6497-3.1952-.3348-1.11124-.7167-2.17674-.9075-2.70901l-.0015-.00395C16.2989 2.26514 15.9222 2 15.5 2h-7Z"></path></svg>`), WineGlassEmptySolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WineGlassEmptySolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineGlassEmptySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root743();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1743();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineGlassEmptySolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2743();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineGlassEmptySolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineGlassEmptySolid = hmr(WineGlassEmptySolid, () => WineGlassEmptySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineGlassEmptySolid[HMR].source;
    set(WineGlassEmptySolid[HMR].source, module.default[HMR].original);
  });
}
var WineGlassEmptySolid_default = WineGlassEmptySolid;

// node_modules/flowbite-svelte-icons/dist/WineGlassOutline.svelte
WineGlassOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineGlassOutline.svelte";
var root_1744 = add_locations(from_svg(`<title> </title>`), WineGlassOutline[FILENAME], [[43, 4]]);
var root_2744 = add_locations(from_svg(`<desc> </desc>`), WineGlassOutline[FILENAME], [[46, 4]]);
var root744 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 14c2.7614 0 5-2.6679 5-5.42928C17 7.18458 15.8809 4.06255 15.5 3h-7C8.15198 4.02095 7 7.17202 7 8.57072 7 11.3321 9.23858 14 12 14Zm0 0v7m0 0H9m3 0h3M7 9h9"></path></svg>`), WineGlassOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function WineGlassOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineGlassOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root744();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1744();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineGlassOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2744();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineGlassOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineGlassOutline = hmr(WineGlassOutline, () => WineGlassOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineGlassOutline[HMR].source;
    set(WineGlassOutline[HMR].source, module.default[HMR].original);
  });
}
var WineGlassOutline_default = WineGlassOutline;

// node_modules/flowbite-svelte-icons/dist/WineGlassSolid.svelte
WineGlassSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WineGlassSolid.svelte";
var root_1745 = add_locations(from_svg(`<title> </title>`), WineGlassSolid[FILENAME], [[41, 4]]);
var root_2745 = add_locations(from_svg(`<desc> </desc>`), WineGlassSolid[FILENAME], [[44, 4]]);
var root745 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M8.5 2c-.42794 0-.80845.2723-.94652.67736-.03443.10101-.07815.2268-.12882.3726-.1952.56172-.4936 1.42039-.76192 2.30283C6.33766 6.42192 6 7.69926 6 8.57072c0 .10149.00259.20301.00772.30444C6.00262 8.91606 6 8.95772 6 9c0 .10098.01497.19846.0428.29034C6.35415 11.9216 8.33422 14.4001 11 14.9062V20H9c-.55228 0-1 .4477-1 1s.44772 1 1 1h6c.5523 0 1-.4477 1-1s-.4477-1-1-1h-2v-5.0938c2.908-.552 5-3.4513 5-6.33548 0-.86275-.3278-2.12695-.6497-3.1952-.3348-1.11124-.7167-2.17674-.9075-2.70901l-.0015-.00395C16.2989 2.26514 15.9222 2 15.5 2h-7Zm-.44291 6h7.88661c-.088-.54205-.2729-1.26599-.5084-2.0475-.2149-.71327-.4515-1.41069-.6413-1.9525H9.21208c-.18553.53611-.41939 1.22278-.63584 1.93462C8.33663 6.72266 8.14708 7.4535 8.05709 8Z" clip-rule="evenodd"></path></svg>`), WineGlassSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function WineGlassSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, WineGlassSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root745();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1745();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      WineGlassSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2745();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      WineGlassSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  WineGlassSolid = hmr(WineGlassSolid, () => WineGlassSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WineGlassSolid[HMR].source;
    set(WineGlassSolid[HMR].source, module.default[HMR].original);
  });
}
var WineGlassSolid_default = WineGlassSolid;

// node_modules/flowbite-svelte-icons/dist/XSolid.svelte
XSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/XSolid.svelte";
var root_1746 = add_locations(from_svg(`<title> </title>`), XSolid[FILENAME], [[41, 4]]);
var root_2746 = add_locations(from_svg(`<desc> </desc>`), XSolid[FILENAME], [[44, 4]]);
var root746 = add_locations(from_svg(`<svg><!><!><path d="M13.795 10.533 20.68 2h-3.073l-5.255 6.517L7.69 2H1l7.806 10.91L1.47 22h3.074l5.705-7.07L15.31 22H22l-8.205-11.467Zm-2.38 2.95L9.97 11.464 4.36 3.627h2.31l4.528 6.317 1.443 2.02 6.018 8.409h-2.31l-4.934-6.89Z"></path></svg>`), XSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function XSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, XSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root746();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1746();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      XSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2746();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      XSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  XSolid = hmr(XSolid, () => XSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = XSolid[HMR].source;
    set(XSolid[HMR].source, module.default[HMR].original);
  });
}
var XSolid_default = XSolid;

// node_modules/flowbite-svelte-icons/dist/YoutubeSolid.svelte
YoutubeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/YoutubeSolid.svelte";
var root_1747 = add_locations(from_svg(`<title> </title>`), YoutubeSolid[FILENAME], [[41, 4]]);
var root_2747 = add_locations(from_svg(`<desc> </desc>`), YoutubeSolid[FILENAME], [[44, 4]]);
var root747 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M21.7 8.037a4.26 4.26 0 0 0-.789-1.964 2.84 2.84 0 0 0-1.984-.839c-2.767-.2-6.926-.2-6.926-.2s-4.157 0-6.928.2a2.836 2.836 0 0 0-1.983.839 4.225 4.225 0 0 0-.79 1.965 30.146 30.146 0 0 0-.2 3.206v1.5a30.12 30.12 0 0 0 .2 3.206c.094.712.364 1.39.784 1.972.604.536 1.38.837 2.187.848 1.583.151 6.731.2 6.731.2s4.161 0 6.928-.2a2.844 2.844 0 0 0 1.985-.84 4.27 4.27 0 0 0 .787-1.965 30.12 30.12 0 0 0 .2-3.206v-1.516a30.672 30.672 0 0 0-.202-3.206Zm-11.692 6.554v-5.62l5.4 2.819-5.4 2.801Z" clip-rule="evenodd"></path></svg>`), YoutubeSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function YoutubeSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, YoutubeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root747();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1747();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      YoutubeSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2747();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      YoutubeSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  YoutubeSolid = hmr(YoutubeSolid, () => YoutubeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = YoutubeSolid[HMR].source;
    set(YoutubeSolid[HMR].source, module.default[HMR].original);
  });
}
var YoutubeSolid_default = YoutubeSolid;

// node_modules/flowbite-svelte-icons/dist/ZoomInOutline.svelte
ZoomInOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomInOutline.svelte";
var root_1748 = add_locations(from_svg(`<title> </title>`), ZoomInOutline[FILENAME], [[43, 4]]);
var root_2748 = add_locations(from_svg(`<desc> </desc>`), ZoomInOutline[FILENAME], [[46, 4]]);
var root748 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M10 7v6m-3-3h6m4 0a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), ZoomInOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ZoomInOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ZoomInOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root748();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1748();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ZoomInOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2748();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ZoomInOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ZoomInOutline = hmr(ZoomInOutline, () => ZoomInOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomInOutline[HMR].source;
    set(ZoomInOutline[HMR].source, module.default[HMR].original);
  });
}
var ZoomInOutline_default = ZoomInOutline;

// node_modules/flowbite-svelte-icons/dist/ZoomInSolid.svelte
ZoomInSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomInSolid.svelte";
var root_1749 = add_locations(from_svg(`<title> </title>`), ZoomInSolid[FILENAME], [[41, 4]]);
var root_2749 = add_locations(from_svg(`<desc> </desc>`), ZoomInSolid[FILENAME], [[44, 4]]);
var root749 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm9-3a1 1 0 1 0-2 0v2H7a1 1 0 0 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2V7Z" clip-rule="evenodd"></path></svg>`), ZoomInSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ZoomInSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ZoomInSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root749();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1749();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ZoomInSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2749();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ZoomInSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ZoomInSolid = hmr(ZoomInSolid, () => ZoomInSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomInSolid[HMR].source;
    set(ZoomInSolid[HMR].source, module.default[HMR].original);
  });
}
var ZoomInSolid_default = ZoomInSolid;

// node_modules/flowbite-svelte-icons/dist/ZoomOutOutline.svelte
ZoomOutOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomOutOutline.svelte";
var root_1750 = add_locations(from_svg(`<title> </title>`), ZoomOutOutline[FILENAME], [[43, 4]]);
var root_2750 = add_locations(from_svg(`<desc> </desc>`), ZoomOutOutline[FILENAME], [[46, 4]]);
var root750 = add_locations(from_svg(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M7 10h6m4 0a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), ZoomOutOutline[FILENAME], [[31, 0, [[48, 2]]]]);
function ZoomOutOutline($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ZoomOutOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root750();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1750();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ZoomOutOutline,
      42,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2750();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ZoomOutOutline,
      45,
      2
    );
  }
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => set_attribute(path, "stroke-width", strokeWidth()));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ZoomOutOutline = hmr(ZoomOutOutline, () => ZoomOutOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomOutOutline[HMR].source;
    set(ZoomOutOutline[HMR].source, module.default[HMR].original);
  });
}
var ZoomOutOutline_default = ZoomOutOutline;

// node_modules/flowbite-svelte-icons/dist/ZoomOutSolid.svelte
ZoomOutSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomOutSolid.svelte";
var root_1751 = add_locations(from_svg(`<title> </title>`), ZoomOutSolid[FILENAME], [[41, 4]]);
var root_2751 = add_locations(from_svg(`<desc> </desc>`), ZoomOutSolid[FILENAME], [[44, 4]]);
var root751 = add_locations(from_svg(`<svg><!><!><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 0 1 1h6a1 1 0 1 0 0-2H7a1 1 0 0 0-1 1Z" clip-rule="evenodd"></path></svg>`), ZoomOutSolid[FILENAME], [[30, 0, [[46, 2]]]]);
function ZoomOutSolid($$anchor, $$props) {
  var _a, _b, _c, _d;
  check_target(new.target);
  push($$props, true, ZoomOutSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`.trim();
  const hasDescription = !!(((_c = $$props.title) == null ? void 0 : _c.id) || ((_d = $$props.desc) == null ? void 0 : _d.id));
  const isLabeled = !!$$props.ariaLabel || hasDescription;
  var $$exports = { ...legacy_api() };
  var svg = root751();
  attribute_effect(
    svg,
    ($0) => ({
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: $0,
      viewBox: "0 0 24 24",
      "aria-label": $$props.ariaLabel,
      "aria-describedby": hasDescription ? ariaDescribedby : void 0,
      "aria-hidden": !isLabeled
    }),
    [() => cn("shrink-0", sizes[size()], $$props.class)]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var title_1 = root_1751();
      var text = child(title_1, true);
      reset(title_1);
      template_effect(() => {
        set_attribute(title_1, "id", $$props.title.id);
        set_text(text, $$props.title.title);
      });
      append($$anchor2, title_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        var _a2;
        if (((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title) $$render(consequent);
      }),
      "if",
      ZoomOutSolid,
      40,
      2
    );
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var desc_1 = root_2751();
      var text_1 = child(desc_1, true);
      reset(desc_1);
      template_effect(() => {
        set_attribute(desc_1, "id", $$props.desc.id);
        set_text(text_1, $$props.desc.desc);
      });
      append($$anchor2, desc_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        var _a2;
        if (((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc) $$render(consequent_1);
      }),
      "if",
      ZoomOutSolid,
      43,
      2
    );
  }
  next();
  reset(svg);
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  ZoomOutSolid = hmr(ZoomOutSolid, () => ZoomOutSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomOutSolid[HMR].source;
    set(ZoomOutSolid[HMR].source, module.default[HMR].original);
  });
}
var ZoomOutSolid_default = ZoomOutSolid;
export {
  AddColumnAfterOutline_default as AddColumnAfterOutline,
  AddColumnBeforeOutline_default as AddColumnBeforeOutline,
  AddressBookOutline_default as AddressBookOutline,
  AddressBookSolid_default as AddressBookSolid,
  AdjustmentsHorizontalOutline_default as AdjustmentsHorizontalOutline,
  AdjustmentsHorizontalSolid_default as AdjustmentsHorizontalSolid,
  AdjustmentsVerticalOutline_default as AdjustmentsVerticalOutline,
  AdjustmentsVerticalSolid_default as AdjustmentsVerticalSolid,
  AlignCenterOutline_default as AlignCenterOutline,
  AlignJustifyOutline_default as AlignJustifyOutline,
  AlignLeftOutline_default as AlignLeftOutline,
  AlignRightOutline_default as AlignRightOutline,
  AngleDownOutline_default as AngleDownOutline,
  AngleLeftOutline_default as AngleLeftOutline,
  AngleRightOutline_default as AngleRightOutline,
  AngleUpOutline_default as AngleUpOutline,
  AnnotationOutline_default as AnnotationOutline,
  AnnotationSolid_default as AnnotationSolid,
  ApiKeyOutline_default as ApiKeyOutline,
  AppleFullOutline_default as AppleFullOutline,
  AppleFullSolid_default as AppleFullSolid,
  AppleSolid_default as AppleSolid,
  ArchiveArrowDownOutline_default as ArchiveArrowDownOutline,
  ArchiveArrowDownSolid_default as ArchiveArrowDownSolid,
  ArchiveOutline_default as ArchiveOutline,
  ArchiveSolid_default as ArchiveSolid,
  ArrowDownOutline_default as ArrowDownOutline,
  ArrowDownToBracketOutline_default as ArrowDownToBracketOutline,
  ArrowLeftOutline_default as ArrowLeftOutline,
  ArrowLeftToBracketOutline_default as ArrowLeftToBracketOutline,
  ArrowRightAltOutline_default as ArrowRightAltOutline,
  ArrowRightAltSolid_default as ArrowRightAltSolid,
  ArrowRightOutline_default as ArrowRightOutline,
  ArrowRightToBracketOutline_default as ArrowRightToBracketOutline,
  ArrowSortLettersOutline_default as ArrowSortLettersOutline,
  ArrowUpDownOutline_default as ArrowUpDownOutline,
  ArrowUpFromBracketOutline_default as ArrowUpFromBracketOutline,
  ArrowUpOutline_default as ArrowUpOutline,
  ArrowUpRightDownLeftOutline_default as ArrowUpRightDownLeftOutline,
  ArrowUpRightFromSquareOutline_default as ArrowUpRightFromSquareOutline,
  ArrowUpRightFromSquareSolid_default as ArrowUpRightFromSquareSolid,
  ArrowsRepeatCountOutline_default as ArrowsRepeatCountOutline,
  ArrowsRepeatOutline_default as ArrowsRepeatOutline,
  AtomOutline_default as AtomOutline,
  AwardOutline_default as AwardOutline,
  AwardSolid_default as AwardSolid,
  AwsSolid_default as AwsSolid,
  BackwardStepOutline_default as BackwardStepOutline,
  BackwardStepSolid_default as BackwardStepSolid,
  BaconOutline_default as BaconOutline,
  BaconSolid_default as BaconSolid,
  BadgeCheckOutline_default as BadgeCheckOutline,
  BadgeCheckSolid_default as BadgeCheckSolid,
  BanOutline_default as BanOutline,
  BarcodeOutline_default as BarcodeOutline,
  BarsFromLeftOutline_default as BarsFromLeftOutline,
  BarsOutline_default as BarsOutline,
  BatteryOutline_default as BatteryOutline,
  BatterySolid_default as BatterySolid,
  BedOutline_default as BedOutline,
  BedSolid_default as BedSolid,
  BeerMugEmptyOutline_default as BeerMugEmptyOutline,
  BeerMugEmptySolid_default as BeerMugEmptySolid,
  BellActiveAltOutline_default as BellActiveAltOutline,
  BellActiveAltSolid_default as BellActiveAltSolid,
  BellActiveOutline_default as BellActiveOutline,
  BellActiveSolid_default as BellActiveSolid,
  BellOutline_default as BellOutline,
  BellRingOutline_default as BellRingOutline,
  BellRingSolid_default as BellRingSolid,
  BellSolid_default as BellSolid,
  BitcoinSolid_default as BitcoinSolid,
  BlenderPhoneOutline_default as BlenderPhoneOutline,
  BlenderPhoneSolid_default as BlenderPhoneSolid,
  BoneOutline_default as BoneOutline,
  BoneSolid_default as BoneSolid,
  BookOpenOutline_default as BookOpenOutline,
  BookOpenReaderOutline_default as BookOpenReaderOutline,
  BookOpenReaderSolid_default as BookOpenReaderSolid,
  BookOpenSolid_default as BookOpenSolid,
  BookOutline_default as BookOutline,
  BookSolid_default as BookSolid,
  BookmarkOutline_default as BookmarkOutline,
  BookmarkSolid_default as BookmarkSolid,
  BoothCurtainOutline_default as BoothCurtainOutline,
  BoothCurtainSolid_default as BoothCurtainSolid,
  BowlFoodOutline_default as BowlFoodOutline,
  BowlFoodSolid_default as BowlFoodSolid,
  BowlRiceOutline_default as BowlRiceOutline,
  BowlRiceSolid_default as BowlRiceSolid,
  BrainOutline_default as BrainOutline,
  BrainSolid_default as BrainSolid,
  BreadSliceOutline_default as BreadSliceOutline,
  BreadSliceSolid_default as BreadSliceSolid,
  BriefcaseOutline_default as BriefcaseOutline,
  BriefcaseSolid_default as BriefcaseSolid,
  BugOutline_default as BugOutline,
  BugSolid_default as BugSolid,
  BuildingOutline_default as BuildingOutline,
  BuildingSolid_default as BuildingSolid,
  BullhornOutline_default as BullhornOutline,
  BullhornSolid_default as BullhornSolid,
  BurgerOutline_default as BurgerOutline,
  BurgerSolid_default as BurgerSolid,
  CakeCandlesOutline_default as CakeCandlesOutline,
  CakeCandlesSolid_default as CakeCandlesSolid,
  CalendarEditOutline_default as CalendarEditOutline,
  CalendarEditSolid_default as CalendarEditSolid,
  CalendarMonthOutline_default as CalendarMonthOutline,
  CalendarMonthSolid_default as CalendarMonthSolid,
  CalendarPlusOutline_default as CalendarPlusOutline,
  CalendarPlusSolid_default as CalendarPlusSolid,
  CalendarWeekOutline_default as CalendarWeekOutline,
  CalendarWeekSolid_default as CalendarWeekSolid,
  CameraPhotoOutline_default as CameraPhotoOutline,
  CameraPhotoSolid_default as CameraPhotoSolid,
  CandyCaneOutline_default as CandyCaneOutline,
  CandyCaneSolid_default as CandyCaneSolid,
  CaptionOutline_default as CaptionOutline,
  CaptionSolid_default as CaptionSolid,
  CaretDownOutline_default as CaretDownOutline,
  CaretDownSolid_default as CaretDownSolid,
  CaretLeftOutline_default as CaretLeftOutline,
  CaretLeftSolid_default as CaretLeftSolid,
  CaretRightOutline_default as CaretRightOutline,
  CaretRightSolid_default as CaretRightSolid,
  CaretSortOutline_default as CaretSortOutline,
  CaretSortSolid_default as CaretSortSolid,
  CaretUpOutline_default as CaretUpOutline,
  CaretUpSolid_default as CaretUpSolid,
  CarrotOutline_default as CarrotOutline,
  CarrotSolid_default as CarrotSolid,
  CartOutline_default as CartOutline,
  CartPlusAltOutline_default as CartPlusAltOutline,
  CartPlusAltSolid_default as CartPlusAltSolid,
  CartPlusOutline_default as CartPlusOutline,
  CartPlusSolid_default as CartPlusSolid,
  CartSolid_default as CartSolid,
  CashOutline_default as CashOutline,
  CashRegisterOutline_default as CashRegisterOutline,
  CashRegisterSolid_default as CashRegisterSolid,
  CashSolid_default as CashSolid,
  CellAttributesOutline_default as CellAttributesOutline,
  ChalkboardOutline_default as ChalkboardOutline,
  ChalkboardSolid_default as ChalkboardSolid,
  ChalkboardUserOutline_default as ChalkboardUserOutline,
  ChalkboardUserSolid_default as ChalkboardUserSolid,
  ChampagneGlassesOutline_default as ChampagneGlassesOutline,
  ChampagneGlassesSolid_default as ChampagneGlassesSolid,
  ChartLineDownOutline_default as ChartLineDownOutline,
  ChartLineUpOutline_default as ChartLineUpOutline,
  ChartMixedDollarOutline_default as ChartMixedDollarOutline,
  ChartMixedDollarSolid_default as ChartMixedDollarSolid,
  ChartMixedOutline_default as ChartMixedOutline,
  ChartOutline_default as ChartOutline,
  ChartPieOutline_default as ChartPieOutline,
  ChartPieSolid_default as ChartPieSolid,
  CheckCircleOutline_default as CheckCircleOutline,
  CheckCircleSolid_default as CheckCircleSolid,
  CheckOutline_default as CheckOutline,
  CheckPlusCircleOutline_default as CheckPlusCircleOutline,
  CheckPlusCircleSolid_default as CheckPlusCircleSolid,
  CheeseOutline_default as CheeseOutline,
  CheeseSolid_default as CheeseSolid,
  ChevronDoubleDownOutline_default as ChevronDoubleDownOutline,
  ChevronDoubleLeftOutline_default as ChevronDoubleLeftOutline,
  ChevronDoubleRightOutline_default as ChevronDoubleRightOutline,
  ChevronDoubleUpOutline_default as ChevronDoubleUpOutline,
  ChevronDownOutline_default as ChevronDownOutline,
  ChevronLeftOutline_default as ChevronLeftOutline,
  ChevronRightOutline_default as ChevronRightOutline,
  ChevronSortOutline_default as ChevronSortOutline,
  ChevronUpOutline_default as ChevronUpOutline,
  CircleMinusOutline_default as CircleMinusOutline,
  CircleMinusSolid_default as CircleMinusSolid,
  CirclePauseOutline_default as CirclePauseOutline,
  CirclePauseSolid_default as CirclePauseSolid,
  CirclePlusOutline_default as CirclePlusOutline,
  CirclePlusSolid_default as CirclePlusSolid,
  ClapperboardPlayOutline_default as ClapperboardPlayOutline,
  ClapperboardPlaySolid_default as ClapperboardPlaySolid,
  ClipboardCheckOutline_default as ClipboardCheckOutline,
  ClipboardCheckSolid_default as ClipboardCheckSolid,
  ClipboardCleanOutline_default as ClipboardCleanOutline,
  ClipboardCleanSolid_default as ClipboardCleanSolid,
  ClipboardListOutline_default as ClipboardListOutline,
  ClipboardListSolid_default as ClipboardListSolid,
  ClipboardOutline_default as ClipboardOutline,
  ClipboardSolid_default as ClipboardSolid,
  ClockArrowOutline_default as ClockArrowOutline,
  ClockOutline_default as ClockOutline,
  ClockSolid_default as ClockSolid,
  CloseCircleOutline_default as CloseCircleOutline,
  CloseCircleSolid_default as CloseCircleSolid,
  CloseOutline_default as CloseOutline,
  CloseSidebarAltOutline_default as CloseSidebarAltOutline,
  CloseSidebarAltSolid_default as CloseSidebarAltSolid,
  CloseSidebarOutline_default as CloseSidebarOutline,
  CloseSidebarSolid_default as CloseSidebarSolid,
  CloudArrowUpOutline_default as CloudArrowUpOutline,
  CloudArrowUpSolid_default as CloudArrowUpSolid,
  CloudMeatballOutline_default as CloudMeatballOutline,
  CloudMeatballSolid_default as CloudMeatballSolid,
  CodeBranchOutline_default as CodeBranchOutline,
  CodeBranchSolid_default as CodeBranchSolid,
  CodeForkOutline_default as CodeForkOutline,
  CodeForkSolid_default as CodeForkSolid,
  CodeMergeOutline_default as CodeMergeOutline,
  CodeMergeSolid_default as CodeMergeSolid,
  CodeOutline_default as CodeOutline,
  CodePullRequestOutline_default as CodePullRequestOutline,
  CodePullRequestSolid_default as CodePullRequestSolid,
  CogOutline_default as CogOutline,
  CogSolid_default as CogSolid,
  ColumnOutline_default as ColumnOutline,
  ColumnSolid_default as ColumnSolid,
  CommandOutline_default as CommandOutline,
  CompressOutline_default as CompressOutline,
  ComputerSpeakerOutline_default as ComputerSpeakerOutline,
  ComputerSpeakerSolid_default as ComputerSpeakerSolid,
  CookieOutline_default as CookieOutline,
  CookieSolid_default as CookieSolid,
  CreditCardOutline_default as CreditCardOutline,
  CreditCardPlusAltOutline_default as CreditCardPlusAltOutline,
  CreditCardPlusAltSolid_default as CreditCardPlusAltSolid,
  CreditCardPlusOutline_default as CreditCardPlusOutline,
  CreditCardPlusSolid_default as CreditCardPlusSolid,
  CreditCardSolid_default as CreditCardSolid,
  CssSolid_default as CssSolid,
  CubeSolid_default as CubeSolid,
  CubesStackedOutline_default as CubesStackedOutline,
  CubesStackedSolid_default as CubesStackedSolid,
  DatabaseOutline_default as DatabaseOutline,
  DatabaseSolid_default as DatabaseSolid,
  DeleteColumnOutline_default as DeleteColumnOutline,
  DeleteRowOutline_default as DeleteRowOutline,
  DeleteTableOutline_default as DeleteTableOutline,
  DesktopPcOutline_default as DesktopPcOutline,
  DesktopPcSolid_default as DesktopPcSolid,
  DiscordSolid_default as DiscordSolid,
  DnaOutline_default as DnaOutline,
  DollarOutline_default as DollarOutline,
  DotsHorizontalOutline_default as DotsHorizontalOutline,
  DotsVerticalOutline_default as DotsVerticalOutline,
  DownloadOutline_default as DownloadOutline,
  DownloadSolid_default as DownloadSolid,
  DrawSquareOutline_default as DrawSquareOutline,
  DrawSquareSolid_default as DrawSquareSolid,
  DribbbleSolid_default as DribbbleSolid,
  DropboxSolid_default as DropboxSolid,
  DropletBottleAltOutline_default as DropletBottleAltOutline,
  DropletBottleAltSolid_default as DropletBottleAltSolid,
  DropletBottleOutline_default as DropletBottleOutline,
  DropletBottleSolid_default as DropletBottleSolid,
  DrumstickBiteOutline_default as DrumstickBiteOutline,
  DrumstickBiteSolid_default as DrumstickBiteSolid,
  EditOutline_default as EditOutline,
  EditSolid_default as EditSolid,
  EggOutline_default as EggOutline,
  EggSolid_default as EggSolid,
  EnvelopeOpenOutline_default as EnvelopeOpenOutline,
  EnvelopeOpenSolid_default as EnvelopeOpenSolid,
  EnvelopeOutline_default as EnvelopeOutline,
  EnvelopeSolid_default as EnvelopeSolid,
  EuroOutline_default as EuroOutline,
  ExclamationCircleOutline_default as ExclamationCircleOutline,
  ExclamationCircleSolid_default as ExclamationCircleSolid,
  ExpandOutline_default as ExpandOutline,
  EyeOutline_default as EyeOutline,
  EyeSlashOutline_default as EyeSlashOutline,
  EyeSlashSolid_default as EyeSlashSolid,
  EyeSolid_default as EyeSolid,
  FaceExplodeOutline_default as FaceExplodeOutline,
  FaceExplodeSolid_default as FaceExplodeSolid,
  FaceGrinOutline_default as FaceGrinOutline,
  FaceGrinSolid_default as FaceGrinSolid,
  FaceGrinStarsOutline_default as FaceGrinStarsOutline,
  FaceGrinStarsSolid_default as FaceGrinStarsSolid,
  FaceLaughOutline_default as FaceLaughOutline,
  FaceLaughSolid_default as FaceLaughSolid,
  FacebookSolid_default as FacebookSolid,
  FileChartBarOutline_default as FileChartBarOutline,
  FileChartBarSolid_default as FileChartBarSolid,
  FileCheckOutline_default as FileCheckOutline,
  FileCheckSolid_default as FileCheckSolid,
  FileCirclePlusOutline_default as FileCirclePlusOutline,
  FileCirclePlusSolid_default as FileCirclePlusSolid,
  FileCloneOutline_default as FileCloneOutline,
  FileCloneSolid_default as FileCloneSolid,
  FileCodeOutline_default as FileCodeOutline,
  FileCodeSolid_default as FileCodeSolid,
  FileCopyAltOutline_default as FileCopyAltOutline,
  FileCopyAltSolid_default as FileCopyAltSolid,
  FileCopyOutline_default as FileCopyOutline,
  FileCopySolid_default as FileCopySolid,
  FileCsvOutline_default as FileCsvOutline,
  FileCsvSolid_default as FileCsvSolid,
  FileDocOutline_default as FileDocOutline,
  FileDocSolid_default as FileDocSolid,
  FileExportOutline_default as FileExportOutline,
  FileExportSolid_default as FileExportSolid,
  FileImageOutline_default as FileImageOutline,
  FileImageSolid_default as FileImageSolid,
  FileImportOutline_default as FileImportOutline,
  FileImportSolid_default as FileImportSolid,
  FileInvoiceOutline_default as FileInvoiceOutline,
  FileInvoiceSolid_default as FileInvoiceSolid,
  FileLinesOutline_default as FileLinesOutline,
  FileLinesSolid_default as FileLinesSolid,
  FileMusicOutline_default as FileMusicOutline,
  FileMusicSolid_default as FileMusicSolid,
  FileOutline_default as FileOutline,
  FilePasteOutline_default as FilePasteOutline,
  FilePasteSolid_default as FilePasteSolid,
  FilePdfOutline_default as FilePdfOutline,
  FilePdfSolid_default as FilePdfSolid,
  FilePenOutline_default as FilePenOutline,
  FilePenSolid_default as FilePenSolid,
  FilePptOutline_default as FilePptOutline,
  FilePptSolid_default as FilePptSolid,
  FileSearchOutline_default as FileSearchOutline,
  FileSearchSolid_default as FileSearchSolid,
  FileShieldOutline_default as FileShieldOutline,
  FileShieldSolid_default as FileShieldSolid,
  FileSolid_default as FileSolid,
  FileVideoOutline_default as FileVideoOutline,
  FileVideoSolid_default as FileVideoSolid,
  FileWordOutline_default as FileWordOutline,
  FileWordSolid_default as FileWordSolid,
  FileZipOutline_default as FileZipOutline,
  FileZipSolid_default as FileZipSolid,
  FilterDollarOutline_default as FilterDollarOutline,
  FilterDollarSolid_default as FilterDollarSolid,
  FilterOutline_default as FilterOutline,
  FilterSolid_default as FilterSolid,
  FingerprintOutline_default as FingerprintOutline,
  FireOutline_default as FireOutline,
  FireSolid_default as FireSolid,
  FishAltOutline_default as FishAltOutline,
  FishAltSolid_default as FishAltSolid,
  FishOutline_default as FishOutline,
  FishSolid_default as FishSolid,
  FixTablesOutline_default as FixTablesOutline,
  FlagOutline_default as FlagOutline,
  FlagSolid_default as FlagSolid,
  FlaskOutline_default as FlaskOutline,
  FlaskSolid_default as FlaskSolid,
  FloppyDiskAltOutline_default as FloppyDiskAltOutline,
  FloppyDiskAltSolid_default as FloppyDiskAltSolid,
  FloppyDiskOutline_default as FloppyDiskOutline,
  FloppyDiskSolid_default as FloppyDiskSolid,
  FlowbiteSolid_default as FlowbiteSolid,
  FolderArrowRightOutline_default as FolderArrowRightOutline,
  FolderArrowRightSolid_default as FolderArrowRightSolid,
  FolderDuplicateOutline_default as FolderDuplicateOutline,
  FolderDuplicateSolid_default as FolderDuplicateSolid,
  FolderOpenOutline_default as FolderOpenOutline,
  FolderOpenSolid_default as FolderOpenSolid,
  FolderOutline_default as FolderOutline,
  FolderPlusOutline_default as FolderPlusOutline,
  FolderPlusSolid_default as FolderPlusSolid,
  FolderSolid_default as FolderSolid,
  FontColorAltSolid_default as FontColorAltSolid,
  FontColorOutline_default as FontColorOutline,
  FontFamilyOutline_default as FontFamilyOutline,
  FontHighlightOutline_default as FontHighlightOutline,
  ForwardOutline_default as ForwardOutline,
  ForwardSolid_default as ForwardSolid,
  ForwardStepOutline_default as ForwardStepOutline,
  ForwardStepSolid_default as ForwardStepSolid,
  GiftBoxOutline_default as GiftBoxOutline,
  GiftBoxSolid_default as GiftBoxSolid,
  GithubSolid_default as GithubSolid,
  GitlabSolid_default as GitlabSolid,
  GlassWaterDropletOutline_default as GlassWaterDropletOutline,
  GlassWaterDropletSolid_default as GlassWaterDropletSolid,
  GlassWaterOutline_default as GlassWaterOutline,
  GlassWaterSolid_default as GlassWaterSolid,
  GlobeOutline_default as GlobeOutline,
  GlobeSolid_default as GlobeSolid,
  GoToNextCellOutline_default as GoToNextCellOutline,
  GoToPrevCellOutline_default as GoToPrevCellOutline,
  GoogleSolid_default as GoogleSolid,
  GraduationCapOutline_default as GraduationCapOutline,
  GraduationCapSolid_default as GraduationCapSolid,
  GridOutline_default as GridOutline,
  GridPlusOutline_default as GridPlusOutline,
  GridPlusSolid_default as GridPlusSolid,
  GridSolid_default as GridSolid,
  HammerOutline_default as HammerOutline,
  HammerSolid_default as HammerSolid,
  HeadphonesOutline_default as HeadphonesOutline,
  HeadphonesSolid_default as HeadphonesSolid,
  HeartOutline_default as HeartOutline,
  HeartSolid_default as HeartSolid,
  HomeOutline_default as HomeOutline,
  HomeSolid_default as HomeSolid,
  HorizontalLinesOutline_default as HorizontalLinesOutline,
  HotdogOutline_default as HotdogOutline,
  HotdogSolid_default as HotdogSolid,
  HourglassOutline_default as HourglassOutline,
  HourglassSolid_default as HourglassSolid,
  HtmlSolid_default as HtmlSolid,
  IcecreamAltOutline_default as IcecreamAltOutline,
  IcecreamAltSolid_default as IcecreamAltSolid,
  IcecreamOutline_default as IcecreamOutline,
  IcecreamSolid_default as IcecreamSolid,
  IconOutline_default as IconOutline,
  IconSolid_default as IconSolid,
  ImageOutline_default as ImageOutline,
  ImageSolid_default as ImageSolid,
  InboxFullOutline_default as InboxFullOutline,
  InboxFullSolid_default as InboxFullSolid,
  InboxOutline_default as InboxOutline,
  InboxSolid_default as InboxSolid,
  IncomingCallOutline_default as IncomingCallOutline,
  IncomingCallSolid_default as IncomingCallSolid,
  IndentOutline_default as IndentOutline,
  IndentSolid_default as IndentSolid,
  InfoCircleOutline_default as InfoCircleOutline,
  InfoCircleSolid_default as InfoCircleSolid,
  InsertRowAfterOutline_default as InsertRowAfterOutline,
  InsertRowBeforeOutline_default as InsertRowBeforeOutline,
  InsertTableAltOutline_default as InsertTableAltOutline,
  InsertTableOutline_default as InsertTableOutline,
  InstagramSolid_default as InstagramSolid,
  JarOutline_default as JarOutline,
  JarSolid_default as JarSolid,
  JarWheatOutline_default as JarWheatOutline,
  JarWheatSolid_default as JarWheatSolid,
  KeyboardOutline_default as KeyboardOutline,
  KeyboardSolid_default as KeyboardSolid,
  LabelOutline_default as LabelOutline,
  LabelSolid_default as LabelSolid,
  LandmarkOutline_default as LandmarkOutline,
  LandmarkSolid_default as LandmarkSolid,
  LanguageOutline_default as LanguageOutline,
  LaptopCodeOutline_default as LaptopCodeOutline,
  LaptopCodeSolid_default as LaptopCodeSolid,
  LaptopFileOutline_default as LaptopFileOutline,
  LaptopFileSolid_default as LaptopFileSolid,
  LaravelSolid_default as LaravelSolid,
  LayersOutline_default as LayersOutline,
  LayersSolid_default as LayersSolid,
  LemonOutline_default as LemonOutline,
  LemonSolid_default as LemonSolid,
  LetterBoldOutline_default as LetterBoldOutline,
  LetterItalicOutline_default as LetterItalicOutline,
  LetterUnderlineOutline_default as LetterUnderlineOutline,
  LifeSaverOutline_default as LifeSaverOutline,
  LifeSaverSolid_default as LifeSaverSolid,
  LightbulbOutline_default as LightbulbOutline,
  LightbulbSolid_default as LightbulbSolid,
  LinkBreakOutline_default as LinkBreakOutline,
  LinkOutline_default as LinkOutline,
  LinkedinSolid_default as LinkedinSolid,
  ListMusicOutline_default as ListMusicOutline,
  ListMusicSolid_default as ListMusicSolid,
  ListOutline_default as ListOutline,
  LockOpenOutline_default as LockOpenOutline,
  LockOpenSolid_default as LockOpenSolid,
  LockOutline_default as LockOutline,
  LockSolid_default as LockSolid,
  LockTimeOutline_default as LockTimeOutline,
  LockTimeSolid_default as LockTimeSolid,
  MailBoxOutline_default as MailBoxOutline,
  MailBoxSolid_default as MailBoxSolid,
  MapPinAltOutline_default as MapPinAltOutline,
  MapPinAltSolid_default as MapPinAltSolid,
  MapPinOutline_default as MapPinOutline,
  MapPinSolid_default as MapPinSolid,
  MartiniGlassCitrusOutline_default as MartiniGlassCitrusOutline,
  MartiniGlassCitrusSolid_default as MartiniGlassCitrusSolid,
  MartiniGlassEmptyOutline_default as MartiniGlassEmptyOutline,
  MartiniGlassEmptySolid_default as MartiniGlassEmptySolid,
  MartiniGlassOutline_default as MartiniGlassOutline,
  MartiniGlassSolid_default as MartiniGlassSolid,
  MastercardSolid_default as MastercardSolid,
  MergeCellsOutline_default as MergeCellsOutline,
  MergeOrSplitOutline_default as MergeOrSplitOutline,
  MessageCaptionOutline_default as MessageCaptionOutline,
  MessageCaptionSolid_default as MessageCaptionSolid,
  MessageDotsOutline_default as MessageDotsOutline,
  MessageDotsSolid_default as MessageDotsSolid,
  MessagesOutline_default as MessagesOutline,
  MessagesSolid_default as MessagesSolid,
  MicrophoneOutline_default as MicrophoneOutline,
  MicrophoneSlashOutline_default as MicrophoneSlashOutline,
  MicrophoneSlashSolid_default as MicrophoneSlashSolid,
  MicrophoneSolid_default as MicrophoneSolid,
  MicroscopeOutline_default as MicroscopeOutline,
  MicroscopeSolid_default as MicroscopeSolid,
  MinimizeOutline_default as MinimizeOutline,
  MinusOutline_default as MinusOutline,
  MissedCallOutline_default as MissedCallOutline,
  MissedCallSolid_default as MissedCallSolid,
  MobilePhoneOutline_default as MobilePhoneOutline,
  MobilePhoneSolid_default as MobilePhoneSolid,
  MongoDbSolid_default as MongoDbSolid,
  MoonOutline_default as MoonOutline,
  MoonPlusOutline_default as MoonPlusOutline,
  MoonPlusSolid_default as MoonPlusSolid,
  MoonSolid_default as MoonSolid,
  MugHotOutline_default as MugHotOutline,
  MugHotSolid_default as MugHotSolid,
  MugSaucerOutline_default as MugSaucerOutline,
  MugSaucerSolid_default as MugSaucerSolid,
  MusicAltOutline_default as MusicAltOutline,
  MusicAltSolid_default as MusicAltSolid,
  MusicOutline_default as MusicOutline,
  MusicSolid_default as MusicSolid,
  NewspaperOutline_default as NewspaperOutline,
  NewspaperSolid_default as NewspaperSolid,
  NpmSolid_default as NpmSolid,
  ObjectsColumnOutline_default as ObjectsColumnOutline,
  ObjectsColumnSolid_default as ObjectsColumnSolid,
  OpenDoorOutline_default as OpenDoorOutline,
  OpenDoorSolid_default as OpenDoorSolid,
  OpenSidebarAltOutline_default as OpenSidebarAltOutline,
  OpenSidebarAltSolid_default as OpenSidebarAltSolid,
  OpenSidebarOutline_default as OpenSidebarOutline,
  OpenSidebarSolid_default as OpenSidebarSolid,
  OrderedListOutline_default as OrderedListOutline,
  OutdentOutline_default as OutdentOutline,
  OutdentSolid_default as OutdentSolid,
  OutgoingCallOutline_default as OutgoingCallOutline,
  OutgoingCallSolid_default as OutgoingCallSolid,
  PaletteOutline_default as PaletteOutline,
  PaletteSolid_default as PaletteSolid,
  PaperClipOutline_default as PaperClipOutline,
  PaperPlaneOutline_default as PaperPlaneOutline,
  PaperPlaneSolid_default as PaperPlaneSolid,
  ParagraphOutline_default as ParagraphOutline,
  ParagraphSolid_default as ParagraphSolid,
  PauseOutline_default as PauseOutline,
  PauseSolid_default as PauseSolid,
  PenNibOutline_default as PenNibOutline,
  PenNibSolid_default as PenNibSolid,
  PenOutline_default as PenOutline,
  PenSolid_default as PenSolid,
  PepperHotOutline_default as PepperHotOutline,
  PepperHotSolid_default as PepperHotSolid,
  PersonChalkboardOutline_default as PersonChalkboardOutline,
  PersonChalkboardSolid_default as PersonChalkboardSolid,
  PhoneHangupOutline_default as PhoneHangupOutline,
  PhoneHangupSolid_default as PhoneHangupSolid,
  PhoneOutline_default as PhoneOutline,
  PhoneSolid_default as PhoneSolid,
  PizzaSliceOutline_default as PizzaSliceOutline,
  PizzaSliceSolid_default as PizzaSliceSolid,
  PlateWheatOutline_default as PlateWheatOutline,
  PlateWheatSolid_default as PlateWheatSolid,
  PlayOutline_default as PlayOutline,
  PlaySolid_default as PlaySolid,
  PlusOutline_default as PlusOutline,
  PrinterOutline_default as PrinterOutline,
  PrinterSolid_default as PrinterSolid,
  ProfileCardOutline_default as ProfileCardOutline,
  ProfileCardSolid_default as ProfileCardSolid,
  QrCodeOutline_default as QrCodeOutline,
  QuestionCircleOutline_default as QuestionCircleOutline,
  QuestionCircleSolid_default as QuestionCircleSolid,
  QuoteOutline_default as QuoteOutline,
  QuoteSolid_default as QuoteSolid,
  ReactSolid_default as ReactSolid,
  ReceiptOutline_default as ReceiptOutline,
  ReceiptSolid_default as ReceiptSolid,
  RectangleListOutline_default as RectangleListOutline,
  RectangleListSolid_default as RectangleListSolid,
  RedditSolid_default as RedditSolid,
  RedoOutline_default as RedoOutline,
  RefreshOutline_default as RefreshOutline,
  ReplyAllOutline_default as ReplyAllOutline,
  ReplyAllSolid_default as ReplyAllSolid,
  ReplyOutline_default as ReplyOutline,
  ReplySolid_default as ReplySolid,
  RestoreWindowOutline_default as RestoreWindowOutline,
  RocketOutline_default as RocketOutline,
  RocketSolid_default as RocketSolid,
  RulerCombinedOutline_default as RulerCombinedOutline,
  RulerCombinedSolid_default as RulerCombinedSolid,
  SalePercentOutline_default as SalePercentOutline,
  SalePercentSolid_default as SalePercentSolid,
  ScaleBalancedOutline_default as ScaleBalancedOutline,
  ScaleBalancedSolid_default as ScaleBalancedSolid,
  SchoolAltOutline_default as SchoolAltOutline,
  SchoolAltSolid_default as SchoolAltSolid,
  SchoolCheckAltOutline_default as SchoolCheckAltOutline,
  SchoolCheckAltSolid_default as SchoolCheckAltSolid,
  SchoolCheckOutline_default as SchoolCheckOutline,
  SchoolCheckSolid_default as SchoolCheckSolid,
  SchoolExclamationAltOutline_default as SchoolExclamationAltOutline,
  SchoolExclamationAltSolid_default as SchoolExclamationAltSolid,
  SchoolExclamationOutline_default as SchoolExclamationOutline,
  SchoolExclamationSolid_default as SchoolExclamationSolid,
  SchoolFlagAltOutline_default as SchoolFlagAltOutline,
  SchoolFlagAltSolid_default as SchoolFlagAltSolid,
  SchoolFlagOutline_default as SchoolFlagOutline,
  SchoolFlagSolid_default as SchoolFlagSolid,
  SchoolLockAltOutline_default as SchoolLockAltOutline,
  SchoolLockAltSolid_default as SchoolLockAltSolid,
  SchoolLockOutline_default as SchoolLockOutline,
  SchoolLockSolid_default as SchoolLockSolid,
  SchoolOutline_default as SchoolOutline,
  SchoolSolid_default as SchoolSolid,
  SchoolXmarkAltOutline_default as SchoolXmarkAltOutline,
  SchoolXmarkAltSolid_default as SchoolXmarkAltSolid,
  SchoolXmarkOutline_default as SchoolXmarkOutline,
  SchoolXmarkSolid_default as SchoolXmarkSolid,
  SearchOutline_default as SearchOutline,
  SearchSolid_default as SearchSolid,
  SeedlingOutline_default as SeedlingOutline,
  SeedlingSolid_default as SeedlingSolid,
  ServerOutline_default as ServerOutline,
  ServerSolid_default as ServerSolid,
  ShapesOutline_default as ShapesOutline,
  ShapesSolid_default as ShapesSolid,
  ShareAllOutline_default as ShareAllOutline,
  ShareAllSolid_default as ShareAllSolid,
  ShareNodesOutline_default as ShareNodesOutline,
  ShareNodesSolid_default as ShareNodesSolid,
  ShieldCheckOutline_default as ShieldCheckOutline,
  ShieldCheckSolid_default as ShieldCheckSolid,
  ShieldOutline_default as ShieldOutline,
  ShieldSolid_default as ShieldSolid,
  ShoppingBagOutline_default as ShoppingBagOutline,
  ShoppingBagSolid_default as ShoppingBagSolid,
  ShrimpOutline_default as ShrimpOutline,
  ShrimpSolid_default as ShrimpSolid,
  ShuffleOutline_default as ShuffleOutline,
  SortHorizontalOutline_default as SortHorizontalOutline,
  SortOutline_default as SortOutline,
  SplitCellsOutline_default as SplitCellsOutline,
  StackoverflowSolid_default as StackoverflowSolid,
  StarHalfOutline_default as StarHalfOutline,
  StarHalfSolid_default as StarHalfSolid,
  StarHalfStrokeOutline_default as StarHalfStrokeOutline,
  StarHalfStrokeSolid_default as StarHalfStrokeSolid,
  StarOutline_default as StarOutline,
  StarSolid_default as StarSolid,
  StopOutline_default as StopOutline,
  StopSolid_default as StopSolid,
  StoreOutline_default as StoreOutline,
  StoreSolid_default as StoreSolid,
  StroopwafelOutline_default as StroopwafelOutline,
  StroopwafelSolid_default as StroopwafelSolid,
  SubscriptOutline_default as SubscriptOutline,
  SunOutline_default as SunOutline,
  SunSolid_default as SunSolid,
  SuperscriptOutline_default as SuperscriptOutline,
  SwatchbookOutline_default as SwatchbookOutline,
  SwatchbookSolid_default as SwatchbookSolid,
  TShirtOutline_default as TShirtOutline,
  TShirtSolid_default as TShirtSolid,
  TableColumnOutline_default as TableColumnOutline,
  TableColumnSolid_default as TableColumnSolid,
  TableRowOutline_default as TableRowOutline,
  TableRowSolid_default as TableRowSolid,
  TabletOutline_default as TabletOutline,
  TabletSolid_default as TabletSolid,
  TagOutline_default as TagOutline,
  TagSolid_default as TagSolid,
  TailwindSolid_default as TailwindSolid,
  TeddyBearOutline_default as TeddyBearOutline,
  TeddyBearSolid_default as TeddyBearSolid,
  TerminalOutline_default as TerminalOutline,
  TerminalSolid_default as TerminalSolid,
  TextSizeOutline_default as TextSizeOutline,
  TextSlashOutline_default as TextSlashOutline,
  TextUnderlineOutline_default as TextUnderlineOutline,
  TheatreOutline_default as TheatreOutline,
  TheatreSolid_default as TheatreSolid,
  ThumbsDownOutline_default as ThumbsDownOutline,
  ThumbsDownSolid_default as ThumbsDownSolid,
  ThumbsUpOutline_default as ThumbsUpOutline,
  ThumbsUpSolid_default as ThumbsUpSolid,
  ThumbtackOutline_default as ThumbtackOutline,
  ThumbtackSolid_default as ThumbtackSolid,
  TicketOutline_default as TicketOutline,
  TicketSolid_default as TicketSolid,
  ToggleHeaderCellOutline_default as ToggleHeaderCellOutline,
  ToggleHeaderColumnOutline_default as ToggleHeaderColumnOutline,
  ToggleHeaderRowOutline_default as ToggleHeaderRowOutline,
  ToolsOutline_default as ToolsOutline,
  TrackingOutline_default as TrackingOutline,
  TrackingSolid_default as TrackingSolid,
  TrashBinOutline_default as TrashBinOutline,
  TrashBinSolid_default as TrashBinSolid,
  TruckClockOutline_default as TruckClockOutline,
  TruckClockSolid_default as TruckClockSolid,
  TruckOutline_default as TruckOutline,
  TruckSolid_default as TruckSolid,
  TwitterSolid_default as TwitterSolid,
  UndoOutline_default as UndoOutline,
  UploadOutline_default as UploadOutline,
  UploadSolid_default as UploadSolid,
  UserAddOutline_default as UserAddOutline,
  UserAddSolid_default as UserAddSolid,
  UserCircleOutline_default as UserCircleOutline,
  UserCircleSolid_default as UserCircleSolid,
  UserEditOutline_default as UserEditOutline,
  UserEditSolid_default as UserEditSolid,
  UserGraduateOutline_default as UserGraduateOutline,
  UserGraduateSolid_default as UserGraduateSolid,
  UserHeadsetOutline_default as UserHeadsetOutline,
  UserHeadsetSolid_default as UserHeadsetSolid,
  UserOutline_default as UserOutline,
  UserRemoveOutline_default as UserRemoveOutline,
  UserRemoveSolid_default as UserRemoveSolid,
  UserSettingsOutline_default as UserSettingsOutline,
  UserSettingsSolid_default as UserSettingsSolid,
  UserSolid_default as UserSolid,
  UsersGroupOutline_default as UsersGroupOutline,
  UsersGroupSolid_default as UsersGroupSolid,
  UsersOutline_default as UsersOutline,
  UsersSolid_default as UsersSolid,
  VideoCameraOutline_default as VideoCameraOutline,
  VideoCameraSolid_default as VideoCameraSolid,
  VisaSolid_default as VisaSolid,
  VolumeDownOutline_default as VolumeDownOutline,
  VolumeDownSolid_default as VolumeDownSolid,
  VolumeMuteOutline_default as VolumeMuteOutline,
  VolumeMuteSolid_default as VolumeMuteSolid,
  VolumeUpOutline_default as VolumeUpOutline,
  VolumeUpSolid_default as VolumeUpSolid,
  VueSolid_default as VueSolid,
  WalletOutline_default as WalletOutline,
  WalletSolid_default as WalletSolid,
  WandMagicSparklesOutline_default as WandMagicSparklesOutline,
  WandMagicSparklesSolid_default as WandMagicSparklesSolid,
  WaterBottleOutline_default as WaterBottleOutline,
  WaterBottleSolid_default as WaterBottleSolid,
  WhatsappSolid_default as WhatsappSolid,
  WheatExclamationOutline_default as WheatExclamationOutline,
  WheatOutline_default as WheatOutline,
  WhiskeyGlassOutline_default as WhiskeyGlassOutline,
  WhiskeyGlassSolid_default as WhiskeyGlassSolid,
  WindowOutline_default as WindowOutline,
  WindowRestoreSolid_default as WindowRestoreSolid,
  WindowSolid_default as WindowSolid,
  WindowsSolid_default as WindowsSolid,
  WineBottleOutline_default as WineBottleOutline,
  WineBottleSolid_default as WineBottleSolid,
  WineGlassEmptyOutline_default as WineGlassEmptyOutline,
  WineGlassEmptySolid_default as WineGlassEmptySolid,
  WineGlassOutline_default as WineGlassOutline,
  WineGlassSolid_default as WineGlassSolid,
  XSolid_default as XSolid,
  YoutubeSolid_default as YoutubeSolid,
  ZoomInOutline_default as ZoomInOutline,
  ZoomInSolid_default as ZoomInSolid,
  ZoomOutOutline_default as ZoomOutOutline,
  ZoomOutSolid_default as ZoomOutSolid
};
//# sourceMappingURL=flowbite-svelte-icons.js.map
